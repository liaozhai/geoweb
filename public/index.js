(function () {
  'use strict';

  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

    _regeneratorRuntime = function () {
      return exports;
    };

    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");

          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }

          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);

            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }

            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if ("throw" !== record.type) {
          var result = record.arg,
              value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }

        reject(record.arg);
      }

      var previousPromise;

      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

            return next.value = undefined, next.done = !0, next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }

    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];

      for (var key in object) keys.push(key);

      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }

        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;

        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
              record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/
  // Variable to hold current primary touch event identifier.
  // iOS needs this since it does not attribute
  // identifier 0 to primary touch event.
  var primaryTouchId = null; // Variable to hold mouse pointer captures.

  if (!("PointerEvent" in window)) {
    // Define {set,release}PointerCapture
    definePointerCapture(); // Create Pointer polyfill from mouse events only on non-touch device

    if (!("TouchEvent" in window)) {
      addMouseToPointerListener(document, "mousedown", "pointerdown");
      addMouseToPointerListener(document, "mousemove", "pointermove");
      addMouseToPointerListener(document, "mouseup", "pointerup");
    } // Define Pointer polyfill from touch events


    addTouchToPointerListener(document, "touchstart", "pointerdown");
    addTouchToPointerListener(document, "touchmove", "pointermove");
    addTouchToPointerListener(document, "touchend", "pointerup");
  } // Function defining {set,release}PointerCapture from {set,releas}Capture


  function definePointerCapture() {
    Element.prototype.setPointerCapture = Element.prototype.setCapture;
    Element.prototype.releasePointerCapture = Element.prototype.releaseCapture;
  } // Function converting a Mouse event to a Pointer event.


  function addMouseToPointerListener(target, mouseType, pointerType) {
    target.addEventListener(mouseType, function (mouseEvent) {
      var pointerEvent = new MouseEvent(pointerType, mouseEvent);
      pointerEvent.pointerId = 1;
      pointerEvent.isPrimary = true;
      pointerEvent.pointerType = "mouse";
      pointerEvent.width = 1;
      pointerEvent.height = 1;
      pointerEvent.tiltX = 0;
      pointerEvent.tiltY = 0; // pressure is 0.5 if a button is holded

      "buttons" in mouseEvent && mouseEvent.buttons !== 0 ? pointerEvent.pressure = 0.5 : pointerEvent.pressure = 0; // if already capturing mouse event, transfer target
      // and don't forget implicit release on mouseup.

      var target = mouseEvent.target;

      target.dispatchEvent(pointerEvent);

      if (pointerEvent.defaultPrevented) {
        mouseEvent.preventDefault();
      }
    });
  } // Function converting a Touch event to a Pointer event.


  function addTouchToPointerListener(target, touchType, pointerType) {
    target.addEventListener(touchType, function (touchEvent) {
      var changedTouches = touchEvent.changedTouches;
      var nbTouches = changedTouches.length;

      for (var t = 0; t < nbTouches; t++) {
        var pointerEvent = new CustomEvent(pointerType, {
          bubbles: true,
          cancelable: true
        });
        pointerEvent.ctrlKey = touchEvent.ctrlKey;
        pointerEvent.shiftKey = touchEvent.shiftKey;
        pointerEvent.altKey = touchEvent.altKey;
        pointerEvent.metaKey = touchEvent.metaKey;
        var touch = changedTouches.item(t);
        pointerEvent.clientX = touch.clientX;
        pointerEvent.clientY = touch.clientY;
        pointerEvent.screenX = touch.screenX;
        pointerEvent.screenY = touch.screenY;
        pointerEvent.pageX = touch.pageX;
        pointerEvent.pageY = touch.pageY;
        var rect = touch.target.getBoundingClientRect();
        pointerEvent.offsetX = touch.clientX - rect.left;
        pointerEvent.offsetY = touch.clientY - rect.top;
        pointerEvent.pointerId = 1 + touch.identifier; // Default values for standard MouseEvent fields.

        pointerEvent.button = 0;
        pointerEvent.buttons = 1;
        pointerEvent.movementX = 0;
        pointerEvent.movementY = 0;
        pointerEvent.region = null;
        pointerEvent.relatedTarget = null;
        pointerEvent.x = pointerEvent.clientX;
        pointerEvent.y = pointerEvent.clientY; // Pointer event details

        pointerEvent.pointerType = "touch";
        pointerEvent.width = 1;
        pointerEvent.height = 1;
        pointerEvent.tiltX = 0;
        pointerEvent.tiltY = 0;
        pointerEvent.pressure = 1; // First touch is the primary pointer event.

        if (touchType === "touchstart" && primaryTouchId === null) {
          primaryTouchId = touch.identifier;
        }

        pointerEvent.isPrimary = touch.identifier === primaryTouchId; // If first touch ends, reset primary touch id.

        if (touchType === "touchend" && pointerEvent.isPrimary) {
          primaryTouchId = null;
        }

        touchEvent.target.dispatchEvent(pointerEvent);

        if (pointerEvent.defaultPrevented) {
          touchEvent.preventDefault();
        }
      }
    });
  }

  /**
   * @module ol/events/Event
   */

  /**
   * @classdesc
   * Stripped down implementation of the W3C DOM Level 2 Event interface.
   * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
   *
   * This implementation only provides `type` and `target` properties, and
   * `stopPropagation` and `preventDefault` methods. It is meant as base class
   * for higher level events defined in the library, and works with
   * {@link module:ol/events/Target~Target}.
   */
  var BaseEvent = /*#__PURE__*/function () {
    /**
     * @param {string} type Type.
     */
    function BaseEvent(type) {
      _classCallCheck(this, BaseEvent);

      /**
       * @type {boolean}
       */
      this.propagationStopped;
      /**
       * @type {boolean}
       */

      this.defaultPrevented;
      /**
       * The event type.
       * @type {string}
       * @api
       */

      this.type = type;
      /**
       * The event target.
       * @type {Object}
       * @api
       */

      this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */


    _createClass(BaseEvent, [{
      key: "preventDefault",
      value: function preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */

    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this.propagationStopped = true;
      }
    }]);

    return BaseEvent;
  }();

  /**
   * @module ol/ObjectEventType
   */

  /**
   * @enum {string}
   */
  var ObjectEventType = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: 'propertychange'
  };
  /**
   * @typedef {'propertychange'} Types
   */

  /**
   * @module ol/Disposable
   */

  /**
   * @classdesc
   * Objects that need to clean up after themselves.
   */
  var Disposable = /*#__PURE__*/function () {
    function Disposable() {
      _classCallCheck(this, Disposable);

      /**
       * The object has already been disposed.
       * @type {boolean}
       * @protected
       */
      this.disposed = false;
    }
    /**
     * Clean up.
     */


    _createClass(Disposable, [{
      key: "dispose",
      value: function dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {}
    }]);

    return Disposable;
  }();

  /**
   * @module ol/array
   */

  /**
   * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
   * https://github.com/darkskyapp/binary-search
   *
   * @param {Array<*>} haystack Items to search through.
   * @param {*} needle The item to look for.
   * @param {Function} [comparator] Comparator function.
   * @return {number} The index of the item if found, -1 if not.
   */
  function binarySearch$1(haystack, needle, comparator) {
    var mid, cmp;
    comparator = comparator || numberSafeCompareFunction;
    var low = 0;
    var high = haystack.length;
    var found = false;

    while (low < high) {
      /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
       * to double (which gives the wrong results). */
      mid = low + (high - low >> 1);
      cmp = +comparator(haystack[mid], needle);

      if (cmp < 0.0) {
        /* Too low. */
        low = mid + 1;
      } else {
        /* Key found or too high */
        high = mid;
        found = !cmp;
      }
    }
    /* Key not found. */


    return found ? low : ~low;
  }
  /**
   * Compare function for array sort that is safe for numbers.
   * @param {*} a The first object to be compared.
   * @param {*} b The second object to be compared.
   * @return {number} A negative number, zero, or a positive number as the first
   *     argument is less than, equal to, or greater than the second.
   */

  function numberSafeCompareFunction(a, b) {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  /**
   * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
   * of this type to determine which nearest resolution to use.
   *
   * This function takes a `{number}` representing a value between two array entries,
   * a `{number}` representing the value of the nearest higher entry and
   * a `{number}` representing the value of the nearest lower entry
   * as arguments and returns a `{number}`. If a negative number or zero is returned
   * the lower value will be used, if a positive number is returned the higher value
   * will be used.
   * @typedef {function(number, number, number): number} NearestDirectionFunction
   * @api
   */

  /**
   * @param {Array<number>} arr Array in descending order.
   * @param {number} target Target.
   * @param {number|NearestDirectionFunction} direction
   *    0 means return the nearest,
   *    > 0 means return the largest nearest,
   *    < 0 means return the smallest nearest.
   * @return {number} Index.
   */

  function linearFindNearest(arr, target, direction) {
    var n = arr.length;

    if (arr[0] <= target) {
      return 0;
    } else if (target <= arr[n - 1]) {
      return n - 1;
    } else {
      var i;

      if (direction > 0) {
        for (i = 1; i < n; ++i) {
          if (arr[i] < target) {
            return i - 1;
          }
        }
      } else if (direction < 0) {
        for (i = 1; i < n; ++i) {
          if (arr[i] <= target) {
            return i;
          }
        }
      } else {
        for (i = 1; i < n; ++i) {
          if (arr[i] == target) {
            return i;
          } else if (arr[i] < target) {
            if (typeof direction === 'function') {
              if (direction(target, arr[i - 1], arr[i]) > 0) {
                return i - 1;
              } else {
                return i;
              }
            } else if (arr[i - 1] - target < target - arr[i]) {
              return i - 1;
            } else {
              return i;
            }
          }
        }
      }

      return n - 1;
    }
  }
  /**
   * @param {Array<VALUE>} arr The array to modify.
   * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
   * @template VALUE
   */

  function extend$1(arr, data) {
    var extension = Array.isArray(data) ? data : [data];
    var length = extension.length;

    for (var i = 0; i < length; i++) {
      arr[arr.length] = extension[i];
    }
  }
  /**
   * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
   * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
   * @return {boolean} Whether the two arrays are equal.
   */

  function equals$3(arr1, arr2) {
    var len1 = arr1.length;

    if (len1 !== arr2.length) {
      return false;
    }

    for (var i = 0; i < len1; i++) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }

    return true;
  }
  /**
   * @param {Array<*>} arr The array to test.
   * @param {Function} [func] Comparison function.
   * @param {boolean} [strict] Strictly sorted (default false).
   * @return {boolean} Return index.
   */

  function isSorted(arr, func, strict) {
    var compare = func || numberSafeCompareFunction;
    return arr.every(function (currentVal, index) {
      if (index === 0) {
        return true;
      }

      var res = compare(arr[index - 1], currentVal);
      return !(res > 0 || strict && res === 0);
    });
  }

  /**
   * @module ol/functions
   */
  /**
   * Always returns true.
   * @return {boolean} true.
   */

  function TRUE() {
    return true;
  }
  /**
   * Always returns false.
   * @return {boolean} false.
   */

  function FALSE() {
    return false;
  }
  /**
   * A reusable function, used e.g. as a default for callbacks.
   *
   * @return {void} Nothing.
   */

  function VOID() {}
  /**
   * Wrap a function in another function that remembers the last return.  If the
   * returned function is called twice in a row with the same arguments and the same
   * this object, it will return the value from the first call in the second call.
   *
   * @param {function(...any): ReturnType} fn The function to memoize.
   * @return {function(...any): ReturnType} The memoized function.
   * @template ReturnType
   */

  function memoizeOne(fn) {
    var called = false;
    /** @type {ReturnType} */

    var lastResult;
    /** @type {Array<any>} */

    var lastArgs;
    var lastThis;
    return function () {
      var nextArgs = Array.prototype.slice.call(arguments);

      if (!called || this !== lastThis || !equals$3(nextArgs, lastArgs)) {
        called = true;
        lastThis = this;
        lastArgs = nextArgs;
        lastResult = fn.apply(this, arguments);
      }

      return lastResult;
    };
  }
  /**
   * @template T
   * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
   * @return {Promise<T>} A promise for the value.
   */

  function toPromise(getter) {
    function promiseGetter() {
      var value;

      try {
        value = getter();
      } catch (err) {
        return Promise.reject(err);
      }

      if (value instanceof Promise) {
        return value;
      }

      return Promise.resolve(value);
    }

    return promiseGetter();
  }

  /**
   * @module ol/obj
   */

  /**
   * Removes all properties from an object.
   * @param {Object} object The object to clear.
   */
  function clear(object) {
    for (var property in object) {
      delete object[property];
    }
  }
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */

  function isEmpty$1(object) {
    var property;

    for (property in object) {
      return false;
    }

    return !property;
  }

  /**
   * @typedef {EventTarget|Target} EventTargetLike
   */

  /**
   * @classdesc
   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
   * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
   *
   * There are two important simplifications compared to the specification:
   *
   * 1. The handling of `useCapture` in `addEventListener` and
   *    `removeEventListener`. There is no real capture model.
   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
   *    There is no event target hierarchy. When a listener calls
   *    `stopPropagation` or `preventDefault` on an event object, it means that no
   *    more listeners after this one will be called. Same as when the listener
   *    returns false.
   */

  var Target = /*#__PURE__*/function (_Disposable) {
    _inherits(Target, _Disposable);

    var _super = _createSuper(Target);

    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    function Target(target) {
      var _this;

      _classCallCheck(this, Target);

      _this = _super.call(this);
      /**
       * @private
       * @type {*}
       */

      _this.eventTarget_ = target;
      /**
       * @private
       * @type {Object<string, number>}
       */

      _this.pendingRemovals_ = null;
      /**
       * @private
       * @type {Object<string, number>}
       */

      _this.dispatching_ = null;
      /**
       * @private
       * @type {Object<string, Array<import("../events.js").Listener>>}
       */

      _this.listeners_ = null;
      return _this;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */


    _createClass(Target, [{
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }

        var listeners = this.listeners_ || (this.listeners_ = {});
        var listenersForType = listeners[type] || (listeners[type] = []);

        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */

    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        var isString = typeof event === 'string';
        var type = isString ? event : event.type;
        var listeners = this.listeners_ && this.listeners_[type];

        if (!listeners) {
          return;
        }

        var evt = isString ? new BaseEvent(event) :
        /** @type {Event} */
        event;

        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }

        var dispatching = this.dispatching_ || (this.dispatching_ = {});
        var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});

        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }

        ++dispatching[type];
        var propagate;

        for (var i = 0, ii = listeners.length; i < ii; ++i) {
          if ('handleEvent' in listeners[i]) {
            propagate =
            /** @type {import("../events.js").ListenerObject} */
            listeners[i].handleEvent(evt);
          } else {
            propagate =
            /** @type {import("../events.js").ListenerFunction} */
            listeners[i].call(this, evt);
          }

          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }

        if (--dispatching[type] === 0) {
          var pr = pendingRemovals[type];
          delete pendingRemovals[type];

          while (pr--) {
            this.removeEventListener(type, VOID);
          }

          delete dispatching[type];
        }

        return propagate;
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */

    }, {
      key: "getListeners",
      value: function getListeners(type) {
        return this.listeners_ && this.listeners_[type] || undefined;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */

    }, {
      key: "hasListener",
      value: function hasListener(type) {
        if (!this.listeners_) {
          return false;
        }

        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */

    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        var listeners = this.listeners_ && this.listeners_[type];

        if (listeners) {
          var index = listeners.indexOf(listener);

          if (index !== -1) {
            if (this.pendingRemovals_ && type in this.pendingRemovals_) {
              // make listener a no-op, and remove later in #dispatchEvent()
              listeners[index] = VOID;
              ++this.pendingRemovals_[type];
            } else {
              listeners.splice(index, 1);

              if (listeners.length === 0) {
                delete this.listeners_[type];
              }
            }
          }
        }
      }
    }]);

    return Target;
  }(Disposable);

  /**
   * @module ol/events/EventType
   */

  /**
   * @enum {string}
   * @const
   */
  var EventType = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: 'change',

    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: 'error',
    BLUR: 'blur',
    CLEAR: 'clear',
    CONTEXTMENU: 'contextmenu',
    CLICK: 'click',
    DBLCLICK: 'dblclick',
    DRAGENTER: 'dragenter',
    DRAGOVER: 'dragover',
    DROP: 'drop',
    FOCUS: 'focus',
    KEYDOWN: 'keydown',
    KEYPRESS: 'keypress',
    LOAD: 'load',
    RESIZE: 'resize',
    TOUCHMOVE: 'touchmove',
    WHEEL: 'wheel'
  };

  /**
   * @module ol/events
   */
  /**
   * Key to use with {@link module:ol/Observable.unByKey}.
   * @typedef {Object} EventsKey
   * @property {ListenerFunction} listener Listener.
   * @property {import("./events/Target.js").EventTargetLike} target Target.
   * @property {string} type Type.
   * @api
   */

  /**
   * Listener function. This function is called with an event object as argument.
   * When the function returns `false`, event propagation will stop.
   *
   * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
   * @api
   */

  /**
   * @typedef {Object} ListenerObject
   * @property {ListenerFunction} handleEvent HandleEvent listener function.
   */

  /**
   * @typedef {ListenerFunction|ListenerObject} Listener
   */

  /**
   * Registers an event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` to a `this` object, and returns
   * a key for use with {@link module:ol/events.unlistenByKey}.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object} [thisArg] Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @param {boolean} [once] If true, add the listener as one-off listener.
   * @return {EventsKey} Unique key for the listener.
   */

  function listen(target, type, _listener, thisArg, once) {
    if (thisArg && thisArg !== target) {
      _listener = _listener.bind(thisArg);
    }

    if (once) {
      var originalListener = _listener;

      _listener = function listener() {
        target.removeEventListener(type, _listener);
        originalListener.apply(this, arguments);
      };
    }

    var eventsKey = {
      target: target,
      type: type,
      listener: _listener
    };
    target.addEventListener(type, _listener);
    return eventsKey;
  }
  /**
   * Registers a one-off event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` as self-unregistering listener
   * to a `this` object, and returns a key for use with
   * {@link module:ol/events.unlistenByKey} in case the listener needs to be
   * unregistered before it is called.
   *
   * When {@link module:ol/events.listen} is called with the same arguments after this
   * function, the self-unregistering listener will be turned into a permanent
   * listener.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object} [thisArg] Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @return {EventsKey} Key for unlistenByKey.
   */

  function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
  }
  /**
   * Unregisters event listeners on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * The argument passed to this function is the key returned from
   * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
   *
   * @param {EventsKey} key The key.
   */

  function unlistenByKey(key) {
    if (key && key.target) {
      key.target.removeEventListener(key.type, key.listener);
      clear(key);
    }
  }

  /***
   * @template {string} Type
   * @template {Event|import("./events/Event.js").default} EventClass
   * @template Return
   * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
   */

  /***
   * @template {string} Type
   * @template Return
   * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
   */

  /**
   * @typedef {'change'|'error'} EventTypes
   */

  /***
   * @template Return
   * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * An event target providing convenient methods for listener registration
   * and unregistration. A generic `change` event is always available through
   * {@link module:ol/Observable~Observable#changed}.
   *
   * @fires import("./events/Event.js").default
   * @api
   */

  var Observable = /*#__PURE__*/function (_EventTarget) {
    _inherits(Observable, _EventTarget);

    var _super = _createSuper(Observable);

    function Observable() {
      var _this;

      _classCallCheck(this, Observable);

      _this = _super.call(this);
      _this.on =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      _this.onInternal;
      _this.once =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      _this.onceInternal;
      _this.un =
      /** @type {ObservableOnSignature<void>} */
      _this.unInternal;
      /**
       * @private
       * @type {number}
       */

      _this.revision_ = 0;
      return _this;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */


    _createClass(Observable, [{
      key: "changed",
      value: function changed() {
        ++this.revision_;
        this.dispatchEvent(EventType.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */

    }, {
      key: "getRevision",
      value: function getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */

    }, {
      key: "onInternal",
      value: function onInternal(type, listener) {
        if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);

          for (var i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }

          return keys;
        } else {
          return listen(this,
          /** @type {string} */
          type, listener);
        }
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */

    }, {
      key: "onceInternal",
      value: function onceInternal(type, listener) {
        var key;

        if (Array.isArray(type)) {
          var len = type.length;
          key = new Array(len);

          for (var i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(this,
          /** @type {string} */
          type, listener);
        }
        /** @type {Object} */


        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */

    }, {
      key: "unInternal",
      value: function unInternal(type, listener) {
        var key =
        /** @type {Object} */
        listener.ol_key;

        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (var i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    }]);

    return Observable;
  }(Target);
  /**
   * Listen for a certain type of event.
   * @function
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */


  Observable.prototype.on;
  /**
   * Listen once for a certain type of event.
   * @function
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */

  Observable.prototype.once;
  /**
   * Unlisten for a certain type of event.
   * @function
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
   * @api
   */

  Observable.prototype.un;
  /**
   * Removes an event listener using the key returned by `on()` or `once()`.
   * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
   *     or `once()` (or an array of keys).
   * @api
   */

  function unByKey(key) {
    if (Array.isArray(key)) {
      for (var i = 0, ii = key.length; i < ii; ++i) {
        unlistenByKey(key[i]);
      }
    } else {
      unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key);
    }
  }

  /**
   * @module ol/util
   */

  /**
   * @return {never} Any return.
   */
  function _abstract() {
    throw new Error('Unimplemented abstract method.');
  }
  var uidCounter_ = 0;
  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. Unique IDs are generated
   * as a strictly increasing sequence. Adapted from goog.getUid.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {string} The unique ID for the object.
   * @api
   */

  function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }

  /**
   * @classdesc
   * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
   */

  var ObjectEvent = /*#__PURE__*/function (_Event) {
    _inherits(ObjectEvent, _Event);

    var _super = _createSuper(ObjectEvent);

    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    function ObjectEvent(type, key, oldValue) {
      var _this;

      _classCallCheck(this, ObjectEvent);

      _this = _super.call(this, type);
      /**
       * The name of the property whose value is changing.
       * @type {string}
       * @api
       */

      _this.key = key;
      /**
       * The old value. To get the new value use `e.target.get(e.key)` where
       * `e` is the event object.
       * @type {*}
       * @api
       */

      _this.oldValue = oldValue;
      return _this;
    }

    return _createClass(ObjectEvent);
  }(BaseEvent);
  /***
   * @template Return
   * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
   *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
   *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Most non-trivial classes inherit from this.
   *
   * This extends {@link module:ol/Observable~Observable} with observable
   * properties, where each property is observable as well as the object as a
   * whole.
   *
   * Classes that inherit from this have pre-defined properties, to which you can
   * add your owns. The pre-defined properties are listed in this documentation as
   * 'Observable Properties', and have their own accessors; for example,
   * {@link module:ol/Map~Map} has a `target` property, accessed with
   * `getTarget()` and changed with `setTarget()`. Not all properties are however
   * settable. There are also general-purpose accessors `get()` and `set()`. For
   * example, `get('target')` is equivalent to `getTarget()`.
   *
   * The `set` accessors trigger a change event, and you can monitor this by
   * registering a listener. For example, {@link module:ol/View~View} has a
   * `center` property, so `view.on('change:center', function(evt) {...});` would
   * call the function whenever the value of the center property changes. Within
   * the function, `evt.target` would be the view, so `evt.target.getCenter()`
   * would return the new center.
   *
   * You can add your own observable properties with
   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
   * You can listen for changes on that property value with
   * `object.on('change:prop', listener)`. You can get a list of all
   * properties with {@link module:ol/Object~BaseObject#getProperties}.
   *
   * Note that the observable properties are separate from standard JS properties.
   * You can, for example, give your map object a title with
   * `map.title='New title'` and with `map.set('title', 'Another title')`. The
   * first will be a `hasOwnProperty`; the second will appear in
   * `getProperties()`. Only the second is observable.
   *
   * Properties can be deleted by using the unset method. E.g.
   * object.unset('foo').
   *
   * @fires ObjectEvent
   * @api
   */

  var BaseObject = /*#__PURE__*/function (_Observable) {
    _inherits(BaseObject, _Observable);

    var _super2 = _createSuper(BaseObject);

    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    function BaseObject(values) {
      var _this2;

      _classCallCheck(this, BaseObject);

      _this2 = _super2.call(this);
      /***
       * @type {ObjectOnSignature<import("./events").EventsKey>}
       */

      _this2.on;
      /***
       * @type {ObjectOnSignature<import("./events").EventsKey>}
       */

      _this2.once;
      /***
       * @type {ObjectOnSignature<void>}
       */

      _this2.un; // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
      // the same as the order in which they were created.  This also helps to
      // ensure that object properties are always added in the same order, which
      // helps many JavaScript engines generate faster code.

      getUid(_assertThisInitialized(_this2));
      /**
       * @private
       * @type {Object<string, *>}
       */

      _this2.values_ = null;

      if (values !== undefined) {
        _this2.setProperties(values);
      }

      return _this2;
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */


    _createClass(BaseObject, [{
      key: "get",
      value: function get(key) {
        var value;

        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }

        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */

    }, {
      key: "getKeys",
      value: function getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */

    }, {
      key: "getProperties",
      value: function getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * @return {boolean} The object has properties.
       */

    }, {
      key: "hasProperties",
      value: function hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */

    }, {
      key: "notify",
      value: function notify(key, oldValue) {
        var eventType;
        eventType = "change:".concat(key);

        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }

        eventType = ObjectEventType.PROPERTYCHANGE;

        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */

    }, {
      key: "addChangeListener",
      value: function addChangeListener(key, listener) {
        this.addEventListener("change:".concat(key), listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */

    }, {
      key: "removeChangeListener",
      value: function removeChangeListener(key, listener) {
        this.removeEventListener("change:".concat(key), listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */

    }, {
      key: "set",
      value: function set(key, value, silent) {
        var values = this.values_ || (this.values_ = {});

        if (silent) {
          values[key] = value;
        } else {
          var oldValue = values[key];
          values[key] = value;

          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */

    }, {
      key: "setProperties",
      value: function setProperties(values, silent) {
        for (var key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */

    }, {
      key: "applyProperties",
      value: function applyProperties(source) {
        if (!source.values_) {
          return;
        }

        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */

    }, {
      key: "unset",
      value: function unset(key, silent) {
        if (this.values_ && key in this.values_) {
          var oldValue = this.values_[key];
          delete this.values_[key];

          if (isEmpty$1(this.values_)) {
            this.values_ = null;
          }

          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    }]);

    return BaseObject;
  }(Observable);

  /**
   * @module ol/AssertionError
   */

  /** @type {Object<number, string>} */
  var messages = {
    1: 'The view center is not defined',
    2: 'The view resolution is not defined',
    3: 'The view rotation is not defined',
    4: '`image` and `src` cannot be provided at the same time',
    5: '`imgSize` must be set when `image` is provided',
    7: '`format` must be set when `url` is set',
    8: 'Unknown `serverType` configured',
    9: '`url` must be configured or set using `#setUrl()`',
    10: 'The default `geometryFunction` can only handle `Point` geometries',
    11: '`options.featureTypes` must be an Array',
    12: '`options.geometryName` must also be provided when `options.bbox` is set',
    13: 'Invalid corner',
    14: 'Invalid color',
    15: 'Tried to get a value for a key that does not exist in the cache',
    16: 'Tried to set a value for a key that is used already',
    17: '`resolutions` must be sorted in descending order',
    18: 'Either `origin` or `origins` must be configured, never both',
    19: 'Number of `tileSizes` and `resolutions` must be equal',
    20: 'Number of `origins` and `resolutions` must be equal',
    22: 'Either `tileSize` or `tileSizes` must be configured, never both',
    24: 'Invalid extent or geometry provided as `geometry`',
    25: 'Cannot fit empty extent provided as `geometry`',
    26: 'Features must have an id set',
    27: 'Features must have an id set',
    28: '`renderMode` must be `"hybrid"` or `"vector"`',
    30: 'The passed `feature` was already added to the source',
    31: 'Tried to enqueue an `element` that was already added to the queue',
    32: 'Transformation matrix cannot be inverted',
    33: 'Invalid units',
    34: 'Invalid geometry layout',
    36: 'Unknown SRS type',
    37: 'Unknown geometry type found',
    38: '`styleMapValue` has an unknown type',
    39: 'Unknown geometry type',
    40: 'Expected `feature` to have a geometry',
    41: 'Expected an `ol/style/Style` or an array of `ol/style/Style.js`',
    42: 'Question unknown, the answer is 42',
    43: 'Expected `layers` to be an array or a `Collection`',
    47: 'Expected `controls` to be an array or an `ol/Collection`',
    48: 'Expected `interactions` to be an array or an `ol/Collection`',
    49: 'Expected `overlays` to be an array or an `ol/Collection`',
    50: '`options.featureTypes` should be an Array',
    51: 'Either `url` or `tileJSON` options must be provided',
    52: 'Unknown `serverType` configured',
    53: 'Unknown `tierSizeCalculation` configured',
    55: 'The {-y} placeholder requires a tile grid with extent',
    56: 'mapBrowserEvent must originate from a pointer event',
    57: 'At least 2 conditions are required',
    59: 'Invalid command found in the PBF',
    60: 'Missing or invalid `size`',
    61: 'Cannot determine IIIF Image API version from provided image information JSON',
    62: 'A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`',
    64: 'Layer opacity must be a number',
    66: '`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`',
    67: 'A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both',
    68: 'A VectorTile source can only be rendered if it has a projection compatible with the view projection'
  };
  /**
   * Error object thrown when an assertion failed. This is an ECMA-262 Error,
   * extended with a `code` property.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
   */

  var AssertionError = /*#__PURE__*/function (_Error) {
    _inherits(AssertionError, _Error);

    var _super = _createSuper(AssertionError);

    /**
     * @param {number} code Error code.
     */
    function AssertionError(code) {
      var _this;

      _classCallCheck(this, AssertionError);

      var message = messages[code];
      _this = _super.call(this, message);
      /**
       * Error code. The meaning of the code can be found on
       * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
       * the version found in the OpenLayers script's header comment if a version
       * other than the latest is used).
       * @type {number}
       * @deprecated ol/AssertionError and error codes will be removed in v8.0
       * @api
       */

      _this.code = code;
      /**
       * @type {string}
       */

      _this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40

      _this.message = message;
      return _this;
    }

    return _createClass(AssertionError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  /**
   * @module ol/asserts
   */
  /**
   * @param {*} assertion Assertion we expected to be truthy.
   * @param {number} errorCode Error code.
   */

  function assert(assertion, errorCode) {
    if (!assertion) {
      throw new AssertionError(errorCode);
    }
  }

  /**
   * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
   */

  /**
   * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
   */

  /***
   * @template Return
   * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
   *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
   *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
   *     |'change:geometry', Return>} FeatureOnSignature
   */

  /***
   * @template Geometry
   * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
   */

  /**
   * @classdesc
   * A vector object for geographic features with a geometry and other
   * attribute properties, similar to the features in vector file formats like
   * GeoJSON.
   *
   * Features can be styled individually with `setStyle`; otherwise they use the
   * style of their vector layer.
   *
   * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
   * the feature object, so they are observable, and have get/set accessors.
   *
   * Typically, a feature has a single geometry property. You can set the
   * geometry using the `setGeometry` method and get it with `getGeometry`.
   * It is possible to store more than one geometry on a feature using attribute
   * properties. By default, the geometry used for rendering is identified by
   * the property name `geometry`. If you want to use another geometry property
   * for rendering, use the `setGeometryName` method to change the attribute
   * property associated with the geometry for the feature.  For example:
   *
   * ```js
   *
   * import Feature from 'ol/Feature';
   * import Polygon from 'ol/geom/Polygon';
   * import Point from 'ol/geom/Point';
   *
   * const feature = new Feature({
   *   geometry: new Polygon(polyCoords),
   *   labelPoint: new Point(labelCoords),
   *   name: 'My Polygon',
   * });
   *
   * // get the polygon geometry
   * const poly = feature.getGeometry();
   *
   * // Render the feature as a point using the coordinates from labelPoint
   * feature.setGeometryName('labelPoint');
   *
   * // get the point geometry
   * const point = feature.getGeometry();
   * ```
   *
   * @api
   * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
   */

  var Feature = /*#__PURE__*/function (_BaseObject) {
    _inherits(Feature, _BaseObject);

    var _super = _createSuper(Feature);

    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    function Feature(geometryOrProperties) {
      var _this;

      _classCallCheck(this, Feature);

      _this = _super.call(this);
      /***
       * @type {FeatureOnSignature<import("./events").EventsKey>}
       */

      _this.on;
      /***
       * @type {FeatureOnSignature<import("./events").EventsKey>}
       */

      _this.once;
      /***
       * @type {FeatureOnSignature<void>}
       */

      _this.un;
      /**
       * @private
       * @type {number|string|undefined}
       */

      _this.id_ = undefined;
      /**
       * @type {string}
       * @private
       */

      _this.geometryName_ = 'geometry';
      /**
       * User provided style.
       * @private
       * @type {import("./style/Style.js").StyleLike}
       */

      _this.style_ = null;
      /**
       * @private
       * @type {import("./style/Style.js").StyleFunction|undefined}
       */

      _this.styleFunction_ = undefined;
      /**
       * @private
       * @type {?import("./events.js").EventsKey}
       */

      _this.geometryChangeKey_ = null;

      _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);

      if (geometryOrProperties) {
        if (typeof
        /** @type {?} */
        geometryOrProperties.getSimplifiedGeometry === 'function') {
          var geometry =
          /** @type {Geometry} */
          geometryOrProperties;

          _this.setGeometry(geometry);
        } else {
          /** @type {Object<string, *>} */
          var properties = geometryOrProperties;

          _this.setProperties(properties);
        }
      }

      return _this;
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */


    _createClass(Feature, [{
      key: "clone",
      value: function clone() {
        var clone =
        /** @type {Feature<Geometry>} */
        new Feature(this.hasProperties() ? this.getProperties() : null);
        clone.setGeometryName(this.getGeometryName());
        var geometry = this.getGeometry();

        if (geometry) {
          clone.setGeometry(
          /** @type {Geometry} */
          geometry.clone());
        }

        var style = this.getStyle();

        if (style) {
          clone.setStyle(style);
        }

        return clone;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */

    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */

    }, {
      key: "getId",
      value: function getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */

    }, {
      key: "getGeometryName",
      value: function getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */

    }, {
      key: "getStyle",
      value: function getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */

    }, {
      key: "getStyleFunction",
      value: function getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */

    }, {
      key: "handleGeometryChange_",
      value: function handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */

    }, {
      key: "handleGeometryChanged_",
      value: function handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }

        var geometry = this.getGeometry();

        if (geometry) {
          this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
        }

        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */

    }, {
      key: "setGeometry",
      value: function setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */

    }, {
      key: "setStyle",
      value: function setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */

    }, {
      key: "setId",
      value: function setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */

    }, {
      key: "setGeometryName",
      value: function setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    }]);

    return Feature;
  }(BaseObject);
  /**
   * Convert the provided object into a feature style function.  Functions passed
   * through unchanged.  Arrays of Style or single style objects wrapped
   * in a new feature style function.
   * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
   *     A feature style function, a single style, or an array of styles.
   * @return {import("./style/Style.js").StyleFunction} A style function.
   */


  function createStyleFunction(obj) {
    if (typeof obj === 'function') {
      return obj;
    } else {
      /**
       * @type {Array<import("./style/Style.js").default>}
       */
      var styles;

      if (Array.isArray(obj)) {
        styles = obj;
      } else {
        assert(typeof
        /** @type {?} */
        obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`

        var style =
        /** @type {import("./style/Style.js").default} */
        obj;
        styles = [style];
      }

      return function () {
        return styles;
      };
    }
  }

  /**
   * @module ol/has
   */
  var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
  /**
   * User agent string says we are dealing with Firefox as browser.
   * @type {boolean}
   */

  var FIREFOX = ua.includes('firefox');
  /**
   * User agent string says we are dealing with Safari as browser.
   * @type {boolean}
   */

  var SAFARI = ua.includes('safari') && !ua.includes('chrom');
  /**
   * https://bugs.webkit.org/show_bug.cgi?id=237906
   * @type {boolean}
   */

  var SAFARI_BUG_237906 = SAFARI && (ua.includes('version/15.4') || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
  /**
   * User agent string says we are dealing with a WebKit engine.
   * @type {boolean}
   */

  var WEBKIT = ua.includes('webkit') && !ua.includes('edge');
  /**
   * User agent string says we are dealing with a Mac as platform.
   * @type {boolean}
   */

  var MAC = ua.includes('macintosh');
  /**
   * The ratio between physical pixels and device-independent pixels
   * (dips) on the device (`window.devicePixelRatio`).
   * @const
   * @type {number}
   * @api
   */

  var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
  /**
   * The execution context is a worker with OffscreenCanvas available.
   * @const
   * @type {boolean}
   */

  var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

  /**
   * Image.prototype.decode() is supported.
   * @type {boolean}
   */

  var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
  /**
   * @type {boolean}
   */

  var PASSIVE_EVENT_LISTENERS = function () {
    var passive = false;

    try {
      var options = Object.defineProperty({}, 'passive', {
        get: function get() {
          passive = true;
        }
      });
      window.addEventListener('_', null, options);
      window.removeEventListener('_', null, options);
    } catch (error) {// passive not supported
    }

    return passive;
  }();

  /**
   * @module ol/transform
   */
  /**
   * An array representing an affine 2d transformation for use with
   * {@link module:ol/transform} functions. The array has 6 elements.
   * @typedef {!Array<number>} Transform
   * @api
   */

  /**
   * Collection of affine 2d transformation functions. The functions work on an
   * array of 6 elements. The element order is compatible with the [SVGMatrix
   * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
   * a subset (elements a to f) of a 33 matrix:
   * ```
   * [ a c e ]
   * [ b d f ]
   * [ 0 0 1 ]
   * ```
   */

  /**
   * @private
   * @type {Transform}
   */

  var tmp_ = new Array(6);
  /**
   * Create an identity transform.
   * @return {!Transform} Identity transform.
   */

  function create$1() {
    return [1, 0, 0, 1, 0, 0];
  }
  /**
   * Resets the given transform to an identity transform.
   * @param {!Transform} transform Transform.
   * @return {!Transform} Transform.
   */

  function reset(transform) {
    return set(transform, 1, 0, 0, 1, 0, 0);
  }
  /**
   * Multiply the underlying matrices of two transforms and return the result in
   * the first transform.
   * @param {!Transform} transform1 Transform parameters of matrix 1.
   * @param {!Transform} transform2 Transform parameters of matrix 2.
   * @return {!Transform} transform1 multiplied with transform2.
   */

  function multiply(transform1, transform2) {
    var a1 = transform1[0];
    var b1 = transform1[1];
    var c1 = transform1[2];
    var d1 = transform1[3];
    var e1 = transform1[4];
    var f1 = transform1[5];
    var a2 = transform2[0];
    var b2 = transform2[1];
    var c2 = transform2[2];
    var d2 = transform2[3];
    var e2 = transform2[4];
    var f2 = transform2[5];
    transform1[0] = a1 * a2 + c1 * b2;
    transform1[1] = b1 * a2 + d1 * b2;
    transform1[2] = a1 * c2 + c1 * d2;
    transform1[3] = b1 * c2 + d1 * d2;
    transform1[4] = a1 * e2 + c1 * f2 + e1;
    transform1[5] = b1 * e2 + d1 * f2 + f1;
    return transform1;
  }
  /**
   * Set the transform components a-f on a given transform.
   * @param {!Transform} transform Transform.
   * @param {number} a The a component of the transform.
   * @param {number} b The b component of the transform.
   * @param {number} c The c component of the transform.
   * @param {number} d The d component of the transform.
   * @param {number} e The e component of the transform.
   * @param {number} f The f component of the transform.
   * @return {!Transform} Matrix with transform applied.
   */

  function set(transform, a, b, c, d, e, f) {
    transform[0] = a;
    transform[1] = b;
    transform[2] = c;
    transform[3] = d;
    transform[4] = e;
    transform[5] = f;
    return transform;
  }
  /**
   * Transforms the given coordinate with the given transform returning the
   * resulting, transformed coordinate. The coordinate will be modified in-place.
   *
   * @param {Transform} transform The transformation.
   * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
   * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
   *     chained together.
   */

  function apply(transform, coordinate) {
    var x = coordinate[0];
    var y = coordinate[1];
    coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
    coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
    return coordinate;
  }
  /**
   * Applies rotation to the given transform.
   * @param {!Transform} transform Transform.
   * @param {number} angle Angle in radians.
   * @return {!Transform} The rotated transform.
   */

  function rotate$2(transform, angle) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
  }
  /**
   * Applies scale to a given transform.
   * @param {!Transform} transform Transform.
   * @param {number} x Scale factor x.
   * @param {number} y Scale factor y.
   * @return {!Transform} The scaled transform.
   */

  function scale$3(transform, x, y) {
    return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
  }
  /**
   * Applies translation to the given transform.
   * @param {!Transform} transform Transform.
   * @param {number} dx Translation x.
   * @param {number} dy Translation y.
   * @return {!Transform} The translated transform.
   */

  function translate$1(transform, dx, dy) {
    return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
  }
  /**
   * Creates a composite transform given an initial translation, scale, rotation, and
   * final translation (in that order only, not commutative).
   * @param {!Transform} transform The transform (will be modified in place).
   * @param {number} dx1 Initial translation x.
   * @param {number} dy1 Initial translation y.
   * @param {number} sx Scale factor x.
   * @param {number} sy Scale factor y.
   * @param {number} angle Rotation (in counter-clockwise radians).
   * @param {number} dx2 Final translation x.
   * @param {number} dy2 Final translation y.
   * @return {!Transform} The composite transform.
   */

  function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
    var sin = Math.sin(angle);
    var cos = Math.cos(angle);
    transform[0] = sx * cos;
    transform[1] = sy * sin;
    transform[2] = -sx * sin;
    transform[3] = sy * cos;
    transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform;
  }
  /**
   * Invert the given transform.
   * @param {!Transform} target Transform to be set as the inverse of
   *     the source transform.
   * @param {!Transform} source The source transform to invert.
   * @return {!Transform} The inverted (target) transform.
   */

  function makeInverse(target, source) {
    var det = determinant(source);
    assert(det !== 0, 32); // Transformation matrix cannot be inverted

    var a = source[0];
    var b = source[1];
    var c = source[2];
    var d = source[3];
    var e = source[4];
    var f = source[5];
    target[0] = d / det;
    target[1] = -b / det;
    target[2] = -c / det;
    target[3] = a / det;
    target[4] = (c * f - d * e) / det;
    target[5] = -(a * f - b * e) / det;
    return target;
  }
  /**
   * Returns the determinant of the given matrix.
   * @param {!Transform} mat Matrix.
   * @return {number} Determinant.
   */

  function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
  }
  /**
   * @type {HTMLElement}
   * @private
   */

  var transformStringDiv;
  /**
   * A rounded string version of the transform.  This can be used
   * for CSS transforms.
   * @param {!Transform} mat Matrix.
   * @return {string} The transform as a string.
   */

  function toString$3(mat) {
    var transformString = 'matrix(' + mat.join(', ') + ')';

    if (WORKER_OFFSCREEN_CANVAS) {
      return transformString;
    }

    var node = transformStringDiv || (transformStringDiv = document.createElement('div'));
    node.style.transform = transformString;
    return node.style.transform;
  }

  /**
   * @module ol/extent/Relationship
   */

  /**
   * Relationship to an extent.
   * @enum {number}
   */
  var Relationship = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
  };

  /**
   * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
   * @typedef {Array<number>} Extent
   * @api
   */

  /**
   * Extent corner.
   * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
   */

  /**
   * Build an extent that includes all given coordinates.
   *
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Bounding extent.
   * @api
   */

  function boundingExtent(coordinates) {
    var extent = createEmpty();

    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
      extendCoordinate(extent, coordinates[i]);
    }

    return extent;
  }
  /**
   * Creates a clone of an extent.
   *
   * @param {Extent} extent Extent to clone.
   * @param {Extent} [dest] Extent.
   * @return {Extent} The clone.
   */

  function clone(extent, dest) {
    if (dest) {
      dest[0] = extent[0];
      dest[1] = extent[1];
      dest[2] = extent[2];
      dest[3] = extent[3];
      return dest;
    } else {
      return extent.slice();
    }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {number} Closest squared distance.
   */

  function closestSquaredDistanceXY(extent, x, y) {
    var dx, dy;

    if (x < extent[0]) {
      dx = extent[0] - x;
    } else if (extent[2] < x) {
      dx = x - extent[2];
    } else {
      dx = 0;
    }

    if (y < extent[1]) {
      dy = extent[1] - y;
    } else if (extent[3] < y) {
      dy = y - extent[3];
    } else {
      dy = 0;
    }

    return dx * dx + dy * dy;
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} The coordinate is contained in the extent.
   * @api
   */

  function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
  }
  /**
   * Check if one extent contains another.
   *
   * An extent is deemed contained if it lies completely within the other extent,
   * including if they share one or more edges.
   *
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The second extent is contained by or on the edge of the
   *     first.
   * @api
   */

  function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   * @return {boolean} The x, y values are contained in the extent.
   * @api
   */

  function containsXY(extent, x, y) {
    return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
  }
  /**
   * Get the relationship between a coordinate and extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
   * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
   *     import("./extent/Relationship.js").Relationship).
   */

  function coordinateRelationship(extent, coordinate) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var x = coordinate[0];
    var y = coordinate[1];
    var relationship = Relationship.UNKNOWN;

    if (x < minX) {
      relationship = relationship | Relationship.LEFT;
    } else if (x > maxX) {
      relationship = relationship | Relationship.RIGHT;
    }

    if (y < minY) {
      relationship = relationship | Relationship.BELOW;
    } else if (y > maxY) {
      relationship = relationship | Relationship.ABOVE;
    }

    if (relationship === Relationship.UNKNOWN) {
      relationship = Relationship.INTERSECTING;
    }

    return relationship;
  }
  /**
   * Create an empty extent.
   * @return {Extent} Empty extent.
   * @api
   */

  function createEmpty() {
    return [Infinity, Infinity, -Infinity, -Infinity];
  }
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent} [dest] Destination extent.
   * @return {Extent} Extent.
   */

  function createOrUpdate$2(minX, minY, maxX, maxY, dest) {
    if (dest) {
      dest[0] = minX;
      dest[1] = minY;
      dest[2] = maxX;
      dest[3] = maxY;
      return dest;
    } else {
      return [minX, minY, maxX, maxY];
    }
  }
  /**
   * Create a new empty extent or make the provided one empty.
   * @param {Extent} [dest] Extent.
   * @return {Extent} Extent.
   */

  function createOrUpdateEmpty(dest) {
    return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, dest);
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {Extent} [dest] Extent.
   * @return {Extent} Extent.
   */

  function createOrUpdateFromCoordinate(coordinate, dest) {
    var x = coordinate[0];
    var y = coordinate[1];
    return createOrUpdate$2(x, y, x, y, dest);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Extent} [dest] Extent.
   * @return {Extent} Extent.
   */

  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
    var extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
  }
  /**
   * Determine if two extents are equivalent.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The two extents are equivalent.
   * @api
   */

  function equals$2(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
  }
  /**
   * Modify an extent to include another extent.
   * @param {Extent} extent1 The extent to be modified.
   * @param {Extent} extent2 The extent that will be included in the first.
   * @return {Extent} A reference to the first (extended) extent.
   * @api
   */

  function extend(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
      extent1[0] = extent2[0];
    }

    if (extent2[2] > extent1[2]) {
      extent1[2] = extent2[2];
    }

    if (extent2[1] < extent1[1]) {
      extent1[1] = extent2[1];
    }

    if (extent2[3] > extent1[3]) {
      extent1[3] = extent2[3];
    }

    return extent1;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   */

  function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) {
      extent[0] = coordinate[0];
    }

    if (coordinate[0] > extent[2]) {
      extent[2] = coordinate[0];
    }

    if (coordinate[1] < extent[1]) {
      extent[1] = coordinate[1];
    }

    if (coordinate[1] > extent[3]) {
      extent[3] = coordinate[1];
    }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Extent} Extent.
   */

  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
    for (; offset < end; offset += stride) {
      extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
    }

    return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   */

  function extendXY(extent, x, y) {
    extent[0] = Math.min(extent[0], x);
    extent[1] = Math.min(extent[1], y);
    extent[2] = Math.max(extent[2], x);
    extent[3] = Math.max(extent[3], y);
  }
  /**
   * This function calls `callback` for each corner of the extent. If the
   * callback returns a truthy value the function returns that value
   * immediately. Otherwise the function returns `false`.
   * @param {Extent} extent Extent.
   * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
   * @return {S|boolean} Value.
   * @template S
   */

  function forEachCorner(extent, callback) {
    var val;
    val = callback(getBottomLeft(extent));

    if (val) {
      return val;
    }

    val = callback(getBottomRight(extent));

    if (val) {
      return val;
    }

    val = callback(getTopRight(extent));

    if (val) {
      return val;
    }

    val = callback(getTopLeft(extent));

    if (val) {
      return val;
    }

    return false;
  }
  /**
   * Get the size of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Area.
   * @api
   */

  function getArea(extent) {
    var area = 0;

    if (!isEmpty(extent)) {
      area = getWidth(extent) * getHeight(extent);
    }

    return area;
  }
  /**
   * Get the bottom left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
   * @api
   */

  function getBottomLeft(extent) {
    return [extent[0], extent[1]];
  }
  /**
   * Get the bottom right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
   * @api
   */

  function getBottomRight(extent) {
    return [extent[2], extent[1]];
  }
  /**
   * Get the center coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Center.
   * @api
   */

  function getCenter(extent) {
    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  /**
   * Get a corner coordinate of an extent.
   * @param {Extent} extent Extent.
   * @param {Corner} corner Corner.
   * @return {import("./coordinate.js").Coordinate} Corner coordinate.
   */

  function getCorner(extent, corner) {
    var coordinate;

    if (corner === 'bottom-left') {
      coordinate = getBottomLeft(extent);
    } else if (corner === 'bottom-right') {
      coordinate = getBottomRight(extent);
    } else if (corner === 'top-left') {
      coordinate = getTopLeft(extent);
    } else if (corner === 'top-right') {
      coordinate = getTopRight(extent);
    } else {
      assert(false, 13); // Invalid corner
    }

    return coordinate;
  }
  /**
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @param {Extent} [dest] Destination extent.
   * @return {Extent} Extent.
   */

  function getForViewAndSize(center, resolution, rotation, size, dest) {
    var _getRotatedViewport = getRotatedViewport(center, resolution, rotation, size),
        _getRotatedViewport2 = _slicedToArray(_getRotatedViewport, 8),
        x0 = _getRotatedViewport2[0],
        y0 = _getRotatedViewport2[1],
        x1 = _getRotatedViewport2[2],
        y1 = _getRotatedViewport2[3],
        x2 = _getRotatedViewport2[4],
        y2 = _getRotatedViewport2[5],
        x3 = _getRotatedViewport2[6],
        y3 = _getRotatedViewport2[7];

    return createOrUpdate$2(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), dest);
  }
  /**
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>} Linear ring representing the viewport.
   */

  function getRotatedViewport(center, resolution, rotation, size) {
    var dx = resolution * size[0] / 2;
    var dy = resolution * size[1] / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    return [x - xCos + ySin, y - xSin - yCos, x - xCos - ySin, y - xSin + yCos, x + xCos - ySin, y + xSin + yCos, x + xCos + ySin, y + xSin - yCos, x - xCos + ySin, y - xSin - yCos];
  }
  /**
   * Get the height of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Height.
   * @api
   */

  function getHeight(extent) {
    return extent[3] - extent[1];
  }
  /**
   * Get the intersection of two extents.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @param {Extent} [dest] Optional extent to populate with intersection.
   * @return {Extent} Intersecting extent.
   * @api
   */

  function getIntersection(extent1, extent2, dest) {
    var intersection = dest ? dest : createEmpty();

    if (intersects$1(extent1, extent2)) {
      if (extent1[0] > extent2[0]) {
        intersection[0] = extent1[0];
      } else {
        intersection[0] = extent2[0];
      }

      if (extent1[1] > extent2[1]) {
        intersection[1] = extent1[1];
      } else {
        intersection[1] = extent2[1];
      }

      if (extent1[2] < extent2[2]) {
        intersection[2] = extent1[2];
      } else {
        intersection[2] = extent2[2];
      }

      if (extent1[3] < extent2[3]) {
        intersection[3] = extent1[3];
      } else {
        intersection[3] = extent2[3];
      }
    } else {
      createOrUpdateEmpty(intersection);
    }

    return intersection;
  }
  /**
   * Get the top left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top left coordinate.
   * @api
   */

  function getTopLeft(extent) {
    return [extent[0], extent[3]];
  }
  /**
   * Get the top right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top right coordinate.
   * @api
   */

  function getTopRight(extent) {
    return [extent[2], extent[3]];
  }
  /**
   * Get the width of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Width.
   * @api
   */

  function getWidth(extent) {
    return extent[2] - extent[0];
  }
  /**
   * Determine if one extent intersects another.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent.
   * @return {boolean} The two extents intersect.
   * @api
   */

  function intersects$1(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
  }
  /**
   * Determine if an extent is empty.
   * @param {Extent} extent Extent.
   * @return {boolean} Is empty.
   * @api
   */

  function isEmpty(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Extent} [dest] Extent.
   * @return {Extent} Extent.
   */

  function returnOrUpdate(extent, dest) {
    if (dest) {
      dest[0] = extent[0];
      dest[1] = extent[1];
      dest[2] = extent[2];
      dest[3] = extent[3];
      return dest;
    } else {
      return extent;
    }
  }
  /**
   * Determine if the segment between two coordinates intersects (crosses,
   * touches, or is contained by) the provided extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
   * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
   * @return {boolean} The segment intersects the extent.
   */

  function intersectsSegment(extent, start, end) {
    var intersects = false;
    var startRel = coordinateRelationship(extent, start);
    var endRel = coordinateRelationship(extent, end);

    if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
      intersects = true;
    } else {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var startX = start[0];
      var startY = start[1];
      var endX = end[0];
      var endY = end[1];
      var slope = (endY - startY) / (endX - startX);
      var x, y;

      if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
        // potentially intersects top
        x = endX - (endY - maxY) / slope;
        intersects = x >= minX && x <= maxX;
      }

      if (!intersects && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
        // potentially intersects right
        y = endY - (endX - maxX) * slope;
        intersects = y >= minY && y <= maxY;
      }

      if (!intersects && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
        // potentially intersects bottom
        x = endX - (endY - minY) / slope;
        intersects = x >= minX && x <= maxX;
      }

      if (!intersects && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
        // potentially intersects left
        y = endY - (endX - minX) * slope;
        intersects = y >= minY && y <= maxY;
      }
    }

    return intersects;
  }

  /**
   * @module ol/proj/Units
   */

  /**
   * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
   * Projection units.
   */

  /**
   * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
   * @type {Object<number, Units>}
   */
  var unitByCode = {
    '9001': 'm',
    '9002': 'ft',
    '9003': 'us-ft',
    '9101': 'radians',
    '9102': 'degrees'
  };
  /**
   * @param {number} code Unit code.
   * @return {Units} Units.
   */

  function fromCode(code) {
    return unitByCode[code];
  }
  /**
   * @typedef {Object} MetersPerUnitLookup
   * @property {number} radians Radians
   * @property {number} degrees Degrees
   * @property {number} ft  Feet
   * @property {number} m Meters
   * @property {number} us-ft US feet
   */

  /**
   * Meters per unit lookup table.
   * @const
   * @type {MetersPerUnitLookup}
   * @api
   */

  var METERS_PER_UNIT$1 = {
    // use the radius of the Normal sphere
    'radians': 6370997 / (2 * Math.PI),
    'degrees': 2 * Math.PI * 6370997 / 360,
    'ft': 0.3048,
    'm': 1,
    'us-ft': 1200 / 3937
  };

  /**
   * @typedef {Object} Options
   * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
   * @property {import("./Units.js").Units} [units] Units. Required unless a
   * proj4 projection is defined for `code`.
   * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
   * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
   * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
   * @property {number} [metersPerUnit] The meters per unit for the SRS.
   * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
   * lookup table.
   * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
   * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
   * Function to determine resolution at a point. The function is called with a
   * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
   * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
   * the default {@link module:ol/proj.getPointResolution} function will be used.
   */

  /**
   * @classdesc
   * Projection definition class. One of these is created for each projection
   * supported in the application and stored in the {@link module:ol/proj} namespace.
   * You can use these in applications, but this is not required, as API params
   * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
   * code will suffice.
   *
   * You can use {@link module:ol/proj.get} to retrieve the object for a particular
   * projection.
   *
   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
   * with the following aliases:
   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
   *     http://www.opengis.net/gml/srs/epsg.xml#4326,
   *     urn:x-ogc:def:crs:EPSG:4326
   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
   *     urn:ogc:def:crs:EPSG:6.18:3:3857,
   *     http://www.opengis.net/gml/srs/epsg.xml#3857
   *
   * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
   * be added using `proj4.defs()`. After all required projection definitions are
   * added, call the {@link module:ol/proj/proj4.register} function.
   *
   * @api
   */

  var Projection = /*#__PURE__*/function () {
    /**
     * @param {Options} options Projection options.
     */
    function Projection(options) {
      _classCallCheck(this, Projection);

      /**
       * @private
       * @type {string}
       */
      this.code_ = options.code;
      /**
       * Units of projected coordinates. When set to `TILE_PIXELS`, a
       * `this.extent_` and `this.worldExtent_` must be configured properly for each
       * tile.
       * @private
       * @type {import("./Units.js").Units}
       */

      this.units_ =
      /** @type {import("./Units.js").Units} */
      options.units;
      /**
       * Validity extent of the projection in projected coordinates. For projections
       * with `TILE_PIXELS` units, this is the extent of the tile in
       * tile pixel space.
       * @private
       * @type {import("../extent.js").Extent}
       */

      this.extent_ = options.extent !== undefined ? options.extent : null;
      /**
       * Extent of the world in EPSG:4326. For projections with
       * `TILE_PIXELS` units, this is the extent of the tile in
       * projected coordinate space.
       * @private
       * @type {import("../extent.js").Extent}
       */

      this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
      /**
       * @private
       * @type {string}
       */

      this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
      /**
       * @private
       * @type {boolean}
       */

      this.global_ = options.global !== undefined ? options.global : false;
      /**
       * @private
       * @type {boolean}
       */

      this.canWrapX_ = !!(this.global_ && this.extent_);
      /**
       * @private
       * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
       */

      this.getPointResolutionFunc_ = options.getPointResolution;
      /**
       * @private
       * @type {import("../tilegrid/TileGrid.js").default}
       */

      this.defaultTileGrid_ = null;
      /**
       * @private
       * @type {number|undefined}
       */

      this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */


    _createClass(Projection, [{
      key: "canWrapX",
      value: function canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */

    }, {
      key: "getCode",
      value: function getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */

    }, {
      key: "getExtent",
      value: function getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */

    }, {
      key: "getUnits",
      value: function getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */

    }, {
      key: "getMetersPerUnit",
      value: function getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */

    }, {
      key: "getWorldExtent",
      value: function getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */

    }, {
      key: "getAxisOrientation",
      value: function getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */

    }, {
      key: "isGlobal",
      value: function isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */

    }, {
      key: "setGlobal",
      value: function setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */

    }, {
      key: "getDefaultTileGrid",
      value: function getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */

    }, {
      key: "setDefaultTileGrid",
      value: function setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */

    }, {
      key: "setExtent",
      value: function setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */

    }, {
      key: "setWorldExtent",
      value: function setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */

    }, {
      key: "setGetPointResolution",
      value: function setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */

    }, {
      key: "getPointResolutionFunc",
      value: function getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    }]);

    return Projection;
  }();

  /**
   * Radius of WGS84 sphere
   *
   * @const
   * @type {number}
   */

  var RADIUS$1 = 6378137;
  /**
   * @const
   * @type {number}
   */

  var HALF_SIZE = Math.PI * RADIUS$1;
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */

  var EXTENT$2 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */

  var WORLD_EXTENT = [-180, -85, 180, 85];
  /**
   * Maximum safe value in y direction
   * @const
   * @type {number}
   */

  var MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
  /**
   * @classdesc
   * Projection object for web/spherical Mercator (EPSG:3857).
   */

  var EPSG3857Projection = /*#__PURE__*/function (_Projection) {
    _inherits(EPSG3857Projection, _Projection);

    var _super = _createSuper(EPSG3857Projection);

    /**
     * @param {string} code Code.
     */
    function EPSG3857Projection(code) {
      _classCallCheck(this, EPSG3857Projection);

      return _super.call(this, {
        code: code,
        units: 'm',
        extent: EXTENT$2,
        global: true,
        worldExtent: WORLD_EXTENT,
        getPointResolution: function getPointResolution(resolution, point) {
          return resolution / Math.cosh(point[1] / RADIUS$1);
        }
      });
    }

    return _createClass(EPSG3857Projection);
  }(Projection);
  /**
   * Projections equal to EPSG:3857.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */


  var PROJECTIONS$1 = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];
  /**
   * Transformation from EPSG:4326 to EPSG:3857.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>} [output] Output array of coordinate values.
   * @param {number} [dimension] Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */

  function fromEPSG4326(input, output, dimension) {
    var length = input.length;
    dimension = dimension > 1 ? dimension : 2;

    if (output === undefined) {
      if (dimension > 2) {
        // preserve values beyond second dimension
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }

    for (var i = 0; i < length; i += dimension) {
      output[i] = HALF_SIZE * input[i] / 180;
      var y = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));

      if (y > MAX_SAFE_Y) {
        y = MAX_SAFE_Y;
      } else if (y < -MAX_SAFE_Y) {
        y = -MAX_SAFE_Y;
      }

      output[i + 1] = y;
    }

    return output;
  }
  /**
   * Transformation from EPSG:3857 to EPSG:4326.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>} [output] Output array of coordinate values.
   * @param {number} [dimension] Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */

  function toEPSG4326(input, output, dimension) {
    var length = input.length;
    dimension = dimension > 1 ? dimension : 2;

    if (output === undefined) {
      if (dimension > 2) {
        // preserve values beyond second dimension
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }

    for (var i = 0; i < length; i += dimension) {
      output[i] = 180 * input[i] / HALF_SIZE;
      output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS$1)) / Math.PI - 90;
    }

    return output;
  }

  /**
   * Semi-major radius of the WGS84 ellipsoid.
   *
   * @const
   * @type {number}
   */

  var RADIUS = 6378137;
  /**
   * Extent of the EPSG:4326 projection which is the whole world.
   *
   * @const
   * @type {import("../extent.js").Extent}
   */

  var EXTENT$1 = [-180, -90, 180, 90];
  /**
   * @const
   * @type {number}
   */

  var METERS_PER_UNIT = Math.PI * RADIUS / 180;
  /**
   * @classdesc
   * Projection object for WGS84 geographic coordinates (EPSG:4326).
   *
   * Note that OpenLayers does not strictly comply with the EPSG definition.
   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
   */

  var EPSG4326Projection = /*#__PURE__*/function (_Projection) {
    _inherits(EPSG4326Projection, _Projection);

    var _super = _createSuper(EPSG4326Projection);

    /**
     * @param {string} code Code.
     * @param {string} [axisOrientation] Axis orientation.
     */
    function EPSG4326Projection(code, axisOrientation) {
      _classCallCheck(this, EPSG4326Projection);

      return _super.call(this, {
        code: code,
        units: 'degrees',
        extent: EXTENT$1,
        axisOrientation: axisOrientation,
        global: true,
        metersPerUnit: METERS_PER_UNIT,
        worldExtent: EXTENT$1
      });
    }

    return _createClass(EPSG4326Projection);
  }(Projection);
  /**
   * Projections equal to EPSG:4326.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */


  var PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu')];

  /**
   * @module ol/proj/projections
   */

  /**
   * @type {Object<string, import("./Projection.js").default>}
   */
  var cache = {};
  /**
   * Get a cached projection by code.
   * @param {string} code The code for the projection.
   * @return {import("./Projection.js").default} The projection (if cached).
   */

  function get$3(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
  }
  /**
   * Add a projection to the cache.
   * @param {string} code The projection code.
   * @param {import("./Projection.js").default} projection The projection to cache.
   */

  function add$2(code, projection) {
    cache[code] = projection;
  }

  /**
   * @module ol/proj/transforms
   */
  /**
   * @private
   * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
   */

  var transforms = {};
  /**
   * Registers a conversion function to convert coordinates from the source
   * projection to the destination projection.
   *
   * @param {import("./Projection.js").default} source Source.
   * @param {import("./Projection.js").default} destination Destination.
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */

  function add$1(source, destination, transformFn) {
    var sourceCode = source.getCode();
    var destinationCode = destination.getCode();

    if (!(sourceCode in transforms)) {
      transforms[sourceCode] = {};
    }

    transforms[sourceCode][destinationCode] = transformFn;
  }
  /**
   * Get a transform given a source code and a destination code.
   * @param {string} sourceCode The code for the source projection.
   * @param {string} destinationCode The code for the destination projection.
   * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
   */

  function get$2(sourceCode, destinationCode) {
    var transform;

    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
      transform = transforms[sourceCode][destinationCode];
    }

    return transform;
  }

  /**
   * @module ol/math
   */

  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param {number} value The input number.
   * @param {number} min The minimum value to return.
   * @param {number} max The maximum value to return.
   * @return {number} The input number if it is within bounds, or the nearest
   *     number within the bounds.
   */
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  /**
   * Returns the square of the closest distance between the point (x, y) and the
   * line segment (x1, y1) to (x2, y2).
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */

  function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;

    if (dx !== 0 || dy !== 0) {
      var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

      if (t > 1) {
        x1 = x2;
        y1 = y2;
      } else if (t > 0) {
        x1 += dx * t;
        y1 += dy * t;
      }
    }

    return squaredDistance(x, y, x1, y1);
  }
  /**
   * Returns the square of the distance between the points (x1, y1) and (x2, y2).
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */

  function squaredDistance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
  }
  /**
   * Solves system of linear equations using Gaussian elimination method.
   *
   * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
   *                                     in row-major order.
   * @return {Array<number>} The resulting vector.
   */

  function solveLinearSystem(mat) {
    var n = mat.length;

    for (var i = 0; i < n; i++) {
      // Find max in the i-th column (ignoring i - 1 first rows)
      var maxRow = i;
      var maxEl = Math.abs(mat[i][i]);

      for (var r = i + 1; r < n; r++) {
        var absValue = Math.abs(mat[r][i]);

        if (absValue > maxEl) {
          maxEl = absValue;
          maxRow = r;
        }
      }

      if (maxEl === 0) {
        return null; // matrix is singular
      } // Swap max row with i-th (current) row


      var tmp = mat[maxRow];
      mat[maxRow] = mat[i];
      mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

      for (var j = i + 1; j < n; j++) {
        var coef = -mat[j][i] / mat[i][i];

        for (var k = i; k < n + 1; k++) {
          if (i == k) {
            mat[j][k] = 0;
          } else {
            mat[j][k] += coef * mat[i][k];
          }
        }
      }
    } // Solve Ax=b for upper triangular matrix A (mat)


    var x = new Array(n);

    for (var l = n - 1; l >= 0; l--) {
      x[l] = mat[l][n] / mat[l][l];

      for (var m = l - 1; m >= 0; m--) {
        mat[m][n] -= mat[m][l] * x[l];
      }
    }

    return x;
  }
  /**
   * Converts degrees to radians.
   *
   * @param {number} angleInDegrees Angle in degrees.
   * @return {number} Angle in radians.
   */

  function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
  }
  /**
   * Returns the modulo of a / b, depending on the sign of b.
   *
   * @param {number} a Dividend.
   * @param {number} b Divisor.
   * @return {number} Modulo.
   */

  function modulo(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r;
  }
  /**
   * Calculates the linearly interpolated value of x between a and b.
   *
   * @param {number} a Number
   * @param {number} b Number
   * @param {number} x Value to be interpolated.
   * @return {number} Interpolated value.
   */

  function lerp(a, b, x) {
    return a + x * (b - a);
  }
  /**
   * Returns a number with a limited number of decimal digits.
   * @param {number} n The input number.
   * @param {number} decimals The maximum number of decimal digits.
   * @return {number} The input number with a limited number of decimal digits.
   */

  function toFixed(n, decimals) {
    var factor = Math.pow(10, decimals);
    return Math.round(n * factor) / factor;
  }
  /**
   * Rounds a number to the next smaller integer considering only the given number
   * of decimal digits (with rounding on the final digit).
   * @param {number} n The input number.
   * @param {number} decimals The maximum number of decimal digits.
   * @return {number} The next smaller integer.
   */

  function floor(n, decimals) {
    return Math.floor(toFixed(n, decimals));
  }
  /**
   * Rounds a number to the next bigger integer considering only the given number
   * of decimal digits (with rounding on the final digit).
   * @param {number} n The input number.
   * @param {number} decimals The maximum number of decimal digits.
   * @return {number} The next bigger integer.
   */

  function ceil(n, decimals) {
    return Math.ceil(toFixed(n, decimals));
  }

  /**
   * @module ol/coordinate
   */
  /**
   * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
   * @typedef {Array<number>} Coordinate
   * @api
   */

  /**
   * A function that takes a {@link module:ol/coordinate~Coordinate} and
   * transforms it into a `{string}`.
   *
   * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
   * @api
   */

  /**
   * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {add} from 'ol/coordinate';
   *
   *     const coord = [7.85, 47.983333];
   *     add(coord, [-2, 4]);
   *     // coord is now [5.85, 51.983333]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {Coordinate} delta Delta.
   * @return {Coordinate} The input coordinate adjusted by
   * the given delta.
   * @api
   */

  function add(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
  }
  /**
   * @param {Coordinate} coordinate1 First coordinate.
   * @param {Coordinate} coordinate2 Second coordinate.
   * @return {boolean} The two coordinates are equal.
   */

  function equals$1(coordinate1, coordinate2) {
    var equals = true;

    for (var i = coordinate1.length - 1; i >= 0; --i) {
      if (coordinate1[i] != coordinate2[i]) {
        equals = false;
        break;
      }
    }

    return equals;
  }
  /**
   * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
   * returned by the function.
   *
   * Example:
   *
   *     import {rotate} from 'ol/coordinate';
   *
   *     const coord = [7.85, 47.983333];
   *     const rotateRadians = Math.PI / 2; // 90 degrees
   *     rotate(coord, rotateRadians);
   *     // coord is now [-47.983333, 7.85]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} angle Angle in radian.
   * @return {Coordinate} Coordinate.
   * @api
   */

  function rotate$1(coordinate, angle) {
    var cosAngle = Math.cos(angle);
    var sinAngle = Math.sin(angle);
    var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x;
    coordinate[1] = y;
    return coordinate;
  }
  /**
   * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {scale as scaleCoordinate} from 'ol/coordinate';
   *
   *     const coord = [7.85, 47.983333];
   *     const scale = 1.2;
   *     scaleCoordinate(coord, scale);
   *     // coord is now [9.42, 57.5799996]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} scale Scale factor.
   * @return {Coordinate} Coordinate.
   */

  function scale$2(coordinate, scale) {
    coordinate[0] *= scale;
    coordinate[1] *= scale;
    return coordinate;
  }
  /**
   * Modifies the provided coordinate in-place to be within the real world
   * extent. The lower projection extent boundary is inclusive, the upper one
   * exclusive.
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {Coordinate} The coordinate within the real world extent.
   */

  function wrapX$1(coordinate, projection) {
    if (projection.canWrapX()) {
      var worldWidth = getWidth(projection.getExtent());
      var worldsAway = getWorldsAway(coordinate, projection, worldWidth);

      if (worldsAway) {
        coordinate[0] -= worldsAway * worldWidth;
      }
    }

    return coordinate;
  }
  /**
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {number} [sourceExtentWidth] Width of the source extent.
   * @return {number} Offset in world widths.
   */

  function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    var projectionExtent = projection.getExtent();
    var worldsAway = 0;

    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
      sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
      worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
    }

    return worldsAway;
  }

  /**
   * @module ol/sphere
   */
  /**
   * Object literal with options for the {@link getLength} or {@link getArea}
   * functions.
   * @typedef {Object} SphereMetricOptions
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
   * Projection of the  geometry.  By default, the geometry is assumed to be in
   * Web Mercator.
   * @property {number} [radius=6371008.8] Sphere radius.  By default, the
   * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
   * for the WGS84 ellipsoid is used.
   */

  /**
   * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
   * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
   * @type {number}
   */

  var DEFAULT_RADIUS = 6371008.8;
  /**
   * Get the great circle distance (in meters) between two geographic coordinates.
   * @param {Array} c1 Starting coordinate.
   * @param {Array} c2 Ending coordinate.
   * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
   *     mean radius using the WGS84 ellipsoid.
   * @return {number} The great circle distance between the points (in meters).
   * @api
   */

  function getDistance(c1, c2, radius) {
    radius = radius || DEFAULT_RADIUS;
    var lat1 = toRadians(c1[1]);
    var lat2 = toRadians(c2[1]);
    var deltaLatBy2 = (lat2 - lat1) / 2;
    var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
    var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  /**
   * @module ol/proj
   */
  var showCoordinateWarning = true;
  /**
   * @param {boolean} [disable = true] Disable console info about `useGeographic()`
   */

  function disableCoordinateWarning(disable) {
    var hide = disable === undefined ? true : disable;
    showCoordinateWarning = !hide;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>} [output] Output array of coordinate values.
   * @param {number} [dimension] Dimension.
   * @return {Array<number>} Output coordinate array (new array, same coordinate
   *     values).
   */

  function cloneTransform(input, output, dimension) {
    if (output !== undefined) {
      for (var i = 0, ii = input.length; i < ii; ++i) {
        output[i] = input[i];
      }

      output = output;
    } else {
      output = input.slice();
    }

    return output;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>} [output] Output array of coordinate values.
   * @param {number} [dimension] Dimension.
   * @return {Array<number>} Input coordinate array (same array as input).
   */

  function identityTransform(input, output, dimension) {
    if (output !== undefined && input !== output) {
      for (var i = 0, ii = input.length; i < ii; ++i) {
        output[i] = input[i];
      }

      input = output;
    }

    return input;
  }
  /**
   * Add a Projection object to the list of supported projections that can be
   * looked up by their code.
   *
   * @param {Projection} projection Projection instance.
   * @api
   */

  function addProjection(projection) {
    add$2(projection.getCode(), projection);
    add$1(projection, projection, cloneTransform);
  }
  /**
   * @param {Array<Projection>} projections Projections.
   */

  function addProjections(projections) {
    projections.forEach(addProjection);
  }
  /**
   * Fetches a Projection object for the code specified.
   *
   * @param {ProjectionLike} projectionLike Either a code string which is
   *     a combination of authority and identifier such as "EPSG:4326", or an
   *     existing projection object, or undefined.
   * @return {Projection|null} Projection object, or null if not in list.
   * @api
   */

  function get$1(projectionLike) {
    return typeof projectionLike === 'string' ? get$3(
    /** @type {string} */
    projectionLike) :
    /** @type {Projection} */
    projectionLike || null;
  }
  /**
   * Get the resolution of the point in degrees or distance units.
   * For projections with degrees as the unit this will simply return the
   * provided resolution. For other projections the point resolution is
   * by default estimated by transforming the `point` pixel to EPSG:4326,
   * measuring its width and height on the normal sphere,
   * and taking the average of the width and height.
   * A custom function can be provided for a specific projection, either
   * by setting the `getPointResolution` option in the
   * {@link module:ol/proj/Projection~Projection} constructor or by using
   * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
   * projection object.
   * @param {ProjectionLike} projection The projection.
   * @param {number} resolution Nominal resolution in projection units.
   * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
   * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
   * Default is the projection's units.
   * @return {number} Point resolution.
   * @api
   */

  function getPointResolution(projection, resolution, point, units) {
    projection = get$1(projection);
    var pointResolution;
    var getter = projection.getPointResolutionFunc();

    if (getter) {
      pointResolution = getter(resolution, point);

      if (units && units !== projection.getUnits()) {
        var metersPerUnit = projection.getMetersPerUnit();

        if (metersPerUnit) {
          pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT$1[units];
        }
      }
    } else {
      var projUnits = projection.getUnits();

      if (projUnits == 'degrees' && !units || units == 'degrees') {
        pointResolution = resolution;
      } else {
        // Estimate point resolution by transforming the center pixel to EPSG:4326,
        // measuring its width and height on the normal sphere, and taking the
        // average of the width and height.
        var _toEPSG = getTransformFromProjections(projection, get$1('EPSG:4326'));

        if (_toEPSG === identityTransform && projUnits !== 'degrees') {
          // no transform is available
          pointResolution = resolution * projection.getMetersPerUnit();
        } else {
          var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
          vertices = _toEPSG(vertices, vertices, 2);
          var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
          var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
          pointResolution = (width + height) / 2;
        }

        var _metersPerUnit = units ? METERS_PER_UNIT$1[units] : projection.getMetersPerUnit();

        if (_metersPerUnit !== undefined) {
          pointResolution /= _metersPerUnit;
        }
      }
    }

    return pointResolution;
  }
  /**
   * Registers transformation functions that don't alter coordinates. Those allow
   * to transform between projections with equal meaning.
   *
   * @param {Array<Projection>} projections Projections.
   * @api
   */

  function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function (source) {
      projections.forEach(function (destination) {
        if (source !== destination) {
          add$1(source, destination, cloneTransform);
        }
      });
    });
  }
  /**
   * Registers transformation functions to convert coordinates in any projection
   * in projection1 to any projection in projection2.
   *
   * @param {Array<Projection>} projections1 Projections with equal
   *     meaning.
   * @param {Array<Projection>} projections2 Projections with equal
   *     meaning.
   * @param {TransformFunction} forwardTransform Transformation from any
   *   projection in projection1 to any projection in projection2.
   * @param {TransformFunction} inverseTransform Transform from any projection
   *   in projection2 to any projection in projection1..
   */

  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function (projection1) {
      projections2.forEach(function (projection2) {
        add$1(projection1, projection2, forwardTransform);
        add$1(projection2, projection1, inverseTransform);
      });
    });
  }
  /**
   * @param {Projection|string|undefined} projection Projection.
   * @param {string} defaultCode Default code.
   * @return {Projection} Projection.
   */

  function createProjection(projection, defaultCode) {
    if (!projection) {
      return get$1(defaultCode);
    } else if (typeof projection === 'string') {
      return get$1(projection);
    } else {
      return (
        /** @type {Projection} */
        projection
      );
    }
  }
  /**
   * Checks if two projections are the same, that is every coordinate in one
   * projection does represent the same geographic point as the same coordinate in
   * the other projection.
   *
   * @param {Projection} projection1 Projection 1.
   * @param {Projection} projection2 Projection 2.
   * @return {boolean} Equivalent.
   * @api
   */

  function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
      return true;
    }

    var equalUnits = projection1.getUnits() === projection2.getUnits();

    if (projection1.getCode() === projection2.getCode()) {
      return equalUnits;
    } else {
      var transformFunc = getTransformFromProjections(projection1, projection2);
      return transformFunc === cloneTransform && equalUnits;
    }
  }
  /**
   * Searches in the list of transform functions for the function for converting
   * coordinates from the source projection to the destination projection.
   *
   * @param {Projection} sourceProjection Source Projection object.
   * @param {Projection} destinationProjection Destination Projection
   *     object.
   * @return {TransformFunction} Transform function.
   */

  function getTransformFromProjections(sourceProjection, destinationProjection) {
    var sourceCode = sourceProjection.getCode();
    var destinationCode = destinationProjection.getCode();
    var transformFunc = get$2(sourceCode, destinationCode);

    if (!transformFunc) {
      transformFunc = identityTransform;
    }

    return transformFunc;
  }
  /**
   * Given the projection-like objects, searches for a transformation
   * function to convert a coordinates array from the source projection to the
   * destination projection.
   *
   * @param {ProjectionLike} source Source.
   * @param {ProjectionLike} destination Destination.
   * @return {TransformFunction} Transform function.
   * @api
   */

  function getTransform(source, destination) {
    var sourceProjection = get$1(source);
    var destinationProjection = get$1(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  /**
   * Transforms a coordinate from source projection to destination projection.
   * This returns a new coordinate (and does not modify the original).
   *
   * See {@link module:ol/proj.transformExtent} for extent transformation.
   * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
   * subclasses for geometry transforms.
   *
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */

  function transform(coordinate, source, destination) {
    var transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, undefined, coordinate.length);
  }
  /**
   * @type {Projection|null}
   */

  var userProjection = null;
  /**
   * Get the projection for coordinates supplied from and returned by API methods.
   * Note that this method is not yet a part of the stable API.  Support for user
   * projections is not yet complete and should be considered experimental.
   * @return {Projection|null} The user projection (or null if not set).
   * @api
   */

  function getUserProjection() {
    return userProjection;
  }
  /**
   * Return a coordinate transformed into the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} sourceProjection The input coordinate projection.
   * @return {Array<number>} The input coordinate in the user projection.
   */

  function toUserCoordinate(coordinate, sourceProjection) {
    {
      return coordinate;
    }
  }
  /**
   * Return a coordinate transformed from the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} destProjection The destination projection.
   * @return {Array<number>} The input coordinate transformed.
   */

  function fromUserCoordinate(coordinate, destProjection) {
    {
      if (showCoordinateWarning && !equals$1(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
        showCoordinateWarning = false; // eslint-disable-next-line no-console

        console.warn('Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.');
      }

      return coordinate;
    }
  }
  /**
   * Return an extent transformed into the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} sourceProjection The input extent projection.
   * @return {import("./extent.js").Extent} The input extent in the user projection.
   */

  function toUserExtent(extent, sourceProjection) {
    {
      return extent;
    }
  }
  /**
   * Return an extent transformed from the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} destProjection The destination projection.
   * @return {import("./extent.js").Extent} The input extent transformed.
   */

  function fromUserExtent(extent, destProjection) {
    {
      return extent;
    }
  }
  /**
   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
   * by when this module is executed and should only need to be called again after
   * `clearAllProjections()` is called (e.g. in tests).
   */

  function addCommon() {
    // Add transformations that don't alter coordinates to convert within set of
    // projections with equal meaning.
    addEquivalentProjections(PROJECTIONS$1);
    addEquivalentProjections(PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
    // coordinates and back.

    addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
  }
  addCommon();

  /**
   * @module ol/geom/flat/transform
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<number>} [dest] Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function transform2D(flatCoordinates, offset, end, stride, transform, dest) {
    dest = dest ? dest : [];
    var i = 0;

    for (var j = offset; j < end; j += stride) {
      var x = flatCoordinates[j];
      var y = flatCoordinates[j + 1];
      dest[i++] = transform[0] * x + transform[2] * y + transform[4];
      dest[i++] = transform[1] * x + transform[3] * y + transform[5];
    }

    if (dest && dest.length != i) {
      dest.length = i;
    }

    return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} angle Angle.
   * @param {Array<number>} anchor Rotation anchor point.
   * @param {Array<number>} [dest] Destination.
   * @return {Array<number>} Transformed coordinates.
   */

  function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;

    for (var j = offset; j < end; j += stride) {
      var deltaX = flatCoordinates[j] - anchorX;
      var deltaY = flatCoordinates[j + 1] - anchorY;
      dest[i++] = anchorX + deltaX * cos - deltaY * sin;
      dest[i++] = anchorY + deltaX * sin + deltaY * cos;

      for (var k = j + 2; k < j + stride; ++k) {
        dest[i++] = flatCoordinates[k];
      }
    }

    if (dest && dest.length != i) {
      dest.length = i;
    }

    return dest;
  }
  /**
   * Scale the coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} sx Scale factor in the x-direction.
   * @param {number} sy Scale factor in the y-direction.
   * @param {Array<number>} anchor Scale anchor point.
   * @param {Array<number>} [dest] Destination.
   * @return {Array<number>} Transformed coordinates.
   */

  function scale$1(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    var anchorX = anchor[0];
    var anchorY = anchor[1];
    var i = 0;

    for (var j = offset; j < end; j += stride) {
      var deltaX = flatCoordinates[j] - anchorX;
      var deltaY = flatCoordinates[j + 1] - anchorY;
      dest[i++] = anchorX + sx * deltaX;
      dest[i++] = anchorY + sy * deltaY;

      for (var k = j + 2; k < j + stride; ++k) {
        dest[i++] = flatCoordinates[k];
      }
    }

    if (dest && dest.length != i) {
      dest.length = i;
    }

    return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @param {Array<number>} [dest] Destination.
   * @return {Array<number>} Transformed coordinates.
   */

  function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    var i = 0;

    for (var j = offset; j < end; j += stride) {
      dest[i++] = flatCoordinates[j] + deltaX;
      dest[i++] = flatCoordinates[j + 1] + deltaY;

      for (var k = j + 2; k < j + stride; ++k) {
        dest[i++] = flatCoordinates[k];
      }
    }

    if (dest && dest.length != i) {
      dest.length = i;
    }

    return dest;
  }

  /**
   * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
   * or measure ('M') coordinate is available.
   */

  /**
   * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
   * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
   * `'GeometryCollection'`, or `'Circle'`.
   */

  /**
   * @type {import("../transform.js").Transform}
   */

  var tmpTransform = create$1();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for vector geometries.
   *
   * To get notified of changes to the geometry, register a listener for the
   * generic `change` event on your geometry instance.
   *
   * @abstract
   * @api
   */

  var Geometry = /*#__PURE__*/function (_BaseObject) {
    _inherits(Geometry, _BaseObject);

    var _super = _createSuper(Geometry);

    function Geometry() {
      var _this;

      _classCallCheck(this, Geometry);

      _this = _super.call(this);
      /**
       * @private
       * @type {import("../extent.js").Extent}
       */

      _this.extent_ = createEmpty();
      /**
       * @private
       * @type {number}
       */

      _this.extentRevision_ = -1;
      /**
       * @protected
       * @type {number}
       */

      _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      /**
       * @protected
       * @type {number}
       */

      _this.simplifiedGeometryRevision = 0;
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} revision The geometry revision.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */

      _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, transform) {
        if (!transform) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }

        var clone = this.clone();
        clone.applyTransform(transform);
        return clone.getSimplifiedGeometry(squaredTolerance);
      });
      return _this;
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */


    _createClass(Geometry, [{
      key: "simplifyTransformed",
      value: function simplifyTransformed(squaredTolerance, transform) {
        return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, transform);
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */

    }, {
      key: "clone",
      value: function clone() {
        return _abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return _abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */

    }, {
      key: "containsXY",
      value: function containsXY(x, y) {
        var coord = this.getClosestPoint([x, y]);
        return coord[0] === x && coord[1] === y;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */

    }, {
      key: "getClosestPoint",
      value: function getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */

    }, {
      key: "intersectsCoordinate",
      value: function intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */

    }, {
      key: "computeExtent",
      value: function computeExtent(extent) {
        return _abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */

    }, {
      key: "getExtent",
      value: function getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          var _extent = this.computeExtent(this.extent_);

          if (isNaN(_extent[0]) || isNaN(_extent[1])) {
            createOrUpdateEmpty(_extent);
          }

          this.extentRevision_ = this.getRevision();
        }

        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */

    }, {
      key: "rotate",
      value: function rotate(angle, anchor) {
        _abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */

    }, {
      key: "scale",
      value: function scale(sx, sy, anchor) {
        _abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */

    }, {
      key: "simplify",
      value: function simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */

    }, {
      key: "getSimplifiedGeometry",
      value: function getSimplifiedGeometry(squaredTolerance) {
        return _abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */

    }, {
      key: "getType",
      value: function getType() {
        return _abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */

    }, {
      key: "applyTransform",
      value: function applyTransform(transformFn) {
        _abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return _abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */

    }, {
      key: "translate",
      value: function translate(deltaX, deltaY) {
        _abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */

    }, {
      key: "transform",
      value: function transform(source, destination) {
        /** @type {import("../proj/Projection.js").default} */
        var sourceProj = get$1(source);
        var transformFn = sourceProj.getUnits() == 'tile-pixels' ? function (inCoordinates, outCoordinates, stride) {
          var pixelExtent = sourceProj.getExtent();
          var projectedExtent = sourceProj.getWorldExtent();
          var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
          transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
          return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    }]);

    return Geometry;
  }(BaseObject);

  /**
   * @classdesc
   * An array of {@link module:ol/geom/Geometry~Geometry} objects.
   *
   * @api
   */

  var GeometryCollection = /*#__PURE__*/function (_Geometry) {
    _inherits(GeometryCollection, _Geometry);

    var _super = _createSuper(GeometryCollection);

    /**
     * @param {Array<Geometry>} [geometries] Geometries.
     */
    function GeometryCollection(geometries) {
      var _this;

      _classCallCheck(this, GeometryCollection);

      _this = _super.call(this);
      /**
       * @private
       * @type {Array<Geometry>}
       */

      _this.geometries_ = geometries ? geometries : null;
      /**
       * @type {Array<import("../events.js").EventsKey>}
       */

      _this.changeEventsKeys_ = [];

      _this.listenGeometriesChange_();

      return _this;
    }
    /**
     * @private
     */


    _createClass(GeometryCollection, [{
      key: "unlistenGeometriesChange_",
      value: function unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(unlistenByKey);
        this.changeEventsKeys_.length = 0;
      }
      /**
       * @private
       */

    }, {
      key: "listenGeometriesChange_",
      value: function listenGeometriesChange_() {
        if (!this.geometries_) {
          return;
        }

        for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
          this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!GeometryCollection} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var geometryCollection = new GeometryCollection(null);
        geometryCollection.setGeometries(this.geometries_);
        geometryCollection.applyProperties(this);
        return geometryCollection;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
        }

        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */

    }, {
      key: "containsXY",
      value: function containsXY(x, y) {
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].containsXY(x, y)) {
            return true;
          }
        }

        return false;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */

    }, {
      key: "computeExtent",
      value: function computeExtent(extent) {
        createOrUpdateEmpty(extent);
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          extend(extent, geometries[i].getExtent());
        }

        return extent;
      }
      /**
       * Return the geometries that make up this geometry collection.
       * @return {Array<Geometry>} Geometries.
       * @api
       */

    }, {
      key: "getGeometries",
      value: function getGeometries() {
        return cloneGeometries(this.geometries_);
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */

    }, {
      key: "getGeometriesArray",
      value: function getGeometriesArray() {
        return this.geometries_;
      }
      /**
       * @return {Array<Geometry>} Geometries.
       */

    }, {
      key: "getGeometriesArrayRecursive",
      value: function getGeometriesArrayRecursive() {
        /** @type {Array<Geometry>} */
        var geometriesArray = [];
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].getType() === this.getType()) {
            geometriesArray = geometriesArray.concat(
            /** @type {GeometryCollection} */
            geometries[i].getGeometriesArrayRecursive());
          } else {
            geometriesArray.push(geometries[i]);
          }
        }

        return geometriesArray;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {GeometryCollection} Simplified GeometryCollection.
       */

    }, {
      key: "getSimplifiedGeometry",
      value: function getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }

        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }

        var simplifiedGeometries = [];
        var geometries = this.geometries_;
        var simplified = false;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          var geometry = geometries[i];
          var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
          simplifiedGeometries.push(simplifiedGeometry);

          if (simplifiedGeometry !== geometry) {
            simplified = true;
          }
        }

        if (simplified) {
          var simplifiedGeometryCollection = new GeometryCollection(null);
          simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
          return simplifiedGeometryCollection;
        } else {
          this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
          return this;
        }
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'GeometryCollection';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          if (geometries[i].intersectsExtent(extent)) {
            return true;
          }
        }

        return false;
      }
      /**
       * @return {boolean} Is empty.
       */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.geometries_.length === 0;
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */

    }, {
      key: "rotate",
      value: function rotate(angle, anchor) {
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].rotate(angle, anchor);
        }

        this.changed();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */

    }, {
      key: "scale",
      value: function scale(sx, sy, anchor) {
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }

        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].scale(sx, sy, anchor);
        }

        this.changed();
      }
      /**
       * Set the geometries that make up this geometry collection.
       * @param {Array<Geometry>} geometries Geometries.
       * @api
       */

    }, {
      key: "setGeometries",
      value: function setGeometries(geometries) {
        this.setGeometriesArray(cloneGeometries(geometries));
      }
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */

    }, {
      key: "setGeometriesArray",
      value: function setGeometriesArray(geometries) {
        this.unlistenGeometriesChange_();
        this.geometries_ = geometries;
        this.listenGeometriesChange_();
        this.changed();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */

    }, {
      key: "applyTransform",
      value: function applyTransform(transformFn) {
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].applyTransform(transformFn);
        }

        this.changed();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */

    }, {
      key: "translate",
      value: function translate(deltaX, deltaY) {
        var geometries = this.geometries_;

        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          geometries[i].translate(deltaX, deltaY);
        }

        this.changed();
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        this.unlistenGeometriesChange_();

        _get(_getPrototypeOf(GeometryCollection.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return GeometryCollection;
  }(Geometry);
  /**
   * @param {Array<Geometry>} geometries Geometries.
   * @return {Array<Geometry>} Cloned geometries.
   */


  function cloneGeometries(geometries) {
    var clonedGeometries = [];

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      clonedGeometries.push(geometries[i].clone());
    }

    return clonedGeometries;
  }

  /**
   * @typedef {Object} ReadOptions
   * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
   * If not provided, the projection will be derived from the data (where possible) or
   * the `dataProjection` of the format is assigned (where set). If the projection
   * can not be derived from the data and if no `dataProjection` is set for a format,
   * the features will not be reprojected.
   * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
   * This is only required when reading data with tile pixels as geometry units. When configured,
   * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
   * provided.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
   * created by the format reader. If not provided, features will be returned in the
   * `dataProjection`.
   */

  /**
   * @typedef {Object} WriteOptions
   * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
   * If not provided, the `dataProjection` of the format is assigned (where set).
   * If no `dataProjection` is set for a format, the features will be returned
   * in the `featureProjection`.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
   * that will be serialized by the format writer. If not provided, geometries are assumed
   * to be in the `dataProjection` if that is set; in other words, they are not transformed.
   * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
   * rule for linear ring orientation.  This means that polygons will have counter-clockwise
   * exterior rings and clockwise interior rings.  By default, coordinates are serialized
   * as they are provided at construction.  If `true`, the right-hand rule will
   * be applied.  If `false`, the left-hand rule will be applied (clockwise for
   * exterior and counter-clockwise for interior rings).  Note that not all
   * formats support this.  The GeoJSON format does use this property when writing
   * geometries.
   * @property {number} [decimals] Maximum number of decimal places for coordinates.
   * Coordinates are stored internally as floats, but floating-point arithmetic can create
   * coordinates with a large number of decimal places, not generally wanted on output.
   * Set a number here to round coordinates. Can also be used to ensure that
   * coordinates read in can be written back out with the same number of decimals.
   * Default is no rounding.
   */

  /**
   * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for feature formats.
   * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
   * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
   * file formats.  See the documentation for each format for more details.
   *
   * @abstract
   * @api
   */

  var FeatureFormat = /*#__PURE__*/function () {
    function FeatureFormat() {
      _classCallCheck(this, FeatureFormat);

      /**
       * @protected
       * @type {import("../proj/Projection.js").default|undefined}
       */
      this.dataProjection = undefined;
      /**
       * @protected
       * @type {import("../proj/Projection.js").default|undefined}
       */

      this.defaultFeatureProjection = undefined;
      /**
       * A list media types supported by the format in descending order of preference.
       * @type {Array<string>}
       */

      this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */


    _createClass(FeatureFormat, [{
      key: "getReadOptions",
      value: function getReadOptions(source, options) {
        if (options) {
          var dataProjection = options.dataProjection ? get$1(options.dataProjection) : this.readProjection(source);

          if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {
            dataProjection = get$1(dataProjection);
            dataProjection.setWorldExtent(options.extent);
          }

          options = {
            dataProjection: dataProjection,
            featureProjection: options.featureProjection
          };
        }

        return this.adaptOptions(options);
      }
      /**
       * Sets the `dataProjection` on the options, if no `dataProjection`
       * is set.
       * @param {WriteOptions|ReadOptions|undefined} options
       *     Options.
       * @protected
       * @return {WriteOptions|ReadOptions|undefined}
       *     Updated options.
       */

    }, {
      key: "adaptOptions",
      value: function adaptOptions(options) {
        return Object.assign({
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection
        }, options);
      }
      /**
       * @abstract
       * @return {Type} The format type.
       */

    }, {
      key: "getType",
      value: function getType() {
        return _abstract();
      }
      /**
       * Read a single feature from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {import("../Feature.js").FeatureLike} Feature.
       */

    }, {
      key: "readFeature",
      value: function readFeature(source, options) {
        return _abstract();
      }
      /**
       * Read all features from a source.
       *
       * @abstract
       * @param {Document|Element|ArrayBuffer|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {Array<import("../Feature.js").FeatureLike>} Features.
       */

    }, {
      key: "readFeatures",
      value: function readFeatures(source, options) {
        return _abstract();
      }
      /**
       * Read a single geometry from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       */

    }, {
      key: "readGeometry",
      value: function readGeometry(source, options) {
        return _abstract();
      }
      /**
       * Read the projection from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default|undefined} Projection.
       */

    }, {
      key: "readProjection",
      value: function readProjection(source) {
        return _abstract();
      }
      /**
       * Encode a feature in this format.
       *
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */

    }, {
      key: "writeFeature",
      value: function writeFeature(feature, options) {
        return _abstract();
      }
      /**
       * Encode an array of features in this format.
       *
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */

    }, {
      key: "writeFeatures",
      value: function writeFeatures(features, options) {
        return _abstract();
      }
      /**
       * Write a single geometry in this format.
       *
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {WriteOptions} [options] Write options.
       * @return {string|ArrayBuffer} Result.
       */

    }, {
      key: "writeGeometry",
      value: function writeGeometry(geometry, options) {
        return _abstract();
      }
    }]);

    return FeatureFormat;
  }();
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {boolean} write Set to true for writing, false for reading.
   * @param {WriteOptions|ReadOptions} [options] Options.
   * @return {import("../geom/Geometry.js").default} Transformed geometry.
   */

  function transformGeometryWithOptions(geometry, write, options) {
    var featureProjection = options ? get$1(options.featureProjection) : null;
    var dataProjection = options ? get$1(options.dataProjection) : null;
    var transformed;

    if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    } else {
      transformed = geometry;
    }

    if (write && options &&
    /** @type {WriteOptions} */
    options.decimals !== undefined) {
      var power = Math.pow(10,
      /** @type {WriteOptions} */
      options.decimals); // if decimals option on write, round each coordinate appropriately

      /**
       * @param {Array<number>} coordinates Coordinates.
       * @return {Array<number>} Transformed coordinates.
       */

      var transform = function transform(coordinates) {
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          coordinates[i] = Math.round(coordinates[i] * power) / power;
        }

        return coordinates;
      };

      if (transformed === geometry) {
        transformed = geometry.clone();
      }

      transformed.applyTransform(transform);
    }

    return transformed;
  }

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for JSON feature formats.
   *
   * @abstract
   */

  var JSONFeature = /*#__PURE__*/function (_FeatureFormat) {
    _inherits(JSONFeature, _FeatureFormat);

    var _super = _createSuper(JSONFeature);

    function JSONFeature() {
      _classCallCheck(this, JSONFeature);

      return _super.call(this);
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     */


    _createClass(JSONFeature, [{
      key: "getType",
      value: function getType() {
        return 'json';
      }
      /**
       * Read a feature.  Only works for a single feature. Use `readFeatures` to
       * read a feature collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {import("../Feature.js").default} Feature.
       * @api
       */

    }, {
      key: "readFeature",
      value: function readFeature(source, options) {
        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, options));
      }
      /**
       * Read all features.  Works with both a single feature and a feature
       * collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */

    }, {
      key: "readFeatures",
      value: function readFeatures(source, options) {
        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, options));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../Feature.js").default} Feature.
       */

    }, {
      key: "readFeatureFromObject",
      value: function readFeatureFromObject(object, options) {
        return _abstract();
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<import("../Feature.js").default>} Features.
       */

    }, {
      key: "readFeaturesFromObject",
      value: function readFeaturesFromObject(object, options) {
        return _abstract();
      }
      /**
       * Read a geometry.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       */

    }, {
      key: "readGeometry",
      value: function readGeometry(source, options) {
        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, options));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */

    }, {
      key: "readGeometryFromObject",
      value: function readGeometryFromObject(object, options) {
        return _abstract();
      }
      /**
       * Read the projection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       */

    }, {
      key: "readProjection",
      value: function readProjection(source) {
        return this.readProjectionFromObject(getObject(source));
      }
      /**
       * @abstract
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */

    }, {
      key: "readProjectionFromObject",
      value: function readProjectionFromObject(object) {
        return _abstract();
      }
      /**
       * Encode a feature as string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded feature.
       * @api
       */

    }, {
      key: "writeFeature",
      value: function writeFeature(feature, options) {
        return JSON.stringify(this.writeFeatureObject(feature, options));
      }
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */

    }, {
      key: "writeFeatureObject",
      value: function writeFeatureObject(feature, options) {
        return _abstract();
      }
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded features.
       * @api
       */

    }, {
      key: "writeFeatures",
      value: function writeFeatures(features, options) {
        return JSON.stringify(this.writeFeaturesObject(features, options));
      }
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */

    }, {
      key: "writeFeaturesObject",
      value: function writeFeaturesObject(features, options) {
        return _abstract();
      }
      /**
       * Encode a geometry as string.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {string} Encoded geometry.
       * @api
       */

    }, {
      key: "writeGeometry",
      value: function writeGeometry(geometry, options) {
        return JSON.stringify(this.writeGeometryObject(geometry, options));
      }
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {Object} Object.
       */

    }, {
      key: "writeGeometryObject",
      value: function writeGeometryObject(geometry, options) {
        return _abstract();
      }
    }]);

    return JSONFeature;
  }(FeatureFormat);
  /**
   * @param {Document|Element|Object|string} source Source.
   * @return {Object} Object.
   */


  function getObject(source) {
    if (typeof source === 'string') {
      var object = JSON.parse(source);
      return object ?
      /** @type {Object} */
      object : null;
    } else if (source !== null) {
      return source;
    } else {
      return null;
    }
  }

  /**
   * @classdesc
   * Abstract base class; only used for creating subclasses; do not instantiate
   * in apps, as cannot be rendered.
   *
   * @abstract
   * @api
   */

  var SimpleGeometry = /*#__PURE__*/function (_Geometry) {
    _inherits(SimpleGeometry, _Geometry);

    var _super = _createSuper(SimpleGeometry);

    function SimpleGeometry() {
      var _this;

      _classCallCheck(this, SimpleGeometry);

      _this = _super.call(this);
      /**
       * @protected
       * @type {import("./Geometry.js").GeometryLayout}
       */

      _this.layout = 'XY';
      /**
       * @protected
       * @type {number}
       */

      _this.stride = 2;
      /**
       * @protected
       * @type {Array<number>}
       */

      _this.flatCoordinates = null;
      return _this;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */


    _createClass(SimpleGeometry, [{
      key: "computeExtent",
      value: function computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return _abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */

    }, {
      key: "getFirstCoordinate",
      value: function getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */

    }, {
      key: "getFlatCoordinates",
      value: function getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */

    }, {
      key: "getLastCoordinate",
      value: function getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */

    }, {
      key: "getLayout",
      value: function getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */

    }, {
      key: "getSimplifiedGeometry",
      value: function getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        } // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.


        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }

        var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        } else {
          // Simplification did not actually remove any coordinates.  We now know
          // that any calls to getSimplifiedGeometry with a squaredTolerance less
          // than or equal to the current squaredTolerance will also not have any
          // effect.  This allows us to short circuit simplification (saving CPU
          // cycles) and prevents the cache of simplified geometries from filling
          // up with useless identical copies of this geometry (saving memory).
          this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
          return this;
        }
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */

    }, {
      key: "getStride",
      value: function getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */

    }, {
      key: "setFlatCoordinates",
      value: function setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        _abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */

    }, {
      key: "setLayout",
      value: function setLayout(layout, coordinates, nesting) {
        /** @type {number} */
        var stride;

        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (var i = 0; i < nesting; ++i) {
            if (coordinates.length === 0) {
              this.layout = 'XY';
              this.stride = 2;
              return;
            } else {
              coordinates =
              /** @type {Array} */
              coordinates[0];
            }
          }

          stride = coordinates.length;
          layout = getLayoutForStride(stride);
        }

        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */

    }, {
      key: "applyTransform",
      value: function applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */

    }, {
      key: "rotate",
      value: function rotate$1(angle, anchor) {
        var flatCoordinates = this.getFlatCoordinates();

        if (flatCoordinates) {
          var stride = this.getStride();

          rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);

          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */

    }, {
      key: "scale",
      value: function scale(sx, sy, anchor) {
        if (sy === undefined) {
          sy = sx;
        }

        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }

        var flatCoordinates = this.getFlatCoordinates();

        if (flatCoordinates) {
          var stride = this.getStride();

          scale$1(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);

          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */

    }, {
      key: "translate",
      value: function translate$1(deltaX, deltaY) {
        var flatCoordinates = this.getFlatCoordinates();

        if (flatCoordinates) {
          var stride = this.getStride();

          translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);

          this.changed();
        }
      }
    }]);

    return SimpleGeometry;
  }(Geometry);
  /**
   * @param {number} stride Stride.
   * @return {import("./Geometry.js").GeometryLayout} layout Layout.
   */


  function getLayoutForStride(stride) {
    var layout;

    if (stride == 2) {
      layout = 'XY';
    } else if (stride == 3) {
      layout = 'XYZ';
    } else if (stride == 4) {
      layout = 'XYZM';
    }

    return (
      /** @type {import("./Geometry.js").GeometryLayout} */
      layout
    );
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @return {number} Stride.
   */


  function getStrideForLayout(layout) {
    var stride;

    if (layout == 'XY') {
      stride = 2;
    } else if (layout == 'XYZ' || layout == 'XYM') {
      stride = 3;
    } else if (layout == 'XYZM') {
      stride = 4;
    }

    return (
      /** @type {number} */
      stride
    );
  }

  /**
   * @module ol/geom/flat/closest
   */
  /**
   * Returns the point on the 2D line segment flatCoordinates[offset1] to
   * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
   * dimensions are linearly interpolated.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset1 Offset 1.
   * @param {number} offset2 Offset 2.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   */

  function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
    var x1 = flatCoordinates[offset1];
    var y1 = flatCoordinates[offset1 + 1];
    var dx = flatCoordinates[offset2] - x1;
    var dy = flatCoordinates[offset2 + 1] - y1;
    var offset;

    if (dx === 0 && dy === 0) {
      offset = offset1;
    } else {
      var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

      if (t > 1) {
        offset = offset2;
      } else if (t > 0) {
        for (var i = 0; i < stride; ++i) {
          closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
        }

        closestPoint.length = stride;
        return;
      } else {
        offset = offset1;
      }
    }

    for (var _i = 0; _i < stride; ++_i) {
      closestPoint[_i] = flatCoordinates[offset + _i];
    }

    closestPoint.length = stride;
  }
  /**
   * Return the squared of the largest distance between any pair of consecutive
   * coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */


  function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];

    for (offset += stride; offset < end; offset += stride) {
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      var squaredDelta = squaredDistance(x1, y1, x2, y2);

      if (squaredDelta > max) {
        max = squaredDelta;
      }

      x1 = x2;
      y1 = y2;
    }

    return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */

  function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
      offset = end;
    }

    return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */

  function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
      offset = ends[ends.length - 1];
    }

    return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>} [tmpPoint] Temporary point object.
   * @return {number} Minimum squared distance.
   */

  function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset == end) {
      return minSquaredDistance;
    }

    var i, squaredDistance$1;

    if (maxDelta === 0) {
      // All points are identical, so just test the first point.
      squaredDistance$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

      if (squaredDistance$1 < minSquaredDistance) {
        for (i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[offset + i];
        }

        closestPoint.length = stride;
        return squaredDistance$1;
      } else {
        return minSquaredDistance;
      }
    }

    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    var index = offset + stride;

    while (index < end) {
      assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
      squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

      if (squaredDistance$1 < minSquaredDistance) {
        minSquaredDistance = squaredDistance$1;

        for (i = 0; i < stride; ++i) {
          closestPoint[i] = tmpPoint[i];
        }

        closestPoint.length = stride;
        index += stride;
      } else {
        // Skip ahead multiple points, because we know that all the skipped
        // points cannot be any closer than the closest point we have found so
        // far.  We know this because we know how close the current point is, how
        // close the closest point we have found so far is, and the maximum
        // distance between consecutive points.  For example, if we're currently
        // at distance 10, the best we've found so far is 3, and that the maximum
        // distance between consecutive points is 2, then we'll need to skip at
        // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
        // finding a closer point.  We use Math.max(..., 1) to ensure that we
        // always advance at least one point, to avoid an infinite loop.
        index += stride * Math.max((Math.sqrt(squaredDistance$1) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
      }
    }

    if (isRing) {
      // Check the closing segment.
      assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
      squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);

      if (squaredDistance$1 < minSquaredDistance) {
        minSquaredDistance = squaredDistance$1;

        for (i = 0; i < stride; ++i) {
          closestPoint[i] = tmpPoint[i];
        }

        closestPoint.length = stride;
      }
    }

    return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>} [tmpPoint] Temporary point object.
   * @return {number} Minimum squared distance.
   */

  function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
      offset = end;
    }

    return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>} [tmpPoint] Temporary point object.
   * @return {number} Minimum squared distance.
   */

  function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
      offset = ends[ends.length - 1];
    }

    return minSquaredDistance;
  }

  /**
   * @module ol/geom/flat/deflate
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
    for (var i = 0, ii = coordinate.length; i < ii; ++i) {
      flatCoordinates[offset++] = coordinate[i];
    }

    return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */

  function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
    for (var i = 0, ii = coordinates.length; i < ii; ++i) {
      var coordinate = coordinates[i];

      for (var j = 0; j < stride; ++j) {
        flatCoordinates[offset++] = coordinate[j];
      }
    }

    return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
   * @param {number} stride Stride.
   * @param {Array<number>} [ends] Ends.
   * @return {Array<number>} Ends.
   */

  function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
    ends = ends ? ends : [];
    var i = 0;

    for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
      var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
      ends[i++] = end;
      offset = end;
    }

    ends.length = i;
    return ends;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
   * @param {number} stride Stride.
   * @param {Array<Array<number>>} [endss] Endss.
   * @return {Array<Array<number>>} Endss.
   */

  function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, endss) {
    endss = endss ? endss : [];
    var i = 0;

    for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
      var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);

      if (ends.length === 0) {
        ends[0] = offset;
      }

      endss[i++] = ends;
      offset = ends[ends.length - 1];
    }

    endss.length = i;
    return endss;
  }

  /**
   * @module ol/geom/flat/simplify
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */

  function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    var n = (end - offset) / stride;

    if (n < 3) {
      for (; offset < end; offset += stride) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
      }

      return simplifiedOffset;
    }
    /** @type {Array<number>} */


    var markers = new Array(n);
    markers[0] = 1;
    markers[n - 1] = 1;
    /** @type {Array<number>} */

    var stack = [offset, end - stride];
    var index = 0;

    while (stack.length > 0) {
      var last = stack.pop();
      var first = stack.pop();
      var maxSquaredDistance = 0;
      var x1 = flatCoordinates[first];
      var y1 = flatCoordinates[first + 1];
      var x2 = flatCoordinates[last];
      var y2 = flatCoordinates[last + 1];

      for (var i = first + stride; i < last; i += stride) {
        var x = flatCoordinates[i];
        var y = flatCoordinates[i + 1];

        var _squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);

        if (_squaredDistance > maxSquaredDistance) {
          index = i;
          maxSquaredDistance = _squaredDistance;
        }
      }

      if (maxSquaredDistance > squaredTolerance) {
        markers[(index - offset) / stride] = 1;

        if (first + stride < index) {
          stack.push(first, index);
        }

        if (index + stride < last) {
          stack.push(index, last);
        }
      }
    }

    for (var _i = 0; _i < n; ++_i) {
      if (markers[_i]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + _i * stride + 1];
      }
    }

    return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */

  function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
      simplifiedEnds.push(simplifiedOffset);
      offset = end;
    }

    return simplifiedOffset;
  }
  /**
   * @param {number} value Value.
   * @param {number} tolerance Tolerance.
   * @return {number} Rounded value.
   */

  function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
  }
  /**
   * Simplifies a line string using an algorithm designed by Tim Schaub.
   * Coordinates are snapped to the nearest value in a virtual grid and
   * consecutive duplicate coordinates are discarded.  This effectively preserves
   * topology as the simplification of any subsection of a line string is
   * independent of the rest of the line string.  This means that, for examples,
   * the common edge between two polygons will be simplified to the same line
   * string independently in both polygons.  This implementation uses a single
   * pass over the coordinates and eliminates intermediate collinear points.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */

  function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    // do nothing if the line is empty
    if (offset == end) {
      return simplifiedOffset;
    } // snap the first coordinate (P1)


    var x1 = snap(flatCoordinates[offset], tolerance);
    var y1 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // add the first coordinate to the output

    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
    // coordinate (P2)

    var x2, y2;

    do {
      x2 = snap(flatCoordinates[offset], tolerance);
      y2 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;

      if (offset == end) {
        // all coordinates snap to the same value, the line collapses to a point
        // push the last snapped value anyway to ensure that the output contains
        // at least two points
        // FIXME should we really return at least two points anyway?
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        return simplifiedOffset;
      }
    } while (x2 == x1 && y2 == y1);

    while (offset < end) {
      // snap the next coordinate (P3)
      var x3 = snap(flatCoordinates[offset], tolerance);
      var y3 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride; // skip P3 if it is equal to P2

      if (x3 == x2 && y3 == y2) {
        continue;
      } // calculate the delta between P1 and P2


      var dx1 = x2 - x1;
      var dy1 = y2 - y1; // calculate the delta between P3 and P1

      var dx2 = x3 - x1;
      var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
      // P1 in the same direction then P2 is on the straight line between P1 and
      // P3

      if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
        // discard P2 and set P2 = P3
        x2 = x3;
        y2 = y3;
        continue;
      } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
      // between P3 and P1 or on the opposite half of the line to P2.  add P2,
      // and continue with P1 = P2 and P2 = P3


      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
      x2 = x3;
      y2 = y3;
    } // add the last point (P2)


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */

  function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
      simplifiedEnds.push(simplifiedOffset);
      offset = end;
    }

    return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
   * @return {number} Simplified offset.
   */

  function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      var simplifiedEnds = [];
      simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
      simplifiedEndss.push(simplifiedEnds);
      offset = ends[ends.length - 1];
    }

    return simplifiedOffset;
  }

  /**
   * @module ol/geom/flat/segments
   */

  /**
   * This function calls `callback` for each segment of the flat coordinates
   * array. If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T
   */
  function forEach(flatCoordinates, offset, end, stride, callback) {
    var ret;
    offset += stride;

    for (; offset < end; offset += stride) {
      ret = callback(flatCoordinates.slice(offset - stride, offset), flatCoordinates.slice(offset, offset + stride));

      if (ret) {
        return ret;
      }
    }

    return false;
  }

  /**
   * @module ol/geom/flat/inflate
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
   * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
   */
  function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates) {
    coordinates = coordinates !== undefined ? coordinates : [];
    var i = 0;

    for (var j = offset; j < end; j += stride) {
      coordinates[i++] = flatCoordinates.slice(j, j + stride);
    }

    coordinates.length = i;
    return coordinates;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
   * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
   */

  function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
    coordinatess = coordinatess !== undefined ? coordinatess : [];
    var i = 0;

    for (var j = 0, jj = ends.length; j < jj; ++j) {
      var end = ends[j];
      coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
      offset = end;
    }

    coordinatess.length = i;
    return coordinatess;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
   *     Coordinatesss.
   * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
   */

  function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, coordinatesss) {
    coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
    var i = 0;

    for (var j = 0, jj = endss.length; j < jj; ++j) {
      var ends = endss[j];
      coordinatesss[i++] = ends.length === 1 && ends[0] === offset ? [] : inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
      offset = ends[ends.length - 1];
    }

    coordinatesss.length = i;
    return coordinatesss;
  }

  /**
   * @module ol/geom/flat/interpolate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} fraction Fraction.
   * @param {Array<number>} [dest] Destination.
   * @param {number} [dimension] Destination dimension (default is `2`)
   * @return {Array<number>} Destination.
   */

  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, dest, dimension) {
    var o, t;
    var n = (end - offset) / stride;

    if (n === 1) {
      o = offset;
    } else if (n === 2) {
      o = offset;
      t = fraction;
    } else if (n !== 0) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      var length = 0;
      var cumulativeLengths = [0];

      for (var i = offset + stride; i < end; i += stride) {
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        cumulativeLengths.push(length);
        x1 = x2;
        y1 = y2;
      }

      var target = fraction * length;
      var index = binarySearch$1(cumulativeLengths, target);

      if (index < 0) {
        t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
        o = offset + (-index - 2) * stride;
      } else {
        o = offset + index * stride;
      }
    }

    dimension = dimension > 1 ? dimension : 2;
    dest = dest ? dest : new Array(dimension);

    for (var _i = 0; _i < dimension; ++_i) {
      dest[_i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + _i] : lerp(flatCoordinates[o + _i], flatCoordinates[o + stride + _i], t);
    }

    return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
   */

  function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
    if (end == offset) {
      return null;
    }

    var coordinate;

    if (m < flatCoordinates[offset + stride - 1]) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(offset, offset + stride);
        coordinate[stride - 1] = m;
        return coordinate;
      } else {
        return null;
      }
    } else if (flatCoordinates[end - 1] < m) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(end - stride, end);
        coordinate[stride - 1] = m;
        return coordinate;
      } else {
        return null;
      }
    } // FIXME use O(1) search


    if (m == flatCoordinates[offset + stride - 1]) {
      return flatCoordinates.slice(offset, offset + stride);
    }

    var lo = offset / stride;
    var hi = end / stride;

    while (lo < hi) {
      var mid = lo + hi >> 1;

      if (m < flatCoordinates[(mid + 1) * stride - 1]) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }

    var m0 = flatCoordinates[lo * stride - 1];

    if (m == m0) {
      return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    }

    var m1 = flatCoordinates[(lo + 1) * stride - 1];
    var t = (m - m0) / (m1 - m0);
    coordinate = [];

    for (var i = 0; i < stride - 1; ++i) {
      coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
    }

    coordinate.push(m);
    return coordinate;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @param {boolean} interpolate Interpolate.
   * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
   */

  function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
    if (interpolate) {
      return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
    }

    var coordinate;

    if (m < flatCoordinates[stride - 1]) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(0, stride);
        coordinate[stride - 1] = m;
        return coordinate;
      } else {
        return null;
      }
    }

    if (flatCoordinates[flatCoordinates.length - 1] < m) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
        coordinate[stride - 1] = m;
        return coordinate;
      } else {
        return null;
      }
    }

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];

      if (offset == end) {
        continue;
      }

      if (m < flatCoordinates[offset + stride - 1]) {
        return null;
      } else if (m <= flatCoordinates[end - 1]) {
        return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
      }

      offset = end;
    }

    return null;
  }

  /**
   * @module ol/geom/flat/contains
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} Contains extent.
   */

  function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
    var outside = forEachCorner(extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
    });
    return !outside;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */

  function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
    // https://geomalgorithms.com/a03-_inclusion.html
    // Copyright 2000 softSurfer, 2012 Dan Sunday
    // This code may be freely used and modified for any purpose
    // providing that this copyright notice is included with it.
    // SoftSurfer makes no warranty for this code, and cannot be held
    // liable for any real or imagined damage resulting from its use.
    // Users of this code must verify correctness for their application.
    var wn = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];

    for (; offset < end; offset += stride) {
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];

      if (y1 <= y) {
        if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
          wn++;
        }
      } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
        wn--;
      }

      x1 = x2;
      y1 = y2;
    }

    return wn !== 0;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */

  function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
    if (ends.length === 0) {
      return false;
    }

    if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
      return false;
    }

    for (var i = 1, ii = ends.length; i < ii; ++i) {
      if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
        return false;
      }
    }

    return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */

  function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
    if (endss.length === 0) {
      return false;
    }

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];

      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        return true;
      }

      offset = ends[ends.length - 1];
    }

    return false;
  }

  /**
   * @module ol/geom/flat/intersectsextent
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */

  function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
    var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);

    if (!intersects$1(extent, coordinatesExtent)) {
      return false;
    }

    if (containsExtent(extent, coordinatesExtent)) {
      return true;
    }

    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
      return true;
    }

    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
      return true;
    }

    return forEach(flatCoordinates, offset, end, stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function (point1, point2) {
      return intersectsSegment(extent, point1, point2);
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */

  function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
        return true;
      }

      offset = ends[i];
    }

    return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */

  function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
      return true;
    }

    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
      return true;
    }

    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
      return true;
    }

    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
      return true;
    }

    if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
      return true;
    }

    return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */

  function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
      return false;
    }

    if (ends.length === 1) {
      return true;
    }

    for (var i = 1, ii = ends.length; i < ii; ++i) {
      if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
          return false;
        }
      }
    }

    return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */

  function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];

      if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
        return true;
      }

      offset = ends[ends.length - 1];
    }

    return false;
  }

  /**
   * @module ol/geom/flat/length
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Length.
   */
  function lineStringLength(flatCoordinates, offset, end, stride) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;

    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      x1 = x2;
      y1 = y2;
    }

    return length;
  }

  /**
   * @classdesc
   * Linestring geometry.
   *
   * @api
   */

  var LineString = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(LineString, _SimpleGeometry);

    var _super = _createSuper(LineString);

    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    function LineString(coordinates, layout) {
      var _this;

      _classCallCheck(this, LineString);

      _this = _super.call(this);
      /**
       * @private
       * @type {import("../coordinate.js").Coordinate}
       */

      _this.flatMidpoint_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.flatMidpointRevision_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDeltaRevision_ = -1;

      if (layout !== undefined && !Array.isArray(coordinates[0])) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);
      } else {
        _this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates, layout);
      }

      return _this;
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */


    _createClass(LineString, [{
      key: "appendCoordinate",
      value: function appendCoordinate(coordinate) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = coordinate.slice();
        } else {
          extend$1(this.flatCoordinates, coordinate);
        }

        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }

        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */

    }, {
      key: "forEachSegment",
      value: function forEachSegment(callback) {
        return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */

    }, {
      key: "getCoordinateAtM",
      value: function getCoordinateAtM(m, extrapolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM') {
          return null;
        }

        extrapolate = extrapolate !== undefined ? extrapolate : false;
        return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */

    }, {
      key: "getCoordinateAt",
      value: function getCoordinateAt(fraction, dest) {
        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, dest, this.stride);
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */

    }, {
      key: "getLength",
      value: function getLength() {
        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */

    }, {
      key: "getFlatMidpoint",
      value: function getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
          this.flatMidpointRevision_ = this.getRevision();
        }

        return this.flatMidpoint_;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, 'XY');
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'LineString';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      }
    }]);

    return LineString;
  }(SimpleGeometry);

  /**
   * @classdesc
   * Multi-linestring geometry.
   *
   * @api
   */

  var MultiLineString = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(MultiLineString, _SimpleGeometry);

    var _super = _createSuper(MultiLineString);

    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    function MultiLineString(coordinates, layout, ends) {
      var _this;

      _classCallCheck(this, MultiLineString);

      _this = _super.call(this);
      /**
       * @type {Array<number>}
       * @private
       */

      _this.ends_ = [];
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDeltaRevision_ = -1;

      if (Array.isArray(coordinates[0])) {
        _this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates, layout);
      } else if (layout !== undefined && ends) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);

        _this.ends_ = ends;
      } else {
        var _layout = _this.getLayout();

        var lineStrings =
        /** @type {Array<LineString>} */
        coordinates;
        var flatCoordinates = [];
        var _ends = [];

        for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
          var lineString = lineStrings[i];

          if (i === 0) {
            _layout = lineString.getLayout();
          }

          extend$1(flatCoordinates, lineString.getFlatCoordinates());

          _ends.push(flatCoordinates.length);
        }

        _this.setFlatCoordinates(_layout, flatCoordinates);

        _this.ends_ = _ends;
      }

      return _this;
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */


    _createClass(MultiLineString, [{
      key: "appendLineString",
      value: function appendLineString(lineString) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = lineString.getFlatCoordinates().slice();
        } else {
          extend$1(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        }

        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }

        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */

    }, {
      key: "getCoordinateAtM",
      value: function getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != 'XYM' && this.layout != 'XYZM' || this.flatCoordinates.length === 0) {
          return null;
        }

        extrapolate = extrapolate !== undefined ? extrapolate : false;
        interpolate = interpolate !== undefined ? interpolate : false;
        return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */

    }, {
      key: "getEnds",
      value: function getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */

    }, {
      key: "getLineString",
      value: function getLineString(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }

        return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */

    }, {
      key: "getLineStrings",
      value: function getLineStrings() {
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var layout = this.layout;
        /** @type {Array<LineString>} */

        var lineStrings = [];
        var offset = 0;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
          lineStrings.push(lineString);
          offset = end;
        }

        return lineStrings;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */

    }, {
      key: "getFlatMidpoints",
      value: function getFlatMidpoints() {
        var midpoints = [];
        var flatCoordinates = this.flatCoordinates;
        var offset = 0;
        var ends = this.ends_;
        var stride = this.stride;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
          extend$1(midpoints, midpoint);
          offset = end;
        }

        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'MultiLineString';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    }]);

    return MultiLineString;
  }(SimpleGeometry);

  /**
   * @classdesc
   * Point geometry.
   *
   * @api
   */

  var Point = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(Point, _SimpleGeometry);

    var _super = _createSuper(Point);

    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    function Point(coordinates, layout) {
      var _this;

      _classCallCheck(this, Point);

      _this = _super.call(this);

      _this.setCoordinates(coordinates, layout);

      return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     */


    _createClass(Point, [{
      key: "clone",
      value: function clone() {
        var point = new Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);

        if (squaredDistance$1 < minSquaredDistance) {
          var stride = this.stride;

          for (var i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }

          closestPoint.length = stride;
          return squaredDistance$1;
        } else {
          return minSquaredDistance;
        }
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */

    }, {
      key: "computeExtent",
      value: function computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'Point';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 0);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      }
    }]);

    return Point;
  }(SimpleGeometry);

  /**
   * @classdesc
   * Multi-point geometry.
   *
   * @api
   */

  var MultiPoint = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(MultiPoint, _SimpleGeometry);

    var _super = _createSuper(MultiPoint);

    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    function MultiPoint(coordinates, layout) {
      var _this;

      _classCallCheck(this, MultiPoint);

      _this = _super.call(this);

      if (layout && !Array.isArray(coordinates[0])) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);
      } else {
        _this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates, layout);
      }

      return _this;
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */


    _createClass(MultiPoint, [{
      key: "appendPoint",
      value: function appendPoint(point) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = point.getFlatCoordinates().slice();
        } else {
          extend$1(this.flatCoordinates, point.getFlatCoordinates());
        }

        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;

        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);

          if (squaredDistance$1 < minSquaredDistance) {
            minSquaredDistance = squaredDistance$1;

            for (var j = 0; j < stride; ++j) {
              closestPoint[j] = flatCoordinates[i + j];
            }

            closestPoint.length = stride;
          }
        }

        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */

    }, {
      key: "getPoint",
      value: function getPoint(index) {
        var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;

        if (index < 0 || n <= index) {
          return null;
        }

        return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */

    }, {
      key: "getPoints",
      value: function getPoints() {
        var flatCoordinates = this.flatCoordinates;
        var layout = this.layout;
        var stride = this.stride;
        /** @type {Array<Point>} */

        var points = [];

        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var point = new Point(flatCoordinates.slice(i, i + stride), layout);
          points.push(point);
        }

        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'MultiPoint';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;

        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];

          if (containsXY(extent, x, y)) {
            return true;
          }
        }

        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      }
    }]);

    return MultiPoint;
  }(SimpleGeometry);

  /**
   * @module ol/geom/flat/area
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRing(flatCoordinates, offset, end, stride) {
    var twiceArea = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];

    for (; offset < end; offset += stride) {
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      twiceArea += y1 * x2 - x1 * y2;
      x1 = x2;
      y1 = y2;
    }

    return twiceArea / 2;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @return {number} Area.
   */

  function linearRings(flatCoordinates, offset, ends, stride) {
    var area = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      area += linearRing(flatCoordinates, offset, end, stride);
      offset = end;
    }

    return area;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {number} Area.
   */

  function linearRingss$1(flatCoordinates, offset, endss, stride) {
    var area = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      area += linearRings(flatCoordinates, offset, ends, stride);
      offset = ends[ends.length - 1];
    }

    return area;
  }

  /**
   * @classdesc
   * Linear ring geometry. Only used as part of polygon; cannot be rendered
   * on its own.
   *
   * @api
   */

  var LinearRing = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(LinearRing, _SimpleGeometry);

    var _super = _createSuper(LinearRing);

    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    function LinearRing(coordinates, layout) {
      var _this;

      _classCallCheck(this, LinearRing);

      _this = _super.call(this);
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDeltaRevision_ = -1;

      if (layout !== undefined && !Array.isArray(coordinates[0])) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);
      } else {
        _this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates, layout);
      }

      return _this;
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     */


    _createClass(LinearRing, [{
      key: "clone",
      value: function clone() {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }

        return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */

    }, {
      key: "getArea",
      value: function getArea() {
        return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, 'XY');
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'LinearRing';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 1);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      }
    }]);

    return LinearRing;
  }(SimpleGeometry);

  /**
   * @module ol/geom/flat/interiorpoint
   */
  /**
   * Calculates a point that is likely to lie in the interior of the linear rings.
   * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @param {number} flatCentersOffset Flat center offset.
   * @param {Array<number>} [dest] Destination.
   * @return {Array<number>} Destination point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   */

  function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
    var i, ii, x, x1, x2, y1, y2;
    var y = flatCenters[flatCentersOffset + 1];
    /** @type {Array<number>} */

    var intersections = []; // Calculate intersections with the horizontal line

    for (var r = 0, rr = ends.length; r < rr; ++r) {
      var end = ends[r];
      x1 = flatCoordinates[end - stride];
      y1 = flatCoordinates[end - stride + 1];

      for (i = offset; i < end; i += stride) {
        x2 = flatCoordinates[i];
        y2 = flatCoordinates[i + 1];

        if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
          x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
          intersections.push(x);
        }

        x1 = x2;
        y1 = y2;
      }
    } // Find the longest segment of the horizontal line that has its center point
    // inside the linear ring.


    var pointX = NaN;
    var maxSegmentLength = -Infinity;
    intersections.sort(numberSafeCompareFunction);
    x1 = intersections[0];

    for (i = 1, ii = intersections.length; i < ii; ++i) {
      x2 = intersections[i];
      var segmentLength = Math.abs(x2 - x1);

      if (segmentLength > maxSegmentLength) {
        x = (x1 + x2) / 2;

        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
          pointX = x;
          maxSegmentLength = segmentLength;
        }
      }

      x1 = x2;
    }

    if (isNaN(pointX)) {
      // There is no horizontal line that has its center point inside the linear
      // ring.  Use the center of the the linear ring's extent.
      pointX = flatCenters[flatCentersOffset];
    }

    if (dest) {
      dest.push(pointX, y, maxSegmentLength);
      return dest;
    } else {
      return [pointX, y, maxSegmentLength];
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @return {Array<number>} Interior points as XYM coordinates, where M is the
   * length of the horizontal intersection that the point belongs to.
   */

  function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
    var interiorPoints = [];

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
      offset = ends[ends.length - 1];
    }

    return interiorPoints;
  }

  /**
   * @module ol/geom/flat/reverse
   */

  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  function coordinates(flatCoordinates, offset, end, stride) {
    while (offset < end - stride) {
      for (var i = 0; i < stride; ++i) {
        var tmp = flatCoordinates[offset + i];
        flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
        flatCoordinates[end - stride + i] = tmp;
      }

      offset += stride;
      end -= stride;
    }
  }

  /**
   * @module ol/geom/flat/orient
   */
  /**
   * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
   * coordinate origin? For a coordinate system with a top-left coordinate origin,
   * the ring's orientation is clockwise when this function returns false.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {boolean} Is clockwise.
   */

  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
    // https://stackoverflow.com/q/1165647/clockwise-method#1165943
    // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
    var edge = 0;
    var x1 = flatCoordinates[end - stride];
    var y1 = flatCoordinates[end - stride + 1];

    for (; offset < end; offset += stride) {
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      edge += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }

    return edge === 0 ? undefined : edge > 0;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean} [right] Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */

  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);

      if (i === 0) {
        if (right && isClockwise || !right && !isClockwise) {
          return false;
        }
      } else {
        if (right && !isClockwise || !right && isClockwise) {
          return false;
        }
      }

      offset = end;
    }

    return true;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean} [right] Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */

  function linearRingssAreOriented(flatCoordinates, offset, endss, stride, right) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];

      if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
        return false;
      }

      if (ends.length) {
        offset = ends[ends.length - 1];
      }
    }

    return true;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {boolean} [right] Follow the right-hand rule for orientation.
   * @return {number} End.
   */

  function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
    right = right !== undefined ? right : false;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
      var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

      if (reverse) {
        coordinates(flatCoordinates, offset, end, stride);
      }

      offset = end;
    }

    return offset;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean} [right] Follow the right-hand rule for orientation.
   * @return {number} End.
   */

  function orientLinearRingsArray(flatCoordinates, offset, endss, stride, right) {
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, right);
    }

    return offset;
  }

  /**
   * @classdesc
   * Polygon geometry.
   *
   * @api
   */

  var Polygon = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(Polygon, _SimpleGeometry);

    var _super = _createSuper(Polygon);

    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    function Polygon(coordinates, layout, ends) {
      var _this;

      _classCallCheck(this, Polygon);

      _this = _super.call(this);
      /**
       * @type {Array<number>}
       * @private
       */

      _this.ends_ = [];
      /**
       * @private
       * @type {number}
       */

      _this.flatInteriorPointRevision_ = -1;
      /**
       * @private
       * @type {import("../coordinate.js").Coordinate}
       */

      _this.flatInteriorPoint_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDeltaRevision_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.orientedRevision_ = -1;
      /**
       * @private
       * @type {Array<number>}
       */

      _this.orientedFlatCoordinates_ = null;

      if (layout !== undefined && ends) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);

        _this.ends_ = ends;
      } else {
        _this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates, layout);
      }

      return _this;
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */


    _createClass(Polygon, [{
      key: "appendLinearRing",
      value: function appendLinearRing(linearRing) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing.getFlatCoordinates().slice();
        } else {
          extend$1(this.flatCoordinates, linearRing.getFlatCoordinates());
        }

        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }

        return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */

    }, {
      key: "containsXY",
      value: function containsXY(x, y) {
        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */

    }, {
      key: "getArea",
      value: function getArea() {
        return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates(right) {
        var flatCoordinates;

        if (right !== undefined) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }

        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */

    }, {
      key: "getEnds",
      value: function getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */

    }, {
      key: "getFlatInteriorPoint",
      value: function getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          var flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
          this.flatInteriorPointRevision_ = this.getRevision();
        }

        return this.flatInteriorPoint_;
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */

    }, {
      key: "getInteriorPoint",
      value: function getInteriorPoint() {
        return new Point(this.getFlatInteriorPoint(), 'XYM');
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */

    }, {
      key: "getLinearRingCount",
      value: function getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */

    }, {
      key: "getLinearRing",
      value: function getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }

        return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */

    }, {
      key: "getLinearRings",
      value: function getLinearRings() {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var linearRings = [];
        var offset = 0;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);
          linearRings.push(linearRing);
          offset = end;
        }

        return linearRings;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */

    }, {
      key: "getOrientedFlatCoordinates",
      value: function getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          var flatCoordinates = this.flatCoordinates;

          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
          }

          this.orientedRevision_ = this.getRevision();
        }

        return this.orientedFlatCoordinates_;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'Polygon';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 2);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    }]);

    return Polygon;
  }(SimpleGeometry);
  /**
   * Create a polygon from an extent. The layout used is `XY`.
   * @param {import("../extent.js").Extent} extent The extent.
   * @return {Polygon} The polygon.
   * @api
   */

  function fromExtent(extent) {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
    return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
  }

  /**
   * @module ol/geom/flat/center
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {Array<number>} Flat centers.
   */

  function linearRingss(flatCoordinates, offset, endss, stride) {
    var flatCenters = [];
    var extent = createEmpty();

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
      flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
      offset = ends[ends.length - 1];
    }

    return flatCenters;
  }

  /**
   * @classdesc
   * Multi-polygon geometry.
   *
   * @api
   */

  var MultiPolygon = /*#__PURE__*/function (_SimpleGeometry) {
    _inherits(MultiPolygon, _SimpleGeometry);

    var _super = _createSuper(MultiPolygon);

    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    function MultiPolygon(coordinates, layout, endss) {
      var _this;

      _classCallCheck(this, MultiPolygon);

      _this = _super.call(this);
      /**
       * @type {Array<Array<number>>}
       * @private
       */

      _this.endss_ = [];
      /**
       * @private
       * @type {number}
       */

      _this.flatInteriorPointsRevision_ = -1;
      /**
       * @private
       * @type {Array<number>}
       */

      _this.flatInteriorPoints_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.maxDeltaRevision_ = -1;
      /**
       * @private
       * @type {number}
       */

      _this.orientedRevision_ = -1;
      /**
       * @private
       * @type {Array<number>}
       */

      _this.orientedFlatCoordinates_ = null;

      if (!endss && !Array.isArray(coordinates[0])) {
        var thisLayout = _this.getLayout();

        var polygons =
        /** @type {Array<Polygon>} */
        coordinates;
        var flatCoordinates = [];
        var thisEndss = [];

        for (var i = 0, ii = polygons.length; i < ii; ++i) {
          var polygon = polygons[i];

          if (i === 0) {
            thisLayout = polygon.getLayout();
          }

          var offset = flatCoordinates.length;
          var ends = polygon.getEnds();

          for (var j = 0, jj = ends.length; j < jj; ++j) {
            ends[j] += offset;
          }

          extend$1(flatCoordinates, polygon.getFlatCoordinates());
          thisEndss.push(ends);
        }

        layout = thisLayout;
        coordinates = flatCoordinates;
        endss = thisEndss;
      }

      if (layout !== undefined && endss) {
        _this.setFlatCoordinates(layout,
        /** @type {Array<number>} */
        coordinates);

        _this.endss_ = endss;
      } else {
        _this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
        coordinates, layout);
      }

      return _this;
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */


    _createClass(MultiPolygon, [{
      key: "appendPolygon",
      value: function appendPolygon(polygon) {
        /** @type {Array<number>} */
        var ends;

        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          var offset = this.flatCoordinates.length;
          extend$1(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();

          for (var i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] += offset;
          }
        }

        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */

    }, {
      key: "clone",
      value: function clone() {
        var len = this.endss_.length;
        var newEndss = new Array(len);

        for (var i = 0; i < len; ++i) {
          newEndss[i] = this.endss_[i].slice();
        }

        var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */

    }, {
      key: "closestPointXY",
      value: function closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }

        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }

        return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */

    }, {
      key: "containsXY",
      value: function containsXY(x, y) {
        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */

    }, {
      key: "getArea",
      value: function getArea() {
        return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */

    }, {
      key: "getCoordinates",
      value: function getCoordinates(right) {
        var flatCoordinates;

        if (right !== undefined) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }

        return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */

    }, {
      key: "getEndss",
      value: function getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */

    }, {
      key: "getFlatInteriorPoints",
      value: function getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          var flatCenters = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
          this.flatInteriorPointsRevision_ = this.getRevision();
        }

        return this.flatInteriorPoints_;
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */

    }, {
      key: "getInteriorPoints",
      value: function getInteriorPoints() {
        return new MultiPoint(this.getFlatInteriorPoints().slice(), 'XYM');
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */

    }, {
      key: "getOrientedFlatCoordinates",
      value: function getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          var flatCoordinates = this.flatCoordinates;

          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
          }

          this.orientedRevision_ = this.getRevision();
        }

        return this.orientedFlatCoordinates_;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */

    }, {
      key: "getSimplifiedGeometryInternal",
      value: function getSimplifiedGeometryInternal(squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */

    }, {
      key: "getPolygon",
      value: function getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) {
          return null;
        }

        var offset;

        if (index === 0) {
          offset = 0;
        } else {
          var prevEnds = this.endss_[index - 1];
          offset = prevEnds[prevEnds.length - 1];
        }

        var ends = this.endss_[index].slice();
        var end = ends[ends.length - 1];

        if (offset !== 0) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] -= offset;
          }
        }

        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */

    }, {
      key: "getPolygons",
      value: function getPolygons() {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var endss = this.endss_;
        var polygons = [];
        var offset = 0;

        for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i].slice();
          var end = ends[ends.length - 1];

          if (offset !== 0) {
            for (var j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] -= offset;
            }
          }

          var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);
          polygons.push(polygon);
          offset = end;
        }

        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */

    }, {
      key: "getType",
      value: function getType() {
        return 'MultiPolygon';
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */

    }, {
      key: "intersectsExtent",
      value: function intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */

    }, {
      key: "setCoordinates",
      value: function setCoordinates(coordinates, layout) {
        this.setLayout(layout, coordinates, 3);

        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }

        var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);

        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          var lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }

        this.changed();
      }
    }]);

    return MultiPolygon;
  }(SimpleGeometry);

  /**
   * @typedef {import("geojson").GeoJSON} GeoJSONObject
   * @typedef {import("geojson").Feature} GeoJSONFeature
   * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
   * @typedef {import("geojson").Geometry} GeoJSONGeometry
   * @typedef {import("geojson").Point} GeoJSONPoint
   * @typedef {import("geojson").LineString} GeoJSONLineString
   * @typedef {import("geojson").Polygon} GeoJSONPolygon
   * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
   * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
   * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
   * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
   */

  /**
   * @typedef {Object} Options
   * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
   * written by the format.  Options passed to read or write methods will take precedence.
   * @property {string} [geometryName] Geometry name to use when creating features.
   * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
   * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
   * will look for that field to set the geometry name. If both this field is set to `true`
   * and a `geometryName` is provided, the `geometryName` will take precedence.
   */

  /**
   * @classdesc
   * Feature format for reading and writing data in the GeoJSON format.
   *
   * @api
   */

  var GeoJSON = /*#__PURE__*/function (_JSONFeature) {
    _inherits(GeoJSON, _JSONFeature);

    var _super = _createSuper(GeoJSON);

    /**
     * @param {Options} [options] Options.
     */
    function GeoJSON(options) {
      var _this;

      _classCallCheck(this, GeoJSON);

      options = options ? options : {};
      _this = _super.call(this);
      /**
       * @type {import("../proj/Projection.js").default}
       */

      _this.dataProjection = get$1(options.dataProjection ? options.dataProjection : 'EPSG:4326');

      if (options.featureProjection) {
        /**
         * @type {import("../proj/Projection.js").default}
         */
        _this.defaultFeatureProjection = get$1(options.featureProjection);
      }
      /**
       * Name of the geometry attribute for features.
       * @type {string|undefined}
       * @private
       */


      _this.geometryName_ = options.geometryName;
      /**
       * Look for the geometry name in the feature GeoJSON
       * @type {boolean|undefined}
       * @private
       */

      _this.extractGeometryName_ = options.extractGeometryName;
      _this.supportedMediaTypes = ['application/geo+json', 'application/vnd.geo+json'];
      return _this;
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */


    _createClass(GeoJSON, [{
      key: "readFeatureFromObject",
      value: function readFeatureFromObject(object, options) {
        /**
         * @type {GeoJSONFeature}
         */
        var geoJSONFeature = null;

        if (object['type'] === 'Feature') {
          geoJSONFeature =
          /** @type {GeoJSONFeature} */
          object;
        } else {
          geoJSONFeature = {
            'type': 'Feature',
            'geometry':
            /** @type {GeoJSONGeometry} */
            object,
            'properties': null
          };
        }

        var geometry = readGeometry(geoJSONFeature['geometry'], options);
        var feature = new Feature();

        if (this.geometryName_) {
          feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
          feature.setGeometryName(geoJSONFeature['geometry_name']);
        }

        feature.setGeometry(geometry);

        if ('id' in geoJSONFeature) {
          feature.setId(geoJSONFeature['id']);
        }

        if (geoJSONFeature['properties']) {
          feature.setProperties(geoJSONFeature['properties'], true);
        }

        return feature;
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {Array<Feature>} Features.
       */

    }, {
      key: "readFeaturesFromObject",
      value: function readFeaturesFromObject(object, options) {
        var geoJSONObject =
        /** @type {GeoJSONObject} */
        object;
        /** @type {Array<import("../Feature.js").default>} */

        var features = null;

        if (geoJSONObject['type'] === 'FeatureCollection') {
          var geoJSONFeatureCollection =
          /** @type {GeoJSONFeatureCollection} */
          object;
          features = [];
          var geoJSONFeatures = geoJSONFeatureCollection['features'];

          for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
            features.push(this.readFeatureFromObject(geoJSONFeatures[i], options));
          }
        } else {
          features = [this.readFeatureFromObject(object, options)];
        }

        return features;
      }
      /**
       * @param {GeoJSONGeometry} object Object.
       * @param {import("./Feature.js").ReadOptions} [options] Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */

    }, {
      key: "readGeometryFromObject",
      value: function readGeometryFromObject(object, options) {
        return readGeometry(object, options);
      }
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */

    }, {
      key: "readProjectionFromObject",
      value: function readProjectionFromObject(object) {
        var crs = object['crs'];
        var projection;

        if (crs) {
          if (crs['type'] == 'name') {
            projection = get$1(crs['properties']['name']);
          } else if (crs['type'] === 'EPSG') {
            projection = get$1('EPSG:' + crs['properties']['code']);
          } else {
            assert(false, 36); // Unknown SRS type
          }
        } else {
          projection = this.dataProjection;
        }

        return (
          /** @type {import("../proj/Projection.js").default} */
          projection
        );
      }
      /**
       * Encode a feature as a GeoJSON Feature object.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeature} Object.
       * @api
       */

    }, {
      key: "writeFeatureObject",
      value: function writeFeatureObject(feature, options) {
        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */

        var object = {
          'type': 'Feature',
          geometry: null,
          properties: null
        };
        var id = feature.getId();

        if (id !== undefined) {
          object.id = id;
        }

        if (!feature.hasProperties()) {
          return object;
        }

        var properties = feature.getProperties();
        var geometry = feature.getGeometry();

        if (geometry) {
          object.geometry = writeGeometry(geometry, options);
          delete properties[feature.getGeometryName()];
        }

        if (!isEmpty$1(properties)) {
          object.properties = properties;
        }

        return object;
      }
      /**
       * Encode an array of features as a GeoJSON object.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONFeatureCollection} GeoJSON Object.
       * @api
       */

    }, {
      key: "writeFeaturesObject",
      value: function writeFeaturesObject(features, options) {
        options = this.adaptOptions(options);
        var objects = [];

        for (var i = 0, ii = features.length; i < ii; ++i) {
          objects.push(this.writeFeatureObject(features[i], options));
        }

        return {
          type: 'FeatureCollection',
          features: objects
        };
      }
      /**
       * Encode a geometry as a GeoJSON object.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions} [options] Write options.
       * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
       * @api
       */

    }, {
      key: "writeGeometryObject",
      value: function writeGeometryObject(geometry, options) {
        return writeGeometry(geometry, this.adaptOptions(options));
      }
    }]);

    return GeoJSON;
  }(JSONFeature);
  /**
   * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  function readGeometry(object, options) {
    if (!object) {
      return null;
    }
    /**
     * @type {import("../geom/Geometry.js").default}
     */


    var geometry;

    switch (object['type']) {
      case 'Point':
        {
          geometry = readPointGeometry(
          /** @type {GeoJSONPoint} */
          object);
          break;
        }

      case 'LineString':
        {
          geometry = readLineStringGeometry(
          /** @type {GeoJSONLineString} */
          object);
          break;
        }

      case 'Polygon':
        {
          geometry = readPolygonGeometry(
          /** @type {GeoJSONPolygon} */
          object);
          break;
        }

      case 'MultiPoint':
        {
          geometry = readMultiPointGeometry(
          /** @type {GeoJSONMultiPoint} */
          object);
          break;
        }

      case 'MultiLineString':
        {
          geometry = readMultiLineStringGeometry(
          /** @type {GeoJSONMultiLineString} */
          object);
          break;
        }

      case 'MultiPolygon':
        {
          geometry = readMultiPolygonGeometry(
          /** @type {GeoJSONMultiPolygon} */
          object);
          break;
        }

      case 'GeometryCollection':
        {
          geometry = readGeometryCollectionGeometry(
          /** @type {GeoJSONGeometryCollection} */
          object);
          break;
        }

      default:
        {
          throw new Error('Unsupported GeoJSON type: ' + object['type']);
        }
    }

    return transformGeometryWithOptions(geometry, false, options);
  }
  /**
   * @param {GeoJSONGeometryCollection} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {GeometryCollection} Geometry collection.
   */


  function readGeometryCollectionGeometry(object, options) {
    var geometries = object['geometries'].map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("../geom/Geometry.js").default} geometry Geometry.
     */
    function (geometry) {
      return readGeometry(geometry, options);
    });
    return new GeometryCollection(geometries);
  }
  /**
   * @param {GeoJSONPoint} object Object.
   * @return {Point} Point.
   */


  function readPointGeometry(object) {
    return new Point(object['coordinates']);
  }
  /**
   * @param {GeoJSONLineString} object Object.
   * @return {LineString} LineString.
   */


  function readLineStringGeometry(object) {
    return new LineString(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiLineString} object Object.
   * @return {MultiLineString} MultiLineString.
   */


  function readMultiLineStringGeometry(object) {
    return new MultiLineString(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiPoint} object Object.
   * @return {MultiPoint} MultiPoint.
   */


  function readMultiPointGeometry(object) {
    return new MultiPoint(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiPolygon} object Object.
   * @return {MultiPolygon} MultiPolygon.
   */


  function readMultiPolygonGeometry(object) {
    return new MultiPolygon(object['coordinates']);
  }
  /**
   * @param {GeoJSONPolygon} object Object.
   * @return {Polygon} Polygon.
   */


  function readPolygonGeometry(object) {
    return new Polygon(object['coordinates']);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writeGeometry(geometry, options) {
    geometry = transformGeometryWithOptions(geometry, true, options);
    var type = geometry.getType();
    /** @type {GeoJSONGeometry} */

    var geoJSON;

    switch (type) {
      case 'Point':
        {
          geoJSON = writePointGeometry(
          /** @type {Point} */
          geometry);
          break;
        }

      case 'LineString':
        {
          geoJSON = writeLineStringGeometry(
          /** @type {LineString} */
          geometry);
          break;
        }

      case 'Polygon':
        {
          geoJSON = writePolygonGeometry(
          /** @type {Polygon} */
          geometry, options);
          break;
        }

      case 'MultiPoint':
        {
          geoJSON = writeMultiPointGeometry(
          /** @type {MultiPoint} */
          geometry);
          break;
        }

      case 'MultiLineString':
        {
          geoJSON = writeMultiLineStringGeometry(
          /** @type {MultiLineString} */
          geometry);
          break;
        }

      case 'MultiPolygon':
        {
          geoJSON = writeMultiPolygonGeometry(
          /** @type {MultiPolygon} */
          geometry, options);
          break;
        }

      case 'GeometryCollection':
        {
          geoJSON = writeGeometryCollectionGeometry(
          /** @type {GeometryCollection} */
          geometry, options);
          break;
        }

      case 'Circle':
        {
          geoJSON = {
            type: 'GeometryCollection',
            geometries: []
          };
          break;
        }

      default:
        {
          throw new Error('Unsupported geometry type: ' + type);
        }
    }

    return geoJSON;
  }
  /**
   * @param {GeometryCollection} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
   */


  function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    var geometries = geometry.getGeometriesArray().map(function (geometry) {
      return writeGeometry(geometry, options);
    });
    return {
      type: 'GeometryCollection',
      geometries: geometries
    };
  }
  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writeLineStringGeometry(geometry, options) {
    return {
      type: 'LineString',
      coordinates: geometry.getCoordinates()
    };
  }
  /**
   * @param {MultiLineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writeMultiLineStringGeometry(geometry, options) {
    return {
      type: 'MultiLineString',
      coordinates: geometry.getCoordinates()
    };
  }
  /**
   * @param {MultiPoint} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writeMultiPointGeometry(geometry, options) {
    return {
      type: 'MultiPoint',
      coordinates: geometry.getCoordinates()
    };
  }
  /**
   * @param {MultiPolygon} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writeMultiPolygonGeometry(geometry, options) {
    var right;

    if (options) {
      right = options.rightHanded;
    }

    return {
      type: 'MultiPolygon',
      coordinates: geometry.getCoordinates(right)
    };
  }
  /**
   * @param {Point} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writePointGeometry(geometry, options) {
    return {
      type: 'Point',
      coordinates: geometry.getCoordinates()
    };
  }
  /**
   * @param {Polygon} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */


  function writePolygonGeometry(geometry, options) {
    var right;

    if (options) {
      right = options.rightHanded;
    }

    return {
      type: 'Polygon',
      coordinates: geometry.getCoordinates(right)
    };
  }

  /**
   * @module ol/CollectionEventType
   */

  /**
   * @enum {string}
   */
  var CollectionEventType = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: 'add',

    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: 'remove'
  };

  /**
   * @enum {string}
   * @private
   */

  var Property$1 = {
    LENGTH: 'length'
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
   * type.
   * @template T
   */

  var CollectionEvent = /*#__PURE__*/function (_Event) {
    _inherits(CollectionEvent, _Event);

    var _super = _createSuper(CollectionEvent);

    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    function CollectionEvent(type, element, index) {
      var _this;

      _classCallCheck(this, CollectionEvent);

      _this = _super.call(this, type);
      /**
       * The element that is added to or removed from the collection.
       * @type {T}
       * @api
       */

      _this.element = element;
      /**
       * The index of the added or removed element.
       * @type {number}
       * @api
       */

      _this.index = index;
      return _this;
    }

    return _createClass(CollectionEvent);
  }(BaseEvent);
  /***
   * @template T
   * @template Return
   * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
   *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:length', import("./Object").ObjectEvent, Return> &
   *   import("./Observable").OnSignature<'add'|'remove', CollectionEvent<T>, Return> &
   *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types|
   *     'change:length'|'add'|'remove',Return>} CollectionOnSignature
   */

  /**
   * @typedef {Object} Options
   * @property {boolean} [unique=false] Disallow the same item from being added to
   * the collection twice.
   */

  /**
   * @classdesc
   * An expanded version of standard JS Array, adding convenience methods for
   * manipulation. Add and remove changes to the Collection trigger a Collection
   * event. Note that this does not cover changes to the objects _within_ the
   * Collection; they trigger events on the appropriate object, not on the
   * Collection as a whole.
   *
   * @fires CollectionEvent
   *
   * @template T
   * @api
   */

  var Collection = /*#__PURE__*/function (_BaseObject) {
    _inherits(Collection, _BaseObject);

    var _super2 = _createSuper(Collection);

    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    function Collection(array, options) {
      var _this2;

      _classCallCheck(this, Collection);

      _this2 = _super2.call(this);
      /***
       * @type {CollectionOnSignature<T, import("./events").EventsKey>}
       */

      _this2.on;
      /***
       * @type {CollectionOnSignature<T, import("./events").EventsKey>}
       */

      _this2.once;
      /***
       * @type {CollectionOnSignature<T, void>}
       */

      _this2.un;
      options = options || {};
      /**
       * @private
       * @type {boolean}
       */

      _this2.unique_ = !!options.unique;
      /**
       * @private
       * @type {!Array<T>}
       */

      _this2.array_ = array ? array : [];

      if (_this2.unique_) {
        for (var i = 0, ii = _this2.array_.length; i < ii; ++i) {
          _this2.assertUnique_(_this2.array_[i], i);
        }
      }

      _this2.updateLength_();

      return _this2;
    }
    /**
     * Remove all elements from the collection.
     * @api
     */


    _createClass(Collection, [{
      key: "clear",
      value: function clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */

    }, {
      key: "extend",
      value: function extend(arr) {
        for (var i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }

        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */

    }, {
      key: "forEach",
      value: function forEach(f) {
        var array = this.array_;

        for (var i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */

    }, {
      key: "getArray",
      value: function getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */

    }, {
      key: "item",
      value: function item(index) {
        return this.array_[index];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */

    }, {
      key: "getLength",
      value: function getLength() {
        return this.get(Property$1.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */

    }, {
      key: "insertAt",
      value: function insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error('Index out of bounds: ' + index);
        }

        if (this.unique_) {
          this.assertUnique_(elem);
        }

        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */

    }, {
      key: "pop",
      value: function pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */

    }, {
      key: "push",
      value: function push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }

        var n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */

    }, {
      key: "remove",
      value: function remove(elem) {
        var arr = this.array_;

        for (var i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }

        return undefined;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */

    }, {
      key: "removeAt",
      value: function removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return undefined;
        }

        var prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType.REMOVE, prev, index));
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */

    }, {
      key: "setAt",
      value: function setAt(index, elem) {
        var n = this.getLength();

        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }

        if (index < 0) {
          throw new Error('Index out of bounds: ' + index);
        }

        if (this.unique_) {
          this.assertUnique_(elem, index);
        }

        var prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType.REMOVE, prev, index));
        this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType.ADD, elem, index));
      }
      /**
       * @private
       */

    }, {
      key: "updateLength_",
      value: function updateLength_() {
        this.set(Property$1.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */

    }, {
      key: "assertUnique_",
      value: function assertUnique_(elem, except) {
        for (var i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new AssertionError(58);
          }
        }
      }
    }]);

    return Collection;
  }(BaseObject);

  /**
   * @module ol/color
   */
  /**
   * A color represented as a short array [red, green, blue, alpha].
   * red, green, and blue should be integers in the range 0..255 inclusive.
   * alpha should be a float in the range 0..1 inclusive. If no alpha value is
   * given then `1` will be used.
   * @typedef {Array<number>} Color
   * @api
   */

  /**
   * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
   * @const
   * @type {RegExp}
   * @private
   */

  var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
  /**
   * Regular expression for matching potential named color style strings.
   * @const
   * @type {RegExp}
   * @private
   */

  var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
  /**
   * Return the color as an rgba string.
   * @param {Color|string} color Color.
   * @return {string} Rgba string.
   * @api
   */

  function asString(color) {
    if (typeof color === 'string') {
      return color;
    } else {
      return toString$2(color);
    }
  }
  /**
   * Return named color as an rgba string.
   * @param {string} color Named color.
   * @return {string} Rgb string.
   */

  function fromNamed(color) {
    var el = document.createElement('div');
    el.style.color = color;

    if (el.style.color !== '') {
      document.body.appendChild(el);
      var rgb = getComputedStyle(el).color;
      document.body.removeChild(el);
      return rgb;
    } else {
      return '';
    }
  }
  /**
   * @param {string} s String.
   * @return {Color} Color.
   */


  var fromString = function () {
    // We maintain a small cache of parsed strings.  To provide cheap LRU-like
    // semantics, whenever the cache grows too large we simply delete an
    // arbitrary 25% of the entries.

    /**
     * @const
     * @type {number}
     */
    var MAX_CACHE_SIZE = 1024;
    /**
     * @type {Object<string, Color>}
     */

    var cache = {};
    /**
     * @type {number}
     */

    var cacheSize = 0;
    return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function (s) {
        var color;

        if (cache.hasOwnProperty(s)) {
          color = cache[s];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            var i = 0;

            for (var key in cache) {
              if ((i++ & 3) === 0) {
                delete cache[key];
                --cacheSize;
              }
            }
          }

          color = fromStringInternal_(s);
          cache[s] = color;
          ++cacheSize;
        }

        return color;
      }
    );
  }();
  /**
   * Return the color as an array. This function maintains a cache of calculated
   * arrays which means the result should not be modified.
   * @param {Color|string} color Color.
   * @return {Color} Color.
   * @api
   */

  function asArray(color) {
    if (Array.isArray(color)) {
      return color;
    } else {
      return fromString(color);
    }
  }
  /**
   * @param {string} s String.
   * @private
   * @return {Color} Color.
   */

  function fromStringInternal_(s) {
    var r, g, b, a, color;

    if (NAMED_COLOR_RE_.exec(s)) {
      s = fromNamed(s);
    }

    if (HEX_COLOR_RE_.exec(s)) {
      // hex
      var n = s.length - 1; // number of hex digits

      var d; // number of digits per channel

      if (n <= 4) {
        d = 1;
      } else {
        d = 2;
      }

      var hasAlpha = n === 4 || n === 8;
      r = parseInt(s.substr(1 + 0 * d, d), 16);
      g = parseInt(s.substr(1 + 1 * d, d), 16);
      b = parseInt(s.substr(1 + 2 * d, d), 16);

      if (hasAlpha) {
        a = parseInt(s.substr(1 + 3 * d, d), 16);
      } else {
        a = 255;
      }

      if (d == 1) {
        r = (r << 4) + r;
        g = (g << 4) + g;
        b = (b << 4) + b;

        if (hasAlpha) {
          a = (a << 4) + a;
        }
      }

      color = [r, g, b, a / 255];
    } else if (s.startsWith('rgba(')) {
      // rgba()
      color = s.slice(5, -1).split(',').map(Number);
      normalize(color);
    } else if (s.startsWith('rgb(')) {
      // rgb()
      color = s.slice(4, -1).split(',').map(Number);
      color.push(1);
      normalize(color);
    } else {
      assert(false, 14); // Invalid color
    }

    return color;
  }
  /**
   * TODO this function is only used in the test, we probably shouldn't export it
   * @param {Color} color Color.
   * @return {Color} Clamped color.
   */


  function normalize(color) {
    color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
    color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
    color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
    color[3] = clamp(color[3], 0, 1);
    return color;
  }
  /**
   * @param {Color} color Color.
   * @return {string} String.
   */

  function toString$2(color) {
    var r = color[0];

    if (r != (r | 0)) {
      r = r + 0.5 | 0;
    }

    var g = color[1];

    if (g != (g | 0)) {
      g = g + 0.5 | 0;
    }

    var b = color[2];

    if (b != (b | 0)) {
      b = b + 0.5 | 0;
    }

    var a = color[3] === undefined ? 1 : Math.round(color[3] * 100) / 100;
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  }
  /**
   * @param {string} s String.
   * @return {boolean} Whether the string is actually a valid color
   */

  function isStringColor(s) {
    if (NAMED_COLOR_RE_.test(s)) {
      s = fromNamed(s);
    }

    return HEX_COLOR_RE_.test(s) || s.startsWith('rgba(') || s.startsWith('rgb(');
  }

  /**
   * @classdesc
   * Singleton class. Available through {@link module:ol/style/IconImageCache.shared}.
   */

  var IconImageCache = /*#__PURE__*/function () {
    function IconImageCache() {
      _classCallCheck(this, IconImageCache);

      /**
       * @type {!Object<string, import("./IconImage.js").default>}
       * @private
       */
      this.cache_ = {};
      /**
       * @type {number}
       * @private
       */

      this.cacheSize_ = 0;
      /**
       * @type {number}
       * @private
       */

      this.maxCacheSize_ = 32;
    }
    /**
     * FIXME empty description for jsdoc
     */


    _createClass(IconImageCache, [{
      key: "clear",
      value: function clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */

    }, {
      key: "canExpireCache",
      value: function canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */

    }, {
      key: "expire",
      value: function expire() {
        if (this.canExpireCache()) {
          var i = 0;

          for (var key in this.cache_) {
            var iconImage = this.cache_[key];

            if ((i++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */

    }, {
      key: "get",
      value: function get(src, crossOrigin, color) {
        var key = getKey$1(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */

    }, {
      key: "set",
      value: function set(src, crossOrigin, color, iconImage) {
        var key = getKey$1(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
      }
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */

    }, {
      key: "setSize",
      value: function setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    }]);

    return IconImageCache;
  }();
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {string} Cache key.
   */


  function getKey$1(src, crossOrigin, color) {
    var colorString = color ? asString(color) : 'null';
    return crossOrigin + ':' + src + ':' + colorString;
  }
  /**
   * The {@link module:ol/style/IconImageCache~IconImageCache} for
   * {@link module:ol/style/Icon~Icon} images.
   * @api
   */

  var shared = new IconImageCache();

  /**
   * @module ol/layer/Property
   */

  /**
   * @enum {string}
   */
  var LayerProperty = {
    OPACITY: 'opacity',
    VISIBLE: 'visible',
    EXTENT: 'extent',
    Z_INDEX: 'zIndex',
    MAX_RESOLUTION: 'maxResolution',
    MIN_RESOLUTION: 'minResolution',
    MAX_ZOOM: 'maxZoom',
    MIN_ZOOM: 'minZoom',
    SOURCE: 'source',
    MAP: 'map'
  };

  /**
   * A css color, or a function called with a view resolution returning a css color.
   *
   * @typedef {string|function(number):string} BackgroundColor
   * @api
   */

  /**
   * @typedef {import("../ObjectEventType").Types|'change:extent'|'change:maxResolution'|'change:maxZoom'|
   *    'change:minResolution'|'change:minZoom'|'change:opacity'|'change:visible'|'change:zIndex'} BaseLayerObjectEventTypes
   */

  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<BaseLayerObjectEventTypes, import("../Object").ObjectEvent, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|BaseLayerObjectEventTypes, Return>} BaseLayerOnSignature
   */

  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {BackgroundColor} [background] Background color for the layer. If not specified, no background
   * will be rendered.
   * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Note that with {@link module:ol/layer/Base~BaseLayer} and all its subclasses, any property set in
   * the options is set as a {@link module:ol/Object~BaseObject} property on the layer object, so
   * is observable, and has get/set accessors.
   *
   * @api
   */

  var BaseLayer = /*#__PURE__*/function (_BaseObject) {
    _inherits(BaseLayer, _BaseObject);

    var _super = _createSuper(BaseLayer);

    /**
     * @param {Options} options Layer options.
     */
    function BaseLayer(options) {
      var _this;

      _classCallCheck(this, BaseLayer);

      _this = _super.call(this);
      /***
       * @type {BaseLayerOnSignature<import("../events").EventsKey>}
       */

      _this.on;
      /***
       * @type {BaseLayerOnSignature<import("../events").EventsKey>}
       */

      _this.once;
      /***
       * @type {BaseLayerOnSignature<void>}
       */

      _this.un;
      /**
       * @type {BackgroundColor|false}
       * @private
       */

      _this.background_ = options.background;
      /**
       * @type {Object<string, *>}
       */

      var properties = Object.assign({}, options);

      if (_typeof(options.properties) === 'object') {
        delete properties.properties;
        Object.assign(properties, options.properties);
      }

      properties[LayerProperty.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
      assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number

      properties[LayerProperty.VISIBLE] = options.visible !== undefined ? options.visible : true;
      properties[LayerProperty.Z_INDEX] = options.zIndex;
      properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
      properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
      properties[LayerProperty.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
      properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
      /**
       * @type {string}
       * @private
       */

      _this.className_ = properties.className !== undefined ? properties.className : 'ol-layer';
      delete properties.className;

      _this.setProperties(properties);
      /**
       * @type {import("./Layer.js").State}
       * @private
       */


      _this.state_ = null;
      return _this;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */


    _createClass(BaseLayer, [{
      key: "getBackground",
      value: function getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */

    }, {
      key: "getClassName",
      value: function getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */

    }, {
      key: "getLayerState",
      value: function getLayerState(managed) {
        /** @type {import("./Layer.js").State} */
        var state = this.state_ ||
        /** @type {?} */
        {
          layer: this,
          managed: managed === undefined ? true : managed
        };
        var zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === undefined && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */

    }, {
      key: "getLayersArray",
      value: function getLayersArray(array) {
        return _abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */

    }, {
      key: "getLayerStatesArray",
      value: function getLayerStatesArray(states) {
        return _abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */

    }, {
      key: "getExtent",
      value: function getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(LayerProperty.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getMaxResolution",
      value: function getMaxResolution() {
        return (
          /** @type {number} */
          this.get(LayerProperty.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getMinResolution",
      value: function getMinResolution() {
        return (
          /** @type {number} */
          this.get(LayerProperty.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getMinZoom",
      value: function getMinZoom() {
        return (
          /** @type {number} */
          this.get(LayerProperty.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getMaxZoom",
      value: function getMaxZoom() {
        return (
          /** @type {number} */
          this.get(LayerProperty.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getOpacity",
      value: function getOpacity() {
        return (
          /** @type {number} */
          this.get(LayerProperty.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */

    }, {
      key: "getSourceState",
      value: function getSourceState() {
        return _abstract();
      }
      /**
       * Return the visibility of the layer (`true` or `false`).
       * @return {boolean} The visibility of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getVisible",
      value: function getVisible() {
        return (
          /** @type {boolean} */
          this.get(LayerProperty.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. The default Z-index is 0.
       * @return {number} The Z-index of the layer.
       * @observable
       * @api
       */

    }, {
      key: "getZIndex",
      value: function getZIndex() {
        return (
          /** @type {number} */
          this.get(LayerProperty.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */

    }, {
      key: "setBackground",
      value: function setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setExtent",
      value: function setExtent(extent) {
        this.set(LayerProperty.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setMaxResolution",
      value: function setMaxResolution(maxResolution) {
        this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setMinResolution",
      value: function setMinResolution(minResolution) {
        this.set(LayerProperty.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setMaxZoom",
      value: function setMaxZoom(maxZoom) {
        this.set(LayerProperty.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setMinZoom",
      value: function setMinZoom(minZoom) {
        this.set(LayerProperty.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setOpacity",
      value: function setOpacity(opacity) {
        assert(typeof opacity === 'number', 64); // Layer opacity must be a number

        this.set(LayerProperty.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        this.set(LayerProperty.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */

    }, {
      key: "setZIndex",
      value: function setZIndex(zindex) {
        this.set(LayerProperty.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }

        _get(_getPrototypeOf(BaseLayer.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return BaseLayer;
  }(BaseObject);

  /**
   * @module ol/render/EventType
   */

  /**
   * @enum {string}
   */
  var RenderEventType = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: 'prerender',

    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: 'postrender',

    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: 'precompose',

    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: 'postcompose',

    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: 'rendercomplete'
  };
  /**
   * @typedef {'postrender'|'precompose'|'postcompose'|'rendercomplete'} MapRenderEventTypes
   */

  /**
   * @typedef {'postrender'|'prerender'} LayerRenderEventTypes
   */

  /**
   * @typedef {function(import("../Map.js").FrameState):HTMLElement} RenderFunction
   */

  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
   *     'change:source', import("../Object").ObjectEvent, Return> &
   *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:source'|
   *     import("../render/EventType").LayerRenderEventTypes, Return>} LayerOnSignature
   */

  /**
   * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {SourceType} [source] Source for this layer.  If not provided to the constructor,
   * the source can be set by calling {@link module:ol/layer/Layer~Layer#setSource layer.setSource(source)} after
   * construction.
   * @property {import("../Map.js").default|null} [map] Map.
   * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
   * HTML element. Will overwrite the default rendering for the layer.
   * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
   */

  /**
   * @typedef {Object} State
   * @property {import("./Layer.js").default} layer Layer.
   * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
   * @property {boolean} visible Visible.
   * @property {boolean} managed Managed.
   * @property {import("../extent.js").Extent} [extent] Extent.
   * @property {number} zIndex ZIndex.
   * @property {number} maxResolution Maximum resolution.
   * @property {number} minResolution Minimum resolution.
   * @property {number} minZoom Minimum zoom.
   * @property {number} maxZoom Maximum zoom.
   */

  /**
   * @classdesc
   * Base class from which all layer types are derived. This should only be instantiated
   * in the case where a custom layer is added to the map with a custom `render` function.
   * Such a function can be specified in the `options` object, and is expected to return an HTML element.
   *
   * A visual representation of raster or vector map data.
   * Layers group together those properties that pertain to how the data is to be
   * displayed, irrespective of the source of that data.
   *
   * Layers are usually added to a map with [map.addLayer()]{@link import("../Map.js").default#addLayer}.
   * Components like {@link module:ol/interaction/Draw~Draw} use unmanaged layers
   * internally. These unmanaged layers are associated with the map using
   * [layer.setMap()]{@link module:ol/layer/Layer~Layer#setMap} instead.
   *
   * A generic `change` event is fired when the state of the source changes.
   *
   * @fires import("../render/Event.js").RenderEvent#prerender
   * @fires import("../render/Event.js").RenderEvent#postrender
   *
   * @template {import("../source/Source.js").default} [SourceType=import("../source/Source.js").default]
   * @template {import("../renderer/Layer.js").default} [RendererType=import("../renderer/Layer.js").default]
   * @api
   */

  var Layer = /*#__PURE__*/function (_BaseLayer) {
    _inherits(Layer, _BaseLayer);

    var _super = _createSuper(Layer);

    /**
     * @param {Options<SourceType>} options Layer options.
     */
    function Layer(options) {
      var _this;

      _classCallCheck(this, Layer);

      var baseOptions = Object.assign({}, options);
      delete baseOptions.source;
      _this = _super.call(this, baseOptions);
      /***
       * @type {LayerOnSignature<import("../events").EventsKey>}
       */

      _this.on;
      /***
       * @type {LayerOnSignature<import("../events").EventsKey>}
       */

      _this.once;
      /***
       * @type {LayerOnSignature<void>}
       */

      _this.un;
      /**
       * @private
       * @type {?import("../events.js").EventsKey}
       */

      _this.mapPrecomposeKey_ = null;
      /**
       * @private
       * @type {?import("../events.js").EventsKey}
       */

      _this.mapRenderKey_ = null;
      /**
       * @private
       * @type {?import("../events.js").EventsKey}
       */

      _this.sourceChangeKey_ = null;
      /**
       * @private
       * @type {RendererType}
       */

      _this.renderer_ = null;
      /**
       * @protected
       * @type {boolean}
       */

      _this.rendered = false; // Overwrite default render method with a custom one

      if (options.render) {
        _this.render = options.render;
      }

      if (options.map) {
        _this.setMap(options.map);
      }

      _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourcePropertyChange_);

      var source = options.source ?
      /** @type {SourceType} */
      options.source : null;

      _this.setSource(source);

      return _this;
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */


    _createClass(Layer, [{
      key: "getLayersArray",
      value: function getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */

    }, {
      key: "getLayerStatesArray",
      value: function getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */

    }, {
      key: "getSource",
      value: function getSource() {
        return (
          /** @type {SourceType} */
          this.get(LayerProperty.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */

    }, {
      key: "getRenderSource",
      value: function getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */

    }, {
      key: "getSourceState",
      value: function getSourceState() {
        var source = this.getSource();
        return !source ? 'undefined' : source.getState();
      }
      /**
       * @private
       */

    }, {
      key: "handleSourceChange_",
      value: function handleSourceChange_() {
        this.changed();
      }
      /**
       * @private
       */

    }, {
      key: "handleSourcePropertyChange_",
      value: function handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }

        var source = this.getSource();

        if (source) {
          this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
        }

        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */

    }, {
      key: "getFeatures",
      value: function getFeatures(pixel) {
        if (!this.renderer_) {
          return new Promise(function (resolve) {
            return resolve([]);
          });
        }

        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */

    }, {
      key: "getData",
      value: function getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }

        return this.renderer_.getData(pixel);
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement} The rendered element.
       */

    }, {
      key: "render",
      value: function render(frameState, target) {
        var layerRenderer = this.getRenderer();

        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
      }
      /**
       * Called when a layer is not visible during a map render.
       */

    }, {
      key: "unrender",
      value: function unrender() {
        this.rendered = false;
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */

    }, {
      key: "setMapInternal",
      value: function setMapInternal(map) {
        if (!map) {
          this.unrender();
        }

        this.set(LayerProperty.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */

    }, {
      key: "getMapInternal",
      value: function getMapInternal() {
        return this.get(LayerProperty.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */

    }, {
      key: "setMap",
      value: function setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }

        if (!map) {
          this.changed();
        }

        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }

        if (map) {
          this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function (evt) {
            var renderEvent =
            /** @type {import("../render/Event.js").default} */
            evt;
            var layerStatesArray = renderEvent.frameState.layerStatesArray;
            var layerState = this.getLayerState(false); // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.

            assert(!layerStatesArray.some(function (arrayLayerState) {
              return arrayLayerState.layer === layerState.layer;
            }), 67);
            layerStatesArray.push(layerState);
          }, this);
          this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */

    }, {
      key: "setSource",
      value: function setSource(source) {
        this.set(LayerProperty.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */

    }, {
      key: "getRenderer",
      value: function getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }

        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */

    }, {
      key: "hasRenderer",
      value: function hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */

    }, {
      key: "createRenderer",
      value: function createRenderer() {
        return null;
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }

        this.setSource(null);

        _get(_getPrototypeOf(Layer.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return Layer;
  }(BaseLayer);
  /**
   * Return `true` if the layer is visible and if the provided view state
   * has resolution and zoom levels that are in range of the layer's min/max.
   * @param {State} layerState Layer state.
   * @param {import("../View.js").State} viewState View state.
   * @return {boolean} The layer is visible at the given view state.
   */


  function inView(layerState, viewState) {
    if (!layerState.visible) {
      return false;
    }

    var resolution = viewState.resolution;

    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
      return false;
    }

    var zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
  }

  /**
   * @typedef HitMatch
   * @property {import("../Feature.js").FeatureLike} feature Feature.
   * @property {import("../layer/Layer.js").default} layer Layer.
   * @property {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @property {number} distanceSq Squared distance.
   * @property {import("./vector.js").FeatureCallback<T>} callback Callback.
   * @template T
   */

  /**
   * @abstract
   */

  var MapRenderer = /*#__PURE__*/function (_Disposable) {
    _inherits(MapRenderer, _Disposable);

    var _super = _createSuper(MapRenderer);

    /**
     * @param {import("../Map.js").default} map Map.
     */
    function MapRenderer(map) {
      var _this;

      _classCallCheck(this, MapRenderer);

      _this = _super.call(this);
      /**
       * @private
       * @type {import("../Map.js").default}
       */

      _this.map_ = map;
      return _this;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */


    _createClass(MapRenderer, [{
      key: "dispatchRenderEvent",
      value: function dispatchRenderEvent(type, frameState) {
        _abstract();
      }
      /**
       * @param {import("../Map.js").FrameState} frameState FrameState.
       * @protected
       */

    }, {
      key: "calculateMatrices2D",
      value: function calculateMatrices2D(frameState) {
        var viewState = frameState.viewState;
        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
        compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
        makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
      }
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */

    }, {
      key: "forEachFeatureAtCoordinate",
      value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
        var result;
        var viewState = frameState.viewState;
        /**
         * @param {boolean} managed Managed layer.
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @param {import("../geom/Geometry.js").default} geometry Geometry.
         * @return {T|undefined} Callback result.
         */

        function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
          return callback.call(thisArg, feature, managed ? layer : null, geometry);
        }

        var projection = viewState.projection;
        var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
        var offsets = [[0, 0]];

        if (projection.canWrapX() && checkWrapped) {
          var projectionExtent = projection.getExtent();
          var worldWidth = getWidth(projectionExtent);
          offsets.push([-worldWidth, 0], [worldWidth, 0]);
        }

        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        var matches =
        /** @type {Array<HitMatch<T>>} */
        [];
        var tmpCoord = [];

        for (var i = 0; i < offsets.length; i++) {
          for (var j = numLayers - 1; j >= 0; --j) {
            var layerState = layerStates[j];
            var layer = layerState.layer;

            if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
              var layerRenderer = layer.getRenderer();
              var source = layer.getSource();

              if (layerRenderer && source) {
                var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;

                var _callback = forEachFeatureAtCoordinate.bind(null, layerState.managed);

                tmpCoord[0] = coordinates[0] + offsets[i][0];
                tmpCoord[1] = coordinates[1] + offsets[i][1];
                result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, _callback, matches);
              }

              if (result) {
                return result;
              }
            }
          }
        }

        if (matches.length === 0) {
          return undefined;
        }

        var order = 1 / matches.length;
        matches.forEach(function (m, i) {
          return m.distanceSq += i * order;
        });
        matches.sort(function (a, b) {
          return a.distanceSq - b.distanceSq;
        });
        matches.some(function (m) {
          return result = m.callback(m.feature, m.layer, m.geometry);
        });
        return result;
      }
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
       * @return {boolean} Is there a feature at the given coordinate?
       * @template U
       */

    }, {
      key: "hasFeatureAtCoordinate",
      value: function hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
        return hasFeature !== undefined;
      }
      /**
       * @return {import("../Map.js").default} Map.
       */

    }, {
      key: "getMap",
      value: function getMap() {
        return this.map_;
      }
      /**
       * Render.
       * @abstract
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "renderFrame",
      value: function renderFrame(frameState) {
        _abstract();
      }
      /**
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "scheduleExpireIconCache",
      value: function scheduleExpireIconCache(frameState) {
        if (shared.canExpireCache()) {
          frameState.postRenderFunctions.push(expireIconCache);
        }
      }
    }]);

    return MapRenderer;
  }(Disposable);
  /**
   * @param {import("../Map.js").default} map Map.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */


  function expireIconCache(map, frameState) {
    shared.expire();
  }

  var RenderEvent = /*#__PURE__*/function (_Event) {
    _inherits(RenderEvent, _Event);

    var _super = _createSuper(RenderEvent);

    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    function RenderEvent(type, inversePixelTransform, frameState, context) {
      var _this;

      _classCallCheck(this, RenderEvent);

      _this = _super.call(this, type);
      /**
       * Transform from CSS pixels (relative to the top-left corner of the map viewport)
       * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
       * @type {import("../transform.js").Transform|undefined}
       * @api
       */

      _this.inversePixelTransform = inversePixelTransform;
      /**
       * An object representing the current render frame state.
       * @type {import("../Map.js").FrameState|undefined}
       * @api
       */

      _this.frameState = frameState;
      /**
       * Canvas context. Not available when the event is dispatched by the map. For Canvas 2D layers,
       * the context will be the 2D rendering context.  For WebGL layers, the context will be the WebGL
       * context.
       * @type {CanvasRenderingContext2D|WebGLRenderingContext|undefined}
       * @api
       */

      _this.context = context;
      return _this;
    }

    return _createClass(RenderEvent);
  }(BaseEvent);

  /**
   * @module ol/css
   */

  /**
   * @typedef {Object} FontParameters
   * @property {string} style Style.
   * @property {string} variant Variant.
   * @property {string} weight Weight.
   * @property {string} size Size.
   * @property {string} lineHeight LineHeight.
   * @property {string} family Family.
   * @property {Array<string>} families Families.
   */

  /**
   * The CSS class for hidden feature.
   *
   * @const
   * @type {string}
   */
  var CLASS_HIDDEN = 'ol-hidden';
  /**
   * The CSS class that we'll give the DOM elements to have them unselectable.
   *
   * @const
   * @type {string}
   */

  var CLASS_UNSELECTABLE = 'ol-unselectable';
  /**
   * The CSS class for controls.
   *
   * @const
   * @type {string}
   */

  var CLASS_CONTROL = 'ol-control';
  /**
   * The CSS class that we'll give the DOM elements that are collapsed, i.e.
   * to those elements which usually can be expanded.
   *
   * @const
   * @type {string}
   */

  var CLASS_COLLAPSED = 'ol-collapsed';

  /**
   * @module ol/dom
   */
  //FIXME Move this function to the canvas module

  /**
   * Create an html canvas element and returns its 2d context.
   * @param {number} [width] Canvas width.
   * @param {number} [height] Canvas height.
   * @param {Array<HTMLCanvasElement>} [canvasPool] Canvas pool to take existing canvas from.
   * @param {CanvasRenderingContext2DSettings} [settings] CanvasRenderingContext2DSettings
   * @return {CanvasRenderingContext2D} The context.
   */

  function createCanvasContext2D(width, height, canvasPool, settings) {
    /** @type {HTMLCanvasElement|OffscreenCanvas} */
    var canvas;

    if (canvasPool && canvasPool.length) {
      canvas = canvasPool.shift();
    } else if (WORKER_OFFSCREEN_CANVAS) {
      canvas = new OffscreenCanvas(width || 300, height || 300);
    } else {
      canvas = document.createElement('canvas');
    }

    if (width) {
      canvas.width = width;
    }

    if (height) {
      canvas.height = height;
    } //FIXME Allow OffscreenCanvasRenderingContext2D as return type


    return (
      /** @type {CanvasRenderingContext2D} */
      canvas.getContext('2d', settings)
    );
  }
  /**
   * Releases canvas memory to avoid exceeding memory limits in Safari.
   * See https://pqina.nl/blog/total-canvas-memory-use-exceeds-the-maximum-limit/
   * @param {CanvasRenderingContext2D} context Context.
   */

  function releaseCanvas$1(context) {
    var canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
  }
  /**
   * @param {Node} newNode Node to replace old node
   * @param {Node} oldNode The node to be replaced
   */

  function replaceNode(newNode, oldNode) {
    var parent = oldNode.parentNode;

    if (parent) {
      parent.replaceChild(newNode, oldNode);
    }
  }
  /**
   * @param {Node} node The node to remove.
   * @return {Node|null} The node that was removed or null.
   */

  function removeNode$1(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * @param {Node} node The node to remove the children from.
   */

  function removeChildren(node) {
    while (node.lastChild) {
      node.removeChild(node.lastChild);
    }
  }
  /**
   * Transform the children of a parent node so they match the
   * provided list of children.  This function aims to efficiently
   * remove, add, and reorder child nodes while maintaining a simple
   * implementation (it is not guaranteed to minimize DOM operations).
   * @param {Node} node The parent node whose children need reworking.
   * @param {Array<Node>} children The desired children.
   */

  function replaceChildren(node, children) {
    var oldChildren = node.childNodes;

    for (var i = 0; true; ++i) {
      var oldChild = oldChildren[i];
      var newChild = children[i]; // check if our work is done

      if (!oldChild && !newChild) {
        break;
      } // check if children match


      if (oldChild === newChild) {
        continue;
      } // check if a new child needs to be added


      if (!oldChild) {
        node.appendChild(newChild);
        continue;
      } // check if an old child needs to be removed


      if (!newChild) {
        node.removeChild(oldChild);
        --i;
        continue;
      } // reorder


      node.insertBefore(newChild, oldChild);
    }
  }

  /**
   * @module ol/render/canvas
   */
  /**
   * @type {BaseObject}
   */

  var checkedFonts = new BaseObject();

  /**
   * @classdesc
   * Canvas map renderer.
   * @api
   */

  var CompositeMapRenderer = /*#__PURE__*/function (_MapRenderer) {
    _inherits(CompositeMapRenderer, _MapRenderer);

    var _super = _createSuper(CompositeMapRenderer);

    /**
     * @param {import("../Map.js").default} map Map.
     */
    function CompositeMapRenderer(map) {
      var _this;

      _classCallCheck(this, CompositeMapRenderer);

      _this = _super.call(this, map);
      /**
       * @type {import("../events.js").EventsKey}
       */

      _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
      /**
       * @private
       * @type {HTMLDivElement}
       */

      _this.element_ = document.createElement('div');
      var style = _this.element_.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      style.zIndex = '0';
      _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
      var container = map.getViewport();
      container.insertBefore(_this.element_, container.firstChild || null);
      /**
       * @private
       * @type {Array<HTMLElement>}
       */

      _this.children_ = [];
      /**
       * @private
       * @type {boolean}
       */

      _this.renderedVisible_ = true;
      return _this;
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */


    _createClass(CompositeMapRenderer, [{
      key: "dispatchRenderEvent",
      value: function dispatchRenderEvent(type, frameState) {
        var map = this.getMap();

        if (map.hasListener(type)) {
          var event = new RenderEvent(type, undefined, frameState);
          map.dispatchEvent(event);
        }
      }
    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        unlistenByKey(this.fontChangeListenerKey_);
        this.element_.parentNode.removeChild(this.element_);

        _get(_getPrototypeOf(CompositeMapRenderer.prototype), "disposeInternal", this).call(this);
      }
      /**
       * Render.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "renderFrame",
      value: function renderFrame(frameState) {
        if (!frameState) {
          if (this.renderedVisible_) {
            this.element_.style.display = 'none';
            this.renderedVisible_ = false;
          }

          return;
        }

        this.calculateMatrices2D(frameState);
        this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
        var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
          return a.zIndex - b.zIndex;
        });
        var viewState = frameState.viewState;
        this.children_.length = 0;
        /**
         * @type {Array<import("../layer/BaseVector.js").default>}
         */

        var declutterLayers = [];
        var previousElement = null;

        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
          var layerState = layerStatesArray[i];
          frameState.layerIndex = i;
          var layer = layerState.layer;
          var sourceState = layer.getSourceState();

          if (!inView(layerState, viewState) || sourceState != 'ready' && sourceState != 'undefined') {
            layer.unrender();
            continue;
          }

          var element = layer.render(frameState, previousElement);

          if (!element) {
            continue;
          }

          if (element !== previousElement) {
            this.children_.push(element);
            previousElement = element;
          }

          if ('getDeclutter' in layer) {
            declutterLayers.push(
            /** @type {import("../layer/BaseVector.js").default} */
            layer);
          }
        }

        for (var _i = declutterLayers.length - 1; _i >= 0; --_i) {
          declutterLayers[_i].renderDeclutter(frameState);
        }

        replaceChildren(this.element_, this.children_);
        this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);

        if (!this.renderedVisible_) {
          this.element_.style.display = '';
          this.renderedVisible_ = true;
        }

        this.scheduleExpireIconCache(frameState);
      }
    }]);

    return CompositeMapRenderer;
  }(MapRenderer);

  /**
   * @typedef {'addlayer'|'removelayer'} EventType
   */

  /**
   * @classdesc
   * A layer group triggers 'addlayer' and 'removelayer' events when layers are added to or removed from
   * the group or one of its child groups.  When a layer group is added to or removed from another layer group,
   * a single event will be triggered (instead of one per layer in the group added or removed).
   */

  var GroupEvent = /*#__PURE__*/function (_Event) {
    _inherits(GroupEvent, _Event);

    var _super = _createSuper(GroupEvent);

    /**
     * @param {EventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    function GroupEvent(type, layer) {
      var _this;

      _classCallCheck(this, GroupEvent);

      _this = _super.call(this, type);
      /**
       * The added or removed layer.
       * @type {BaseLayer}
       * @api
       */

      _this.layer = layer;
      return _this;
    }

    return _createClass(GroupEvent);
  }(BaseEvent);
  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
   *     'change:layers', import("../Object").ObjectEvent, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|'change:layers', Return>} GroupOnSignature
   */

  /**
   * @typedef {Object} Options
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {Array<import("./Base.js").default>|Collection<import("./Base.js").default>} [layers] Child layers.
   * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
   */

  /**
   * @enum {string}
   * @private
   */

  var Property = {
    LAYERS: 'layers'
  };
  /**
   * @classdesc
   * A {@link module:ol/Collection~Collection} of layers that are handled together.
   *
   * A generic `change` event is triggered when the group/Collection changes.
   *
   * @api
   */

  var LayerGroup = /*#__PURE__*/function (_BaseLayer) {
    _inherits(LayerGroup, _BaseLayer);

    var _super2 = _createSuper(LayerGroup);

    /**
     * @param {Options} [options] Layer options.
     */
    function LayerGroup(options) {
      var _this2;

      _classCallCheck(this, LayerGroup);

      options = options || {};
      var baseOptions =
      /** @type {Options} */
      Object.assign({}, options);
      delete baseOptions.layers;
      var layers = options.layers;
      _this2 = _super2.call(this, baseOptions);
      /***
       * @type {GroupOnSignature<import("../events").EventsKey>}
       */

      _this2.on;
      /***
       * @type {GroupOnSignature<import("../events").EventsKey>}
       */

      _this2.once;
      /***
       * @type {GroupOnSignature<void>}
       */

      _this2.un;
      /**
       * @private
       * @type {Array<import("../events.js").EventsKey>}
       */

      _this2.layersListenerKeys_ = [];
      /**
       * @private
       * @type {Object<string, Array<import("../events.js").EventsKey>>}
       */

      _this2.listenerKeys_ = {};

      _this2.addChangeListener(Property.LAYERS, _this2.handleLayersChanged_);

      if (layers) {
        if (Array.isArray(layers)) {
          layers = new Collection(layers.slice(), {
            unique: true
          });
        } else {
          assert(typeof
          /** @type {?} */
          layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
        }
      } else {
        layers = new Collection(undefined, {
          unique: true
        });
      }

      _this2.setLayers(layers);

      return _this2;
    }
    /**
     * @private
     */


    _createClass(LayerGroup, [{
      key: "handleLayerChange_",
      value: function handleLayerChange_() {
        this.changed();
      }
      /**
       * @private
       */

    }, {
      key: "handleLayersChanged_",
      value: function handleLayersChanged_() {
        this.layersListenerKeys_.forEach(unlistenByKey);
        this.layersListenerKeys_.length = 0;
        var layers = this.getLayers();
        this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));

        for (var id in this.listenerKeys_) {
          this.listenerKeys_[id].forEach(unlistenByKey);
        }

        clear(this.listenerKeys_);
        var layersArray = layers.getArray();

        for (var i = 0, ii = layersArray.length; i < ii; i++) {
          var layer = layersArray[i];
          this.registerLayerListeners_(layer);
          this.dispatchEvent(new GroupEvent('addlayer', layer));
        }

        this.changed();
      }
      /**
       * @param {BaseLayer} layer The layer.
       */

    }, {
      key: "registerLayerListeners_",
      value: function registerLayerListeners_(layer) {
        var listenerKeys = [listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(layer, EventType.CHANGE, this.handleLayerChange_, this)];

        if (layer instanceof LayerGroup) {
          listenerKeys.push(listen(layer, 'addlayer', this.handleLayerGroupAdd_, this), listen(layer, 'removelayer', this.handleLayerGroupRemove_, this));
        }

        this.listenerKeys_[getUid(layer)] = listenerKeys;
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */

    }, {
      key: "handleLayerGroupAdd_",
      value: function handleLayerGroupAdd_(event) {
        this.dispatchEvent(new GroupEvent('addlayer', event.layer));
      }
      /**
       * @param {GroupEvent} event The layer group event.
       */

    }, {
      key: "handleLayerGroupRemove_",
      value: function handleLayerGroupRemove_(event) {
        this.dispatchEvent(new GroupEvent('removelayer', event.layer));
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */

    }, {
      key: "handleLayersAdd_",
      value: function handleLayersAdd_(collectionEvent) {
        var layer = collectionEvent.element;
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent('addlayer', layer));
        this.changed();
      }
      /**
       * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
       * @private
       */

    }, {
      key: "handleLayersRemove_",
      value: function handleLayersRemove_(collectionEvent) {
        var layer = collectionEvent.element;
        var key = getUid(layer);
        this.listenerKeys_[key].forEach(unlistenByKey);
        delete this.listenerKeys_[key];
        this.dispatchEvent(new GroupEvent('removelayer', layer));
        this.changed();
      }
      /**
       * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!Collection<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */

    }, {
      key: "getLayers",
      value: function getLayers() {
        return (
          /** @type {!Collection<import("./Base.js").default>} */
          this.get(Property.LAYERS)
        );
      }
      /**
       * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!Collection<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
       * @observable
       * @api
       */

    }, {
      key: "setLayers",
      value: function setLayers(layers) {
        var collection = this.getLayers();

        if (collection) {
          var currentLayers = collection.getArray();

          for (var i = 0, ii = currentLayers.length; i < ii; ++i) {
            this.dispatchEvent(new GroupEvent('removelayer', currentLayers[i]));
          }
        }

        this.set(Property.LAYERS, layers);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */

    }, {
      key: "getLayersArray",
      value: function getLayersArray(array) {
        array = array !== undefined ? array : [];
        this.getLayers().forEach(function (layer) {
          layer.getLayersArray(array);
        });
        return array;
      }
      /**
       * Get the layer states list and use this groups z-index as the default
       * for all layers in this and nested groups, if it is unset at this point.
       * If dest is not provided and this group's z-index is undefined
       * 0 is used a the default z-index.
       * @param {Array<import("./Layer.js").State>} [dest] Optional list
       * of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */

    }, {
      key: "getLayerStatesArray",
      value: function getLayerStatesArray(dest) {
        var states = dest !== undefined ? dest : [];
        var pos = states.length;
        this.getLayers().forEach(function (layer) {
          layer.getLayerStatesArray(states);
        });
        var ownLayerState = this.getLayerState();
        var defaultZIndex = ownLayerState.zIndex;

        if (!dest && ownLayerState.zIndex === undefined) {
          defaultZIndex = 0;
        }

        for (var i = pos, ii = states.length; i < ii; i++) {
          var layerState = states[i];
          layerState.opacity *= ownLayerState.opacity;
          layerState.visible = layerState.visible && ownLayerState.visible;
          layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
          layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
          layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
          layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);

          if (ownLayerState.extent !== undefined) {
            if (layerState.extent !== undefined) {
              layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
            } else {
              layerState.extent = ownLayerState.extent;
            }
          }

          if (layerState.zIndex === undefined) {
            layerState.zIndex = defaultZIndex;
          }
        }

        return states;
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */

    }, {
      key: "getSourceState",
      value: function getSourceState() {
        return 'ready';
      }
    }]);

    return LayerGroup;
  }(BaseLayer);

  /**
   * @classdesc
   * Events emitted as map events are instances of this type.
   * See {@link module:ol/Map~Map} for which events trigger a map event.
   */

  var MapEvent = /*#__PURE__*/function (_Event) {
    _inherits(MapEvent, _Event);

    var _super = _createSuper(MapEvent);

    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    function MapEvent(type, map, frameState) {
      var _this;

      _classCallCheck(this, MapEvent);

      _this = _super.call(this, type);
      /**
       * The map where the event occurred.
       * @type {import("./Map.js").default}
       * @api
       */

      _this.map = map;
      /**
       * The frame state at the time of the event.
       * @type {?import("./Map.js").FrameState}
       * @api
       */

      _this.frameState = frameState !== undefined ? frameState : null;
      return _this;
    }

    return _createClass(MapEvent);
  }(BaseEvent);

  /**
   * @classdesc
   * Events emitted as map browser events are instances of this type.
   * See {@link module:ol/Map~Map} for which events trigger a map browser event.
   * @template {UIEvent} EVENT
   */

  var MapBrowserEvent = /*#__PURE__*/function (_MapEvent) {
    _inherits(MapBrowserEvent, _MapEvent);

    var _super = _createSuper(MapBrowserEvent);

    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    function MapBrowserEvent(type, map, originalEvent, dragging, frameState, activePointers) {
      var _this;

      _classCallCheck(this, MapBrowserEvent);

      _this = _super.call(this, type, map, frameState);
      /**
       * The original browser event.
       * @const
       * @type {EVENT}
       * @api
       */

      _this.originalEvent = originalEvent;
      /**
       * The map pixel relative to the viewport corresponding to the original browser event.
       * @type {?import("./pixel.js").Pixel}
       */

      _this.pixel_ = null;
      /**
       * The coordinate in the user projection corresponding to the original browser event.
       * @type {?import("./coordinate.js").Coordinate}
       */

      _this.coordinate_ = null;
      /**
       * Indicates if the map is currently being dragged. Only set for
       * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
       *
       * @type {boolean}
       * @api
       */

      _this.dragging = dragging !== undefined ? dragging : false;
      /**
       * @type {Array<PointerEvent>|undefined}
       */

      _this.activePointers = activePointers;
      return _this;
    }
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */


    _createClass(MapBrowserEvent, [{
      key: "pixel",
      get: function get() {
        if (!this.pixel_) {
          this.pixel_ = this.map.getEventPixel(this.originalEvent);
        }

        return this.pixel_;
      },
      set: function set(pixel) {
        this.pixel_ = pixel;
      }
      /**
       * The coordinate corresponding to the original browser event.  This will be in the user
       * projection if one is set.  Otherwise it will be in the view projection.
       * @type {import("./coordinate.js").Coordinate}
       * @api
       */

    }, {
      key: "coordinate",
      get: function get() {
        if (!this.coordinate_) {
          this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
        }

        return this.coordinate_;
      },
      set: function set(coordinate) {
        this.coordinate_ = coordinate;
      }
      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @api
       */

    }, {
      key: "preventDefault",
      value: function preventDefault() {
        _get(_getPrototypeOf(MapBrowserEvent.prototype), "preventDefault", this).call(this);

        if ('preventDefault' in this.originalEvent) {
          /** @type {UIEvent} */
          this.originalEvent.preventDefault();
        }
      }
      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @api
       */

    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        _get(_getPrototypeOf(MapBrowserEvent.prototype), "stopPropagation", this).call(this);

        if ('stopPropagation' in this.originalEvent) {
          /** @type {UIEvent} */
          this.originalEvent.stopPropagation();
        }
      }
    }]);

    return MapBrowserEvent;
  }(MapEvent);

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */

  var MapBrowserEventType = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: 'singleclick',

    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: EventType.CLICK,

    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: EventType.DBLCLICK,

    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: 'pointerdrag',

    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
  };
  /***
   * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types
   */

  /**
   * @module ol/pointer/EventType
   */

  /**
   * Constants for event names.
   * @enum {string}
   */
  var PointerEventType = {
    POINTERMOVE: 'pointermove',
    POINTERDOWN: 'pointerdown',
    POINTERUP: 'pointerup',
    POINTEROVER: 'pointerover',
    POINTEROUT: 'pointerout',
    POINTERENTER: 'pointerenter',
    POINTERLEAVE: 'pointerleave',
    POINTERCANCEL: 'pointercancel'
  };

  var MapBrowserEventHandler = /*#__PURE__*/function (_Target) {
    _inherits(MapBrowserEventHandler, _Target);

    var _super = _createSuper(MapBrowserEventHandler);

    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    function MapBrowserEventHandler(map, moveTolerance) {
      var _this;

      _classCallCheck(this, MapBrowserEventHandler);

      _this = _super.call(this, map);
      /**
       * This is the element that we will listen to the real events on.
       * @type {import("./Map.js").default}
       * @private
       */

      _this.map_ = map;
      /**
       * @type {any}
       * @private
       */

      _this.clickTimeoutId_;
      /**
       * Emulate dblclick and singleclick. Will be true when only one pointer is active.
       * @type {boolean}
       */

      _this.emulateClicks_ = false;
      /**
       * @type {boolean}
       * @private
       */

      _this.dragging_ = false;
      /**
       * @type {!Array<import("./events.js").EventsKey>}
       * @private
       */

      _this.dragListenerKeys_ = [];
      /**
       * @type {number}
       * @private
       */

      _this.moveTolerance_ = moveTolerance === undefined ? 1 : moveTolerance;
      /**
       * The most recent "down" type event (or null if none have occurred).
       * Set on pointerdown.
       * @type {PointerEvent|null}
       * @private
       */

      _this.down_ = null;

      var element = _this.map_.getViewport();
      /**
       * @type {Array<PointerEvent>}
       * @private
       */


      _this.activePointers_ = [];
      /**
       * @type {!Object<number, Event>}
       * @private
       */

      _this.trackedTouches_ = {};
      _this.element_ = element;
      /**
       * @type {?import("./events.js").EventsKey}
       * @private
       */

      _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _assertThisInitialized(_this));
      /**
       * @type {PointerEvent}
       * @private
       */

      _this.originalPointerMoveEvent_;
      /**
       * @type {?import("./events.js").EventsKey}
       * @private
       */

      _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayMoveEvent_, _assertThisInitialized(_this));
      /**
       * @private
       */

      _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_assertThisInitialized(_this));

      _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {
        passive: false
      } : false);

      return _this;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */


    _createClass(MapBrowserEventHandler, [{
      key: "emulateClick_",
      value: function emulateClick_(pointerEvent) {
        var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);

        if (this.clickTimeoutId_ !== undefined) {
          // double-click
          clearTimeout(this.clickTimeoutId_);
          this.clickTimeoutId_ = undefined;
          newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
        } else {
          // click
          this.clickTimeoutId_ = setTimeout(
          /** @this {MapBrowserEventHandler} */
          function () {
            this.clickTimeoutId_ = undefined;
            var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
          }.bind(this), 250);
        }
      }
      /**
       * Keeps track on how many pointers are currently active.
       *
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */

    }, {
      key: "updateActivePointers_",
      value: function updateActivePointers_(pointerEvent) {
        var event = pointerEvent;
        var id = event.pointerId;

        if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
          delete this.trackedTouches_[id];

          for (var pointerId in this.trackedTouches_) {
            if (this.trackedTouches_[pointerId].target !== event.target) {
              // Some platforms assign a new pointerId when the target changes.
              // If this happens, delete one tracked pointer. If there is more
              // than one tracked pointer for the old target, it will be cleared
              // by subsequent POINTERUP events from other pointers.
              delete this.trackedTouches_[pointerId];
              break;
            }
          }
        } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {
          this.trackedTouches_[id] = event;
        }

        this.activePointers_ = Object.values(this.trackedTouches_);
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */

    }, {
      key: "handlePointerUp_",
      value: function handlePointerUp_(pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.preventDefault().

        if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
          this.emulateClick_(this.down_);
        }

        if (this.activePointers_.length === 0) {
          this.dragListenerKeys_.forEach(unlistenByKey);
          this.dragListenerKeys_.length = 0;
          this.dragging_ = false;
          this.down_ = null;
        }
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} If the left mouse button was pressed.
       * @private
       */

    }, {
      key: "isMouseActionButton_",
      value: function isMouseActionButton_(pointerEvent) {
        return pointerEvent.button === 0;
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */

    }, {
      key: "handlePointerDown_",
      value: function handlePointerDown_(pointerEvent) {
        this.emulateClicks_ = this.activePointers_.length === 0;
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent, undefined, undefined, this.activePointers_);
        this.dispatchEvent(newEvent); // Store a copy of the down event

        this.down_ =
        /** @type {PointerEvent} */
        {};

        for (var property in pointerEvent) {
          var value = pointerEvent[property];
          this.down_[property] = typeof value === 'function' ? VOID : value;
        }

        if (this.dragListenerKeys_.length === 0) {
          var doc = this.map_.getOwnerDocument();
          this.dragListenerKeys_.push(listen(doc, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),
          /* Note that the listener for `pointercancel is set up on
           * `pointerEventHandler_` and not `documentPointerEventHandler_` like
           * the `pointerup` and `pointermove` listeners.
           *
           * The reason for this is the following: `TouchSource.vacuumTouches_()`
           * issues `pointercancel` events, when there was no `touchend` for a
           * `touchstart`. Now, let's say a first `touchstart` is registered on
           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
           * But `documentPointerEventHandler_` doesn't know about the first
           * `touchstart`. If there is no `touchend` for the `touchstart`, we can
           * only receive a `touchcancel` from `pointerEventHandler_`, because it is
           * only registered there.
           */
          listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));

          if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
            this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
          }
        }
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */

    }, {
      key: "handlePointerMove_",
      value: function handlePointerMove_(pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
          this.updateActivePointers_(pointerEvent);
          this.dragging_ = true;
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_, undefined, this.activePointers_);
          this.dispatchEvent(newEvent);
        }
      }
      /**
       * Wrap and relay a pointermove event.
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */

    }, {
      key: "relayMoveEvent_",
      value: function relayMoveEvent_(pointerEvent) {
        this.originalPointerMoveEvent_ = pointerEvent;
        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new MapBrowserEvent(MapBrowserEventType.POINTERMOVE, this.map_, pointerEvent, dragging));
      }
      /**
       * Flexible handling of a `touch-action: none` css equivalent: because calling
       * `preventDefault()` on a `pointermove` event does not stop native page scrolling
       * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
       * when an interaction (currently `DragPan` handles the event.
       * @param {TouchEvent} event Event.
       * @private
       */

    }, {
      key: "handleTouchMove_",
      value: function handleTouchMove_(event) {
        // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
        // may not be initialized yet when we get here on a platform without native pointer events.
        var originalEvent = this.originalPointerMoveEvent_;

        if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== 'boolean' || event.cancelable === true)) {
          event.preventDefault();
        }
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} Is moving.
       * @private
       */

    }, {
      key: "isMoving_",
      value: function isMoving_(pointerEvent) {
        return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        if (this.relayedListenerKey_) {
          unlistenByKey(this.relayedListenerKey_);
          this.relayedListenerKey_ = null;
        }

        this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);

        if (this.pointerdownListenerKey_) {
          unlistenByKey(this.pointerdownListenerKey_);
          this.pointerdownListenerKey_ = null;
        }

        this.dragListenerKeys_.forEach(unlistenByKey);
        this.dragListenerKeys_.length = 0;
        this.element_ = null;

        _get(_getPrototypeOf(MapBrowserEventHandler.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return MapBrowserEventHandler;
  }(Target);

  /**
   * @module ol/MapEventType
   */

  /**
   * @enum {string}
   */
  var MapEventType = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: 'postrender',

    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: 'movestart',

    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: 'moveend',

    /**
     * Triggered when loading of additional map data (tiles, images, features) starts.
     * @event module:ol/MapEvent~MapEvent#loadstart
     * @api
     */
    LOADSTART: 'loadstart',

    /**
     * Triggered when loading of additional map data has completed.
     * @event module:ol/MapEvent~MapEvent#loadend
     * @api
     */
    LOADEND: 'loadend'
  };
  /***
   * @typedef {'postrender'|'movestart'|'moveend'|'loadstart'|'loadend'} Types
   */

  /**
   * @module ol/MapProperty
   */

  /**
   * @enum {string}
   */
  var MapProperty = {
    LAYERGROUP: 'layergroup',
    SIZE: 'size',
    TARGET: 'target',
    VIEW: 'view'
  };

  /**
   * @type {number}
   */

  var DROP = Infinity;
  /**
   * @classdesc
   * Priority queue.
   *
   * The implementation is inspired from the Closure Library's Heap class and
   * Python's heapq module.
   *
   * See https://github.com/google/closure-library/blob/master/closure/goog/structs/heap.js
   * and https://hg.python.org/cpython/file/2.7/Lib/heapq.py.
   *
   * @template T
   */

  var PriorityQueue = /*#__PURE__*/function () {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    function PriorityQueue(priorityFunction, keyFunction) {
      _classCallCheck(this, PriorityQueue);

      /**
       * @type {function(T): number}
       * @private
       */
      this.priorityFunction_ = priorityFunction;
      /**
       * @type {function(T): string}
       * @private
       */

      this.keyFunction_ = keyFunction;
      /**
       * @type {Array<T>}
       * @private
       */

      this.elements_ = [];
      /**
       * @type {Array<number>}
       * @private
       */

      this.priorities_ = [];
      /**
       * @type {!Object<string, boolean>}
       * @private
       */

      this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */


    _createClass(PriorityQueue, [{
      key: "clear",
      value: function clear$1() {
        this.elements_.length = 0;
        this.priorities_.length = 0;

        clear(this.queuedElements_);
      }
      /**
       * Remove and return the highest-priority element. O(log N).
       * @return {T} Element.
       */

    }, {
      key: "dequeue",
      value: function dequeue() {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[0];

        if (elements.length == 1) {
          elements.length = 0;
          priorities.length = 0;
        } else {
          elements[0] = elements.pop();
          priorities[0] = priorities.pop();
          this.siftUp_(0);
        }

        var elementKey = this.keyFunction_(element);
        delete this.queuedElements_[elementKey];
        return element;
      }
      /**
       * Enqueue an element. O(log N).
       * @param {T} element Element.
       * @return {boolean} The element was added to the queue.
       */

    }, {
      key: "enqueue",
      value: function enqueue(element) {
        assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue

        var priority = this.priorityFunction_(element);

        if (priority != DROP) {
          this.elements_.push(element);
          this.priorities_.push(priority);
          this.queuedElements_[this.keyFunction_(element)] = true;
          this.siftDown_(0, this.elements_.length - 1);
          return true;
        }

        return false;
      }
      /**
       * @return {number} Count.
       */

    }, {
      key: "getCount",
      value: function getCount() {
        return this.elements_.length;
      }
      /**
       * Gets the index of the left child of the node at the given index.
       * @param {number} index The index of the node to get the left child for.
       * @return {number} The index of the left child.
       * @private
       */

    }, {
      key: "getLeftChildIndex_",
      value: function getLeftChildIndex_(index) {
        return index * 2 + 1;
      }
      /**
       * Gets the index of the right child of the node at the given index.
       * @param {number} index The index of the node to get the right child for.
       * @return {number} The index of the right child.
       * @private
       */

    }, {
      key: "getRightChildIndex_",
      value: function getRightChildIndex_(index) {
        return index * 2 + 2;
      }
      /**
       * Gets the index of the parent of the node at the given index.
       * @param {number} index The index of the node to get the parent for.
       * @return {number} The index of the parent.
       * @private
       */

    }, {
      key: "getParentIndex_",
      value: function getParentIndex_(index) {
        return index - 1 >> 1;
      }
      /**
       * Make this a heap. O(N).
       * @private
       */

    }, {
      key: "heapify_",
      value: function heapify_() {
        var i;

        for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
          this.siftUp_(i);
        }
      }
      /**
       * @return {boolean} Is empty.
       */

    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.elements_.length === 0;
      }
      /**
       * @param {string} key Key.
       * @return {boolean} Is key queued.
       */

    }, {
      key: "isKeyQueued",
      value: function isKeyQueued(key) {
        return key in this.queuedElements_;
      }
      /**
       * @param {T} element Element.
       * @return {boolean} Is queued.
       */

    }, {
      key: "isQueued",
      value: function isQueued(element) {
        return this.isKeyQueued(this.keyFunction_(element));
      }
      /**
       * @param {number} index The index of the node to move down.
       * @private
       */

    }, {
      key: "siftUp_",
      value: function siftUp_(index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var count = elements.length;
        var element = elements[index];
        var priority = priorities[index];
        var startIndex = index;

        while (index < count >> 1) {
          var lIndex = this.getLeftChildIndex_(index);
          var rIndex = this.getRightChildIndex_(index);
          var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
          elements[index] = elements[smallerChildIndex];
          priorities[index] = priorities[smallerChildIndex];
          index = smallerChildIndex;
        }

        elements[index] = element;
        priorities[index] = priority;
        this.siftDown_(startIndex, index);
      }
      /**
       * @param {number} startIndex The index of the root.
       * @param {number} index The index of the node to move up.
       * @private
       */

    }, {
      key: "siftDown_",
      value: function siftDown_(startIndex, index) {
        var elements = this.elements_;
        var priorities = this.priorities_;
        var element = elements[index];
        var priority = priorities[index];

        while (index > startIndex) {
          var parentIndex = this.getParentIndex_(index);

          if (priorities[parentIndex] > priority) {
            elements[index] = elements[parentIndex];
            priorities[index] = priorities[parentIndex];
            index = parentIndex;
          } else {
            break;
          }
        }

        elements[index] = element;
        priorities[index] = priority;
      }
      /**
       * FIXME empty description for jsdoc
       */

    }, {
      key: "reprioritize",
      value: function reprioritize() {
        var priorityFunction = this.priorityFunction_;
        var elements = this.elements_;
        var priorities = this.priorities_;
        var index = 0;
        var n = elements.length;
        var element, i, priority;

        for (i = 0; i < n; ++i) {
          element = elements[i];
          priority = priorityFunction(element);

          if (priority == DROP) {
            delete this.queuedElements_[this.keyFunction_(element)];
          } else {
            priorities[index] = priority;
            elements[index++] = element;
          }
        }

        elements.length = index;
        priorities.length = index;
        this.heapify_();
      }
    }]);

    return PriorityQueue;
  }();

  /**
   * @module ol/TileState
   */

  /**
   * @enum {number}
   */
  var TileState = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,

    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4
  };

  /**
   * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
   */

  var TileQueue = /*#__PURE__*/function (_PriorityQueue) {
    _inherits(TileQueue, _PriorityQueue);

    var _super = _createSuper(TileQueue);

    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    function TileQueue(tilePriorityFunction, tileChangeCallback) {
      var _this;

      _classCallCheck(this, TileQueue);

      _this = _super.call(this,
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function (element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function (element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      });
      /** @private */

      _this.boundHandleTileChange_ = _this.handleTileChange.bind(_assertThisInitialized(_this));
      /**
       * @private
       * @type {function(): ?}
       */

      _this.tileChangeCallback_ = tileChangeCallback;
      /**
       * @private
       * @type {number}
       */

      _this.tilesLoading_ = 0;
      /**
       * @private
       * @type {!Object<string,boolean>}
       */

      _this.tilesLoadingKeys_ = {};
      return _this;
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     */


    _createClass(TileQueue, [{
      key: "enqueue",
      value: function enqueue(element) {
        var added = _get(_getPrototypeOf(TileQueue.prototype), "enqueue", this).call(this, element);

        if (added) {
          var tile = element[0];
          tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
        }

        return added;
      }
      /**
       * @return {number} Number of tiles loading.
       */

    }, {
      key: "getTilesLoading",
      value: function getTilesLoading() {
        return this.tilesLoading_;
      }
      /**
       * @param {import("./events/Event.js").default} event Event.
       * @protected
       */

    }, {
      key: "handleTileChange",
      value: function handleTileChange(event) {
        var tile =
        /** @type {import("./Tile.js").default} */
        event.target;
        var state = tile.getState();

        if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
          if (state !== TileState.ERROR) {
            tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
          }

          var tileKey = tile.getKey();

          if (tileKey in this.tilesLoadingKeys_) {
            delete this.tilesLoadingKeys_[tileKey];
            --this.tilesLoading_;
          }

          this.tileChangeCallback_();
        }
      }
      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */

    }, {
      key: "loadMoreTiles",
      value: function loadMoreTiles(maxTotalLoading, maxNewLoads) {
        var newLoads = 0;
        var state, tile, tileKey;

        while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
          tile =
          /** @type {import("./Tile.js").default} */
          this.dequeue()[0];
          tileKey = tile.getKey();
          state = tile.getState();

          if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
            this.tilesLoadingKeys_[tileKey] = true;
            ++this.tilesLoading_;
            ++newLoads;
            tile.load();
          }
        }
      }
    }]);

    return TileQueue;
  }(PriorityQueue);
  /**
   * @param {import('./Map.js').FrameState} frameState Frame state.
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */

  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    // Filter out tiles at higher zoom levels than the current zoom level, or that
    // are outside the visible extent.
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
      return DROP;
    }

    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
      return DROP;
    } // Prioritize the highest zoom level tiles closest to the focus.
    // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
    // Within a zoom level, tiles are prioritized by the distance in pixels between
    // the center of the tile and the center of the viewport.  The factor of 65536
    // means that the prioritization should behave as desired for tiles up to
    // 65536 * Math.log(2) = 45426 pixels from the focus.


    var center = frameState.viewState.center;
    var deltaX = tileCenter[0] - center[0];
    var deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }

  /**
   * @module ol/ViewHint
   */

  /**
   * @enum {number}
   */
  var ViewHint = {
    ANIMATING: 0,
    INTERACTING: 1
  };

  /**
   * @module ol/ViewProperty
   */

  /**
   * @enum {string}
   */
  var ViewProperty = {
    CENTER: 'center',
    RESOLUTION: 'resolution',
    ROTATION: 'rotation'
  };

  /**
   * @module ol/tilegrid/common
   */

  /**
   * Default maximum zoom for default tile grids.
   * @type {number}
   */
  var DEFAULT_MAX_ZOOM = 42;
  /**
   * Default tile size.
   * @type {number}
   */

  var DEFAULT_TILE_SIZE = 256;

  /**
   * @module ol/centerconstraint
   */
  /**
   * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
   */

  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
   * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
   * (only during interaction and animation).
   * @return {Type} The constraint.
   */

  function createExtent(extent, onlyCenter, smooth) {
    return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number|undefined} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @param {Array<number>} [centerShift] Shift between map center and viewport center.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function (center, resolution, size, isMoving, centerShift) {
        if (!center) {
          return undefined;
        }

        if (!resolution && !onlyCenter) {
          return center;
        }

        var viewWidth = onlyCenter ? 0 : size[0] * resolution;
        var viewHeight = onlyCenter ? 0 : size[1] * resolution;
        var shiftX = centerShift ? centerShift[0] : 0;
        var shiftY = centerShift ? centerShift[1] : 0;
        var minX = extent[0] + viewWidth / 2 + shiftX;
        var maxX = extent[2] - viewWidth / 2 + shiftX;
        var minY = extent[1] + viewHeight / 2 + shiftY;
        var maxY = extent[3] - viewHeight / 2 + shiftY; // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for

        if (minX > maxX) {
          minX = (maxX + minX) / 2;
          maxX = minX;
        }

        if (minY > maxY) {
          minY = (maxY + minY) / 2;
          maxY = minY;
        }

        var x = clamp(center[0], minX, maxX);
        var y = clamp(center[1], minY, maxY); // during an interaction, allow some overscroll

        if (isMoving && smooth && resolution) {
          var ratio = 30 * resolution;
          x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
          y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }

        return [x, y];
      }
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} [center] Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Center.
   */

  function none$1(center) {
    return center;
  }

  /**
   * @module ol/resolutionconstraint
   */
  /**
   * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
   */

  /**
   * Returns a modified resolution taking into account the viewport size and maximum
   * allowed extent.
   * @param {number} resolution Resolution
   * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
   * @param {import("./size.js").Size} viewportSize Viewport size.
   * @param {boolean} showFullExtent Whether to show the full extent.
   * @return {number} Capped resolution.
   */

  function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    var xResolution = getWidth(maxExtent) / viewportSize[0];
    var yResolution = getHeight(maxExtent) / viewportSize[1];

    if (showFullExtent) {
      return Math.min(resolution, Math.max(xResolution, yResolution));
    }

    return Math.min(resolution, Math.min(xResolution, yResolution));
  }
  /**
   * Returns a modified resolution to be between maxResolution and minResolution while
   * still allowing the value to be slightly out of bounds.
   * Note: the computation is based on the logarithm function (ln):
   *  - at 1, ln(x) is 0
   *  - above 1, ln(x) keeps increasing but at a much slower pace than x
   * The final result is clamped to prevent getting too far away from bounds.
   * @param {number} resolution Resolution.
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @return {number} Smoothed resolution.
   */


  function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    var result = Math.min(resolution, maxResolution);
    var ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;

    if (minResolution) {
      result = Math.max(result, minResolution);
      result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }

    return clamp(result, minResolution / 2, maxResolution * 2);
  }
  /**
   * @param {Array<number>} resolutions Resolutions.
   * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
   * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */


  function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
          var maxResolution = resolutions[0];
          var minResolution = resolutions[resolutions.length - 1];
          var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

          if (isMoving) {
            if (!smooth) {
              return clamp(resolution, minResolution, cappedMaxRes);
            }

            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
          }

          var capped = Math.min(cappedMaxRes, resolution);
          var z = Math.floor(linearFindNearest(resolutions, capped, direction));

          if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
            return resolutions[z + 1];
          }

          return resolutions[z];
        } else {
          return undefined;
        }
      }
    );
  }
  /**
   * @param {number} power Power.
   * @param {number} maxResolution Maximum resolution.
   * @param {number} [minResolution] Minimum resolution.
   * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
   * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */

  function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    minResolution = minResolution !== undefined ? minResolution : 0;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
          var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

          if (isMoving) {
            if (!smooth) {
              return clamp(resolution, minResolution, cappedMaxRes);
            }

            return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
          }

          var tolerance = 1e-9;
          var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
          var offset = -direction * (0.5 - tolerance) + 0.5;
          var capped = Math.min(cappedMaxRes, resolution);
          var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
          var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
          var newResolution = maxResolution / Math.pow(power, zoomLevel);
          return clamp(newResolution, minResolution, cappedMaxRes);
        } else {
          return undefined;
        }
      }
    );
  }
  /**
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @param {boolean} [smooth] If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent} [maxExtent] Maximum allowed extent.
   * @param {boolean} [showFullExtent] If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */

  function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== undefined ? smooth : true;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, isMoving) {
        if (resolution !== undefined) {
          var cappedMaxRes = maxExtent ? getViewportClampedResolution(maxResolution, maxExtent, size, showFullExtent) : maxResolution;

          if (!smooth || !isMoving) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        } else {
          return undefined;
        }
      }
    );
  }

  /**
   * @module ol/rotationconstraint
   */
  /**
   * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
   */

  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */

  function disable(rotation) {
    if (rotation !== undefined) {
      return 0;
    } else {
      return undefined;
    }
  }
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */

  function none(rotation) {
    if (rotation !== undefined) {
      return rotation;
    } else {
      return undefined;
    }
  }
  /**
   * @param {number} n N.
   * @return {Type} Rotation constraint.
   */

  function createSnapToN(n) {
    var theta = 2 * Math.PI / n;
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, isMoving) {
        if (isMoving) {
          return rotation;
        }

        if (rotation !== undefined) {
          rotation = Math.floor(rotation / theta + 0.5) * theta;
          return rotation;
        } else {
          return undefined;
        }
      }
    );
  }
  /**
   * @param {number} [tolerance] Tolerance.
   * @return {Type} Rotation constraint.
   */

  function createSnapToZero(tolerance) {
    tolerance = tolerance || toRadians(5);
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, isMoving) {
        if (isMoving) {
          return rotation;
        }

        if (rotation !== undefined) {
          if (Math.abs(rotation) <= tolerance) {
            return 0;
          } else {
            return rotation;
          }
        } else {
          return undefined;
        }
      }
    );
  }

  /**
   * @module ol/easing
   */

  /**
   * Start slow and speed up.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeIn(t) {
    return Math.pow(t, 3);
  }
  /**
   * Start fast and slow down.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */

  function easeOut(t) {
    return 1 - easeIn(1 - t);
  }
  /**
   * Start slow, speed up, and then slow down again.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */

  function inAndOut(t) {
    return 3 * t * t - 2 * t * t * t;
  }
  /**
   * Maintain a constant speed over time.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */

  function linear(t) {
    return t;
  }

  /**
   * An animation configuration
   *
   * @typedef {Object} Animation
   * @property {import("./coordinate.js").Coordinate} [sourceCenter] Source center.
   * @property {import("./coordinate.js").Coordinate} [targetCenter] Target center.
   * @property {number} [sourceResolution] Source resolution.
   * @property {number} [targetResolution] Target resolution.
   * @property {number} [sourceRotation] Source rotation.
   * @property {number} [targetRotation] Target rotation.
   * @property {import("./coordinate.js").Coordinate} [anchor] Anchor.
   * @property {number} start Start.
   * @property {number} duration Duration.
   * @property {boolean} complete Complete.
   * @property {function(number):number} easing Easing.
   * @property {function(boolean):void} callback Callback.
   */

  /**
   * @typedef {Object} Constraints
   * @property {import("./centerconstraint.js").Type} center Center.
   * @property {import("./resolutionconstraint.js").Type} resolution Resolution.
   * @property {import("./rotationconstraint.js").Type} rotation Rotation.
   */

  /**
   * @typedef {Object} FitOptions
   * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
   * the extent into. Default is the current size of the first map in the DOM that
   * uses this view, or `[100, 100]` if no such map is found.
   * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
   * cleared inside the view. Values in the array are top, right, bottom and left
   * padding.
   * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
   * get the nearest extent instead of the closest that actually fits the view.
   * @property {number} [minResolution=0] Minimum resolution that we zoom to.
   * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
   * `minResolution` is given, this property is ignored.
   * @property {number} [duration] The duration of the animation in milliseconds.
   * By default, there is no animation to the target extent.
   * @property {function(number):number} [easing] The easing function used during
   * the animation (defaults to {@link module:ol/easing.inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   * @property {function(boolean):void} [callback] Function called when the view is in
   * its final position. The callback will be called with `true` if the animation
   * series completed on its own or `false` if it was cancelled.
   */

  /**
   * @typedef {Object} ViewOptions
   * @property {import("./coordinate.js").Coordinate} [center] The initial center for
   * the view. If a user projection is not set, the coordinate system for the center is
   * specified with the `projection` option. Layer sources will not be fetched if this
   * is not set, but the center can be set later with {@link #setCenter}.
   * @property {boolean|number} [constrainRotation=true] Rotation constraint.
   * `false` means no constraint. `true` means no constraint, but snap to zero
   * near zero. A number constrains the rotation to that number of values. For
   * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
   * @property {boolean} [enableRotation=true] Enable rotation.
   * If `false`, a rotation constraint that always sets the rotation to zero is
   * used. The `constrainRotation` option has no effect if `enableRotation` is
   * `false`.
   * @property {import("./extent.js").Extent} [extent] The extent that constrains the
   * view, in other words, nothing outside of this extent can be visible on the map.
   * @property {boolean} [constrainOnlyCenter=false] If true, the extent
   * constraint will only apply to the view center and not the whole extent.
   * @property {boolean} [smoothExtentConstraint=true] If true, the extent
   * constraint will be applied smoothly, i.e. allow the view to go slightly outside
   * of the given `extent`.
   * @property {number} [maxResolution] The maximum resolution used to determine
   * the resolution constraint. It is used together with `minResolution` (or
   * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
   * that the projection's validity extent fits in a 256x256 px tile. If the
   * projection is Spherical Mercator (the default) then `maxResolution` defaults
   * to `40075016.68557849 / 256 = 156543.03392804097`.
   * @property {number} [minResolution] The minimum resolution used to determine
   * the resolution constraint.  It is used together with `maxResolution` (or
   * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
   * zoom levels (with a factor of 2). If the projection is Spherical Mercator
   * (the default) then `minResolution` defaults to
   * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
   * @property {number} [maxZoom=28] The maximum zoom level used to determine the
   * resolution constraint. It is used together with `minZoom` (or
   * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
   * provided, it is given precedence over `maxZoom`.
   * @property {number} [minZoom=0] The minimum zoom level used to determine the
   * resolution constraint. It is used together with `maxZoom` (or
   * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
   * provided, it is given precedence over `minZoom`.
   * @property {boolean} [multiWorld=false] If `false` the view is constrained so
   * only one world is visible, and you cannot pan off the edge.  If `true` the map
   * may show multiple worlds at low zoom levels.  Only used if the `projection` is
   * global.  Note that if `extent` is also provided it is given precedence.
   * @property {boolean} [constrainResolution=false] If true, the view will always
   * animate to the closest zoom level after an interaction; false means
   * intermediary zoom levels are allowed.
   * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
   * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
   * the given resolution or zoom bounds.
   * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
   * show the full configured extent. By default, when a view is configured with an
   * extent, users will not be able to zoom out so the viewport exceeds the extent in
   * either dimension. This means the full extent may not be visible if the viewport
   * is taller or wider than the aspect ratio of the configured extent. If
   * showFullExtent is true, the user will be able to zoom out so that the viewport
   * exceeds the height or width of the configured extent, but not both, allowing the
   * full extent to be shown.
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
   * projection. The default is Spherical Mercator.
   * @property {number} [resolution] The initial resolution for the view. The
   * units are `projection` units per pixel (e.g. meters per pixel). An
   * alternative to setting this is to set `zoom`. Layer sources will not be
   * fetched if neither this nor `zoom` are defined, but they can be set later
   * with {@link #setZoom} or {@link #setResolution}.
   * @property {Array<number>} [resolutions] Resolutions that determine the
   * zoom levels if specified. The index in the array corresponds to the zoom level,
   * therefore the resolution values have to be in descending order. It also constrains
   * the resolution by the minimum and maximum value. If set the `maxResolution`,
   * `minResolution`, `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
   * @property {number} [rotation=0] The initial rotation for the view in radians
   * (positive rotation clockwise, 0 means North).
   * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
   * level used to calculate the initial resolution for the view.
   * @property {number} [zoomFactor=2] The zoom factor used to compute the
   * corresponding resolution.
   * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from
   * that content. The order of the values is top, right, bottom, left.
   */

  /**
   * @typedef {Object} AnimationOptions
   * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
   * the animation.
   * @property {number} [zoom] The zoom level of the view at the end of the
   * animation. This takes precedence over `resolution`.
   * @property {number} [resolution] The resolution of the view at the end
   * of the animation.  If `zoom` is also provided, this option will be ignored.
   * @property {number} [rotation] The rotation of the view at the end of
   * the animation.
   * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
   * during a rotation or resolution animation.
   * @property {number} [duration=1000] The duration of the animation in milliseconds.
   * @property {function(number):number} [easing] The easing function used
   * during the animation (defaults to {@link module:ol/easing.inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   */

  /**
   * @typedef {Object} State
   * @property {import("./coordinate.js").Coordinate} center Center.
   * @property {import("./proj/Projection.js").default} projection Projection.
   * @property {number} resolution Resolution.
   * @property {import("./coordinate.js").Coordinate} [nextCenter] The next center during an animation series.
   * @property {number} [nextResolution] The next resolution during an animation series.
   * @property {number} [nextRotation] The next rotation during an animation series.
   * @property {number} rotation Rotation.
   * @property {number} zoom Zoom.
   */

  /**
   * Default min zoom level for the map view.
   * @type {number}
   */

  var DEFAULT_MIN_ZOOM = 0;
  /**
   * @typedef {import("./ObjectEventType").Types|'change:center'|'change:resolution'|'change:rotation'} ViewObjectEventTypes
   */

  /***
   * @template Return
   * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
   *   import("./Observable").OnSignature<ViewObjectEventTypes, import("./Object").ObjectEvent, Return> &
   *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|ViewObjectEventTypes, Return>} ViewOnSignature
   */

  /**
   * @classdesc
   * A View object represents a simple 2D view of the map.
   *
   * This is the object to act upon to change the center, resolution,
   * and rotation of the map.
   *
   * A View has a `projection`. The projection determines the
   * coordinate system of the center, and its units determine the units of the
   * resolution (projection units per pixel). The default projection is
   * Web Mercator (EPSG:3857).
   *
   * ### The view states
   *
   * A View is determined by three states: `center`, `resolution`,
   * and `rotation`. Each state has a corresponding getter and setter, e.g.
   * `getCenter` and `setCenter` for the `center` state.
   *
   * The `zoom` state is actually not saved on the view: all computations
   * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
   * methods are available, as well as `getResolutionForZoom` and
   * `getZoomForResolution` to switch from one system to the other.
   *
   * ### The constraints
   *
   * `setCenter`, `setResolution` and `setRotation` can be used to change the
   * states of the view, but any constraint defined in the constructor will
   * be applied along the way.
   *
   * A View object can have a *resolution constraint*, a *rotation constraint*
   * and a *center constraint*.
   *
   * The *resolution constraint* typically restricts min/max values and
   * snaps to specific resolutions. It is determined by the following
   * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
   * If `resolutions` is set, the other three options are ignored. See
   * documentation for each option for more information. By default, the view
   * only has a min/max restriction and allow intermediary zoom levels when
   * pinch-zooming for example.
   *
   * The *rotation constraint* snaps to specific angles. It is determined
   * by the following options: `enableRotation` and `constrainRotation`.
   * By default rotation is allowed and its value is snapped to zero when approaching the
   * horizontal.
   *
   * The *center constraint* is determined by the `extent` option. By
   * default the view center is not constrained at all.
   *
   * ### Changing the view state
   *
   * It is important to note that `setZoom`, `setResolution`, `setCenter` and
   * `setRotation` are subject to the above mentioned constraints. As such, it
   * may sometimes not be possible to know in advance the resulting state of the
   * View. For example, calling `setResolution(10)` does not guarantee that
   * `getResolution()` will return `10`.
   *
   * A consequence of this is that, when applying a delta on the view state, one
   * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
   * rather than the corresponding setters. This will let view do its internal
   * computations. Besides, the `adjust*` methods also take an `anchor`
   * argument which allows specifying an origin for the transformation.
   *
   * ### Interacting with the view
   *
   * View constraints are usually only applied when the view is *at rest*, meaning that
   * no interaction or animation is ongoing. As such, if the user puts the view in a
   * state that is not equivalent to a constrained one (e.g. rotating the view when
   * the snap angle is 0), an animation will be triggered at the interaction end to
   * put back the view to a stable state;
   *
   * @api
   */

  var View = /*#__PURE__*/function (_BaseObject) {
    _inherits(View, _BaseObject);

    var _super = _createSuper(View);

    /**
     * @param {ViewOptions} [options] View options.
     */
    function View(options) {
      var _this;

      _classCallCheck(this, View);

      _this = _super.call(this);
      /***
       * @type {ViewOnSignature<import("./events").EventsKey>}
       */

      _this.on;
      /***
       * @type {ViewOnSignature<import("./events").EventsKey>}
       */

      _this.once;
      /***
       * @type {ViewOnSignature<void>}
       */

      _this.un;
      options = Object.assign({}, options);
      /**
       * @private
       * @type {Array<number>}
       */

      _this.hints_ = [0, 0];
      /**
       * @private
       * @type {Array<Array<Animation>>}
       */

      _this.animations_ = [];
      /**
       * @private
       * @type {number|undefined}
       */

      _this.updateAnimationKey_;
      /**
       * @private
       * @const
       * @type {import("./proj/Projection.js").default}
       */

      _this.projection_ = createProjection(options.projection, 'EPSG:3857');
      /**
       * @private
       * @type {import("./size.js").Size}
       */

      _this.viewportSize_ = [100, 100];
      /**
       * @private
       * @type {import("./coordinate.js").Coordinate|undefined}
       */

      _this.targetCenter_ = null;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.targetResolution_;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.targetRotation_;
      /**
       * @private
       * @type {import("./coordinate.js").Coordinate}
       */

      _this.nextCenter_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.nextResolution_;
      /**
       * @private
       * @type {number}
       */

      _this.nextRotation_;
      /**
       * @private
       * @type {import("./coordinate.js").Coordinate|undefined}
       */

      _this.cancelAnchor_ = undefined;

      if (options.projection) {
        disableCoordinateWarning();
      }

      if (options.center) {
        options.center = fromUserCoordinate(options.center, _this.projection_);
      }

      if (options.extent) {
        options.extent = fromUserExtent(options.extent, _this.projection_);
      }

      _this.applyOptions_(options);

      return _this;
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */


    _createClass(View, [{
      key: "applyOptions_",
      value: function applyOptions_(options) {
        var properties = Object.assign({}, options);

        for (var key in ViewProperty) {
          delete properties[key];
        }

        this.setProperties(properties, true);
        var resolutionConstraintInfo = createResolutionConstraint(options);
        /**
         * @private
         * @type {number}
         */

        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        /**
         * @private
         * @type {number}
         */

        this.minResolution_ = resolutionConstraintInfo.minResolution;
        /**
         * @private
         * @type {number}
         */

        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        /**
         * @private
         * @type {Array<number>|undefined}
         */

        this.resolutions_ = options.resolutions;
        /**
         * @type {Array<number>|undefined}
         * @private
         */

        this.padding_ = options.padding;
        /**
         * @private
         * @type {number}
         */

        this.minZoom_ = resolutionConstraintInfo.minZoom;
        var centerConstraint = createCenterConstraint(options);
        var resolutionConstraint = resolutionConstraintInfo.constraint;
        var rotationConstraint = createRotationConstraint(options);
        /**
         * @private
         * @type {Constraints}
         */

        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== undefined ? options.rotation : 0);
        this.setCenterInternal(options.center !== undefined ? options.center : null);

        if (options.resolution !== undefined) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== undefined) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */

    }, {
      key: "padding",
      get: function get() {
        return this.padding_;
      },
      set: function set(padding) {
        var oldPadding = this.padding_;
        this.padding_ = padding;
        var center = this.getCenter();

        if (center) {
          var newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          var resolution = this.getResolution();
          var offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          var offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */

    }, {
      key: "getUpdatedOptions_",
      value: function getUpdatedOptions_(newOptions) {
        var options = this.getProperties(); // preserve resolution (or zoom)

        if (options.resolution !== undefined) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        } // preserve center


        options.center = this.getCenterInternal(); // preserve rotation

        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */

    }, {
      key: "animate",
      value: function animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }

        var args = new Array(arguments.length);

        for (var i = 0; i < args.length; ++i) {
          var options = arguments[i];

          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(options.center, this.getProjection());
          }

          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
          }

          args[i] = options;
        }

        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */

    }, {
      key: "animateInternal",
      value: function animateInternal(var_args) {
        var animationCount = arguments.length;
        var callback;

        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
          callback = arguments[animationCount - 1];
          --animationCount;
        }

        var i = 0;

        for (; i < animationCount && !this.isDef(); ++i) {
          // if view properties are not yet set, shortcut to the final state
          var state = arguments[i];

          if (state.center) {
            this.setCenterInternal(state.center);
          }

          if (state.zoom !== undefined) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }

          if (state.rotation !== undefined) {
            this.setRotation(state.rotation);
          }
        }

        if (i === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }

          return;
        }

        var start = Date.now();
        var center = this.targetCenter_.slice();
        var resolution = this.targetResolution_;
        var rotation = this.targetRotation_;
        var series = [];

        for (; i < animationCount; ++i) {
          var options =
          /** @type {AnimationOptions} */
          arguments[i];
          var animation = {
            start: start,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== undefined ? options.duration : 1000,
            easing: options.easing || inAndOut,
            callback: callback
          };

          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }

          if (options.zoom !== undefined) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }

          if (options.rotation !== undefined) {
            animation.sourceRotation = rotation;
            var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          } // check if animation is a no-op


          if (isNoopAnimation(animation)) {
            animation.complete = true; // we still push it onto the series for callback handling
          } else {
            start += animation.duration;
          }

          series.push(animation);
        }

        this.animations_.push(series);
        this.setHint(ViewHint.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */

    }, {
      key: "getAnimating",
      value: function getAnimating() {
        return this.hints_[ViewHint.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */

    }, {
      key: "getInteracting",
      value: function getInteracting() {
        return this.hints_[ViewHint.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */

    }, {
      key: "cancelAnimations",
      value: function cancelAnimations() {
        this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
        var anchor;

        for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
          var series = this.animations_[i];

          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }

          if (!anchor) {
            for (var j = 0, jj = series.length; j < jj; ++j) {
              var animation = series[j];

              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }

        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */

    }, {
      key: "updateAnimations_",
      value: function updateAnimations_() {
        if (this.updateAnimationKey_ !== undefined) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = undefined;
        }

        if (!this.getAnimating()) {
          return;
        }

        var now = Date.now();
        var more = false;

        for (var i = this.animations_.length - 1; i >= 0; --i) {
          var series = this.animations_[i];
          var seriesComplete = true;

          for (var j = 0, jj = series.length; j < jj; ++j) {
            var animation = series[j];

            if (animation.complete) {
              continue;
            }

            var elapsed = now - animation.start;
            var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }

            var progress = animation.easing(fraction);

            if (animation.sourceCenter) {
              var x0 = animation.sourceCenter[0];
              var y0 = animation.sourceCenter[1];
              var x1 = animation.targetCenter[0];
              var y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              var x = x0 + progress * (x1 - x0);
              var y = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x, y];
            }

            if (animation.sourceResolution && animation.targetResolution) {
              var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

              if (animation.anchor) {
                var size = this.getViewportSize_(this.getRotation());
                var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
              }

              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }

            if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
              var rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

              if (animation.anchor) {
                var constrainedRotation = this.constraints_.rotation(rotation, true);
                this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
              }

              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }

            this.applyTargetState_(true);
            more = true;

            if (!animation.complete) {
              break;
            }
          }

          if (seriesComplete) {
            this.animations_[i] = null;
            this.setHint(ViewHint.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            var callback = series[0].callback;

            if (callback) {
              animationCallback(callback, true);
            }
          }
        } // prune completed series


        this.animations_ = this.animations_.filter(Boolean);

        if (more && this.updateAnimationKey_ === undefined) {
          this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */

    }, {
      key: "calculateCenterRotate",
      value: function calculateCenterRotate(rotation, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();

        if (currentCenter !== undefined) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate$1(center, rotation - this.getRotation());
          add(center, anchor);
        }

        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */

    }, {
      key: "calculateCenterZoom",
      value: function calculateCenterZoom(resolution, anchor) {
        var center;
        var currentCenter = this.getCenterInternal();
        var currentResolution = this.getResolution();

        if (currentCenter !== undefined && currentResolution !== undefined) {
          var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }

        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */

    }, {
      key: "getViewportSize_",
      value: function getViewportSize_(rotation) {
        var size = this.viewportSize_;

        if (rotation) {
          var w = size[0];
          var h = size[1];
          return [Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)), Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))];
        } else {
          return size;
        }
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */

    }, {
      key: "setViewportSize",
      value: function setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];

        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */

    }, {
      key: "getCenter",
      value: function getCenter() {
        var center = this.getCenterInternal();

        if (!center) {
          return center;
        }

        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */

    }, {
      key: "getCenterInternal",
      value: function getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */

    }, {
      key: "getConstraints",
      value: function getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */

    }, {
      key: "getConstrainResolution",
      value: function getConstrainResolution() {
        return this.get('constrainResolution');
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */

    }, {
      key: "getHints",
      value: function getHints(hints) {
        if (hints !== undefined) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        } else {
          return this.hints_.slice();
        }
      }
      /**
       * Calculate the extent for the current view state and the passed size.
       * The size is the pixel dimensions of the box into which the calculated extent
       * should fit. In most cases you want to get the extent of the entire map,
       * that is `map.getSize()`.
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
       * of the map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */

    }, {
      key: "calculateExtent",
      value: function calculateExtent(size) {
        var extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */

    }, {
      key: "calculateExtentInternal",
      value: function calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        var center =
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal();
        assert(center, 1); // The view center is not defined

        var resolution =
        /** @type {!number} */
        this.getResolution();
        assert(resolution !== undefined, 2); // The view resolution is not defined

        var rotation =
        /** @type {!number} */
        this.getRotation();
        assert(rotation !== undefined, 3); // The view rotation is not defined

        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */

    }, {
      key: "getMaxResolution",
      value: function getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */

    }, {
      key: "getMinResolution",
      value: function getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */

    }, {
      key: "getMaxZoom",
      value: function getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */

    }, {
      key: "setMaxZoom",
      value: function setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
          maxZoom: zoom
        }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */

    }, {
      key: "getMinZoom",
      value: function getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */

    }, {
      key: "setMinZoom",
      value: function setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({
          minZoom: zoom
        }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */

    }, {
      key: "setConstrainResolution",
      value: function setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({
          constrainResolution: enabled
        }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */

    }, {
      key: "getProjection",
      value: function getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */

    }, {
      key: "getResolution",
      value: function getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */

    }, {
      key: "getResolutions",
      value: function getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */

    }, {
      key: "getResolutionForExtent",
      value: function getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), size);
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */

    }, {
      key: "getResolutionForExtentInternal",
      value: function getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        var xResolution = getWidth(extent) / size[0];
        var yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */

    }, {
      key: "getResolutionForValueFunction",
      value: function getResolutionForValueFunction(power) {
        power = power || 2;
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function (value) {
            var resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */

    }, {
      key: "getRotation",
      value: function getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */

    }, {
      key: "getValueForResolutionFunction",
      value: function getValueForResolutionFunction(power) {
        var logPower = Math.log(power || 2);
        var maxResolution = this.getConstrainedResolution(this.maxResolution_);
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function (resolution) {
            var value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */

    }, {
      key: "getViewportSizeMinusPadding_",
      value: function getViewportSizeMinusPadding_(rotation) {
        var size = this.getViewportSize_(rotation);
        var padding = this.padding_;

        if (padding) {
          size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];
        }

        return size;
      }
      /**
       * @return {State} View state.
       */

    }, {
      key: "getState",
      value: function getState() {
        var projection = this.getProjection();
        var resolution = this.getResolution();
        var rotation = this.getRotation();
        var center =
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal();
        var padding = this.padding_;

        if (padding) {
          var reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
        }

        return {
          center: center.slice(0),
          projection: projection !== undefined ? projection : null,
          resolution: resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation: rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */

    }, {
      key: "getZoom",
      value: function getZoom() {
        var zoom;
        var resolution = this.getResolution();

        if (resolution !== undefined) {
          zoom = this.getZoomForResolution(resolution);
        }

        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */

    }, {
      key: "getZoomForResolution",
      value: function getZoomForResolution(resolution) {
        var offset = this.minZoom_ || 0;
        var max, zoomFactor;

        if (this.resolutions_) {
          var nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];

          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }

        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */

    }, {
      key: "getResolutionForZoom",
      value: function getResolutionForZoom(zoom) {
        if (this.resolutions_) {
          if (this.resolutions_.length <= 1) {
            return 0;
          }

          var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
          var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        } else {
          return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
        }
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */

    }, {
      key: "fit",
      value: function fit(geometryOrExtent, options) {
        /** @type {import("./geom/SimpleGeometry.js").default} */
        var geometry;
        assert(Array.isArray(geometryOrExtent) || typeof
        /** @type {?} */
        geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`

        if (Array.isArray(geometryOrExtent)) {
          assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`

          var extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === 'Circle') {
          var _extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());

          geometry = fromExtent(_extent);
          geometry.rotate(this.getRotation(), getCenter(_extent));
        } else {
          var userProjection = getUserProjection();

          if (userProjection) {
            geometry =
            /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }

        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */

    }, {
      key: "rotatedExtentForGeometry",
      value: function rotatedExtentForGeometry(geometry) {
        var rotation = this.getRotation();
        var cosAngle = Math.cos(rotation);
        var sinAngle = Math.sin(-rotation);
        var coords = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        var minRotX = +Infinity;
        var minRotY = +Infinity;
        var maxRotX = -Infinity;
        var maxRotY = -Infinity;

        for (var i = 0, ii = coords.length; i < ii; i += stride) {
          var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }

        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */

    }, {
      key: "fitInternal",
      value: function fitInternal(geometry, options) {
        options = options || {};
        var size = options.size;

        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }

        var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
        var nearest = options.nearest !== undefined ? options.nearest : false;
        var minResolution;

        if (options.minResolution !== undefined) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== undefined) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }

        var rotatedExtent = this.rotatedExtentForGeometry(geometry); // calculate resolution

        var resolution = this.getResolutionForExtentInternal(rotatedExtent, [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center

        var rotation = this.getRotation();
        var sinAngle = Math.sin(rotation);
        var cosAngle = Math.cos(rotation);
        var centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        var centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        var centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        var center = this.getConstrainedCenter([centerX, centerY], resolution);
        var callback = options.callback ? options.callback : VOID;

        if (options.duration !== undefined) {
          this.animateInternal({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
          }, callback);
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */

    }, {
      key: "centerOn",
      value: function centerOn(coordinate, size, position) {
        this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */

    }, {
      key: "centerOnInternal",
      value: function centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */

    }, {
      key: "calculateCenterShift",
      value: function calculateCenterShift(center, resolution, rotation, size) {
        var centerShift;
        var padding = this.padding_;

        if (padding && center) {
          var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
          centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];
        }

        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */

    }, {
      key: "isDef",
      value: function isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== undefined;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */

    }, {
      key: "adjustCenter",
      value: function adjustCenter(deltaCoordinates) {
        var center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */

    }, {
      key: "adjustCenterInternal",
      value: function adjustCenterInternal(deltaCoordinates) {
        var center = this.targetCenter_;
        this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */

    }, {
      key: "adjustResolution",
      value: function adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */

    }, {
      key: "adjustResolutionInternal",
      value: function adjustResolutionInternal(ratio, anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var size = this.getViewportSize_(this.getRotation());
        var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);

        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }

        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */

    }, {
      key: "adjustZoom",
      value: function adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */

    }, {
      key: "adjustRotation",
      value: function adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }

        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */

    }, {
      key: "adjustRotationInternal",
      value: function adjustRotationInternal(delta, anchor) {
        var isMoving = this.getAnimating() || this.getInteracting();
        var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);

        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }

        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */

    }, {
      key: "setCenter",
      value: function setCenter(center) {
        this.setCenterInternal(center ? fromUserCoordinate(center, this.getProjection()) : center);
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */

    }, {
      key: "setCenterInternal",
      value: function setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */

    }, {
      key: "setHint",
      value: function setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */

    }, {
      key: "setResolution",
      value: function setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */

    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */

    }, {
      key: "setZoom",
      value: function setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */

    }, {
      key: "applyTargetState_",
      value: function applyTargetState_(doNotCancelAnims, forceMoving) {
        var isMoving = this.getAnimating() || this.getInteracting() || forceMoving; // compute rotation

        var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

        if (this.get(ViewProperty.ROTATION) !== newRotation) {
          this.set(ViewProperty.ROTATION, newRotation);
        }

        if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
          this.set(ViewProperty.RESOLUTION, newResolution);
          this.set('zoom', this.getZoom(), true);
        }

        if (!newCenter || !this.get(ViewProperty.CENTER) || !equals$1(this.get(ViewProperty.CENTER), newCenter)) {
          this.set(ViewProperty.CENTER, newCenter);
        }

        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }

        this.cancelAnchor_ = undefined;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */

    }, {
      key: "resolveConstraints",
      value: function resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== undefined ? duration : 200;
        var direction = resolutionDirection || 0;
        var newRotation = this.constraints_.rotation(this.targetRotation_);
        var size = this.getViewportSize_(newRotation);
        var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
        var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }

        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
        this.cancelAnchor_ = undefined;

        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals$1(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }

          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration: duration,
            easing: easeOut,
            anchor: anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */

    }, {
      key: "beginInteraction",
      value: function beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */

    }, {
      key: "endInteraction",
      value: function endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */

    }, {
      key: "endInteractionInternal",
      value: function endInteractionInternal(duration, resolutionDirection, anchor) {
        this.setHint(ViewHint.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */

    }, {
      key: "getConstrainedCenter",
      value: function getConstrainedCenter(targetCenter, targetResolution) {
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(targetCenter, targetResolution || this.getResolution(), size);
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */

    }, {
      key: "getConstrainedZoom",
      value: function getConstrainedZoom(targetZoom, direction) {
        var targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(this.getConstrainedResolution(targetRes, direction));
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */

    }, {
      key: "getConstrainedResolution",
      value: function getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        var size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    }]);

    return View;
  }(BaseObject);
  /**
   * @param {Function} callback Callback.
   * @param {*} returnValue Return value.
   */


  function animationCallback(callback, returnValue) {
    setTimeout(function () {
      callback(returnValue);
    }, 0);
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./centerconstraint.js").Type} The constraint.
   */


  function createCenterConstraint(options) {
    if (options.extent !== undefined) {
      var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
      return createExtent(options.extent, options.constrainOnlyCenter, smooth);
    }

    var projection = createProjection(options.projection, 'EPSG:3857');

    if (options.multiWorld !== true && projection.isGlobal()) {
      var extent = projection.getExtent().slice();
      extent[0] = -Infinity;
      extent[2] = Infinity;
      return createExtent(extent, false, false);
    }

    return none$1;
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
   *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
   */

  function createResolutionConstraint(options) {
    var resolutionConstraint;
    var maxResolution;
    var minResolution; // TODO: move these to be ol constants
    // see https://github.com/openlayers/openlayers/issues/2076

    var defaultMaxZoom = 28;
    var defaultZoomFactor = 2;
    var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
    var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
    var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
    var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
    var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
    var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
    var projection = createProjection(options.projection, 'EPSG:3857');
    var projExtent = projection.getExtent();
    var constrainOnlyCenter = options.constrainOnlyCenter;
    var extent = options.extent;

    if (!multiWorld && !extent && projection.isGlobal()) {
      constrainOnlyCenter = false;
      extent = projExtent;
    }

    if (options.resolutions !== undefined) {
      var resolutions = options.resolutions;
      maxResolution = resolutions[minZoom];
      minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];

      if (options.constrainResolution) {
        resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
      } else {
        resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
      }
    } else {
      // calculate the default min and max resolution
      var size = !projExtent ? // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit() : Math.max(getWidth(projExtent), getHeight(projExtent));
      var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
      var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

      maxResolution = options.maxResolution;

      if (maxResolution !== undefined) {
        minZoom = 0;
      } else {
        maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
      } // user provided minResolution takes precedence


      minResolution = options.minResolution;

      if (minResolution === undefined) {
        if (options.maxZoom !== undefined) {
          if (options.maxResolution !== undefined) {
            minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
          } else {
            minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
          }
        } else {
          minResolution = defaultMinResolution;
        }
      } // given discrete zoom levels, minResolution may be different than provided


      maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

      if (options.constrainResolution) {
        resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
      } else {
        resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
      }
    }

    return {
      constraint: resolutionConstraint,
      maxResolution: maxResolution,
      minResolution: minResolution,
      minZoom: minZoom,
      zoomFactor: zoomFactor
    };
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./rotationconstraint.js").Type} Rotation constraint.
   */

  function createRotationConstraint(options) {
    var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

    if (enableRotation) {
      var constrainRotation = options.constrainRotation;

      if (constrainRotation === undefined || constrainRotation === true) {
        return createSnapToZero();
      } else if (constrainRotation === false) {
        return none;
      } else if (typeof constrainRotation === 'number') {
        return createSnapToN(constrainRotation);
      } else {
        return none;
      }
    } else {
      return disable;
    }
  }
  /**
   * Determine if an animation involves no view change.
   * @param {Animation} animation The animation.
   * @return {boolean} The animation involves no view change.
   */

  function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
      if (!equals$1(animation.sourceCenter, animation.targetCenter)) {
        return false;
      }
    }

    if (animation.sourceResolution !== animation.targetResolution) {
      return false;
    }

    if (animation.sourceRotation !== animation.targetRotation) {
      return false;
    }

    return true;
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @return {import("./coordinate.js").Coordinate} Shifted center.
   */

  function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    // calculate rotated position
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

    sinAngle = -sinAngle; // go back to original rotation

    var centerX = rotX * cosAngle - rotY * sinAngle;
    var centerY = rotY * cosAngle + rotX * sinAngle;
    return [centerX, centerY];
  }

  /**
   * @typedef {Object} Options
   * @property {HTMLElement} [element] The element is the control's
   * container element. This only needs to be specified if you're developing
   * a custom control.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want
   * the control to be rendered outside of the map's viewport.
   */

  /**
   * @classdesc
   * A control is a visible widget with a DOM element in a fixed position on the
   * screen. They can involve user input (buttons), or be informational only;
   * the position is determined using CSS. By default these are placed in the
   * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
   * any outside DOM element.
   *
   * This is the base class for controls. You can use it for simple custom
   * controls by creating the element with listeners, creating an instance:
   * ```js
   * const myControl = new Control({element: myElement});
   * ```
   * and then adding this to the map.
   *
   * The main advantage of having this as a control rather than a simple separate
   * DOM element is that preventing propagation is handled for you. Controls
   * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
   *
   * You can also extend this base for your own control class. See
   * examples/custom-controls for an example of how to do this.
   *
   * @api
   */

  var Control = /*#__PURE__*/function (_BaseObject) {
    _inherits(Control, _BaseObject);

    var _super = _createSuper(Control);

    /**
     * @param {Options} options Control options.
     */
    function Control(options) {
      var _this;

      _classCallCheck(this, Control);

      _this = _super.call(this);
      var element = options.element;

      if (element && !options.target && !element.style.pointerEvents) {
        element.style.pointerEvents = 'auto';
      }
      /**
       * @protected
       * @type {HTMLElement}
       */


      _this.element = element ? element : null;
      /**
       * @private
       * @type {HTMLElement}
       */

      _this.target_ = null;
      /**
       * @private
       * @type {import("../Map.js").default|null}
       */

      _this.map_ = null;
      /**
       * @protected
       * @type {!Array<import("../events.js").EventsKey>}
       */

      _this.listenerKeys = [];

      if (options.render) {
        _this.render = options.render;
      }

      if (options.target) {
        _this.setTarget(options.target);
      }

      return _this;
    }
    /**
     * Clean up.
     */


    _createClass(Control, [{
      key: "disposeInternal",
      value: function disposeInternal() {
        removeNode$1(this.element);

        _get(_getPrototypeOf(Control.prototype), "disposeInternal", this).call(this);
      }
      /**
       * Get the map associated with this control.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */

    }, {
      key: "getMap",
      value: function getMap() {
        return this.map_;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Pass `null` to just remove the control from the current map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */

    }, {
      key: "setMap",
      value: function setMap(map) {
        if (this.map_) {
          removeNode$1(this.element);
        }

        for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this.listenerKeys[i]);
        }

        this.listenerKeys.length = 0;
        this.map_ = map;

        if (map) {
          var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);

          if (this.render !== VOID) {
            this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
          }

          map.render();
        }
      }
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */

    }, {
      key: "render",
      value: function render(mapEvent) {}
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */

    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
      }
    }]);

    return Control;
  }(BaseObject);

  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-attribution'] CSS class name.
   * @property {HTMLElement|string} [target] Specify a target if you
   * want the control to be rendered outside of the map's
   * viewport.
   * @property {boolean} [collapsible] Specify if attributions can
   * be collapsed. If not specified, sources control this behavior with their
   * `attributionsCollapsible` setting.
   * @property {boolean} [collapsed=true] Specify if attributions should
   * be collapsed at startup.
   * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
   * @property {string|HTMLElement} [label='i'] Text label to use for the
   * collapsed attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [expandClassName=className + '-expand'] CSS class name for the
   * collapsed attributions button.
   * @property {string|HTMLElement} [collapseLabel=''] Text label to use
   * for the expanded attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
   * expanded attributions button.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   */

  /**
   * @classdesc
   * Control to show all the attributions associated with the layer sources
   * in the map. This control is one of the default controls included in maps.
   * By default it will show in the bottom right portion of the map, but this can
   * be changed by using a css selector for `.ol-attribution`.
   *
   * @api
   */

  var Attribution = /*#__PURE__*/function (_Control) {
    _inherits(Attribution, _Control);

    var _super = _createSuper(Attribution);

    /**
     * @param {Options} [options] Attribution options.
     */
    function Attribution(options) {
      var _this;

      _classCallCheck(this, Attribution);

      options = options ? options : {};
      _this = _super.call(this, {
        element: document.createElement('div'),
        render: options.render,
        target: options.target
      });
      /**
       * @private
       * @type {HTMLElement}
       */

      _this.ulElement_ = document.createElement('ul');
      /**
       * @private
       * @type {boolean}
       */

      _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
      /**
       * @private
       * @type {boolean}
       */

      _this.userCollapsed_ = _this.collapsed_;
      /**
       * @private
       * @type {boolean}
       */

      _this.overrideCollapsible_ = options.collapsible !== undefined;
      /**
       * @private
       * @type {boolean}
       */

      _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

      if (!_this.collapsible_) {
        _this.collapsed_ = false;
      }

      var className = options.className !== undefined ? options.className : 'ol-attribution';
      var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
      var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
      var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : "\u203A";
      var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collapse';

      if (typeof collapseLabel === 'string') {
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.collapseLabel_ = document.createElement('span');
        _this.collapseLabel_.textContent = collapseLabel;
        _this.collapseLabel_.className = collapseClassName;
      } else {
        _this.collapseLabel_ = collapseLabel;
      }

      var label = options.label !== undefined ? options.label : 'i';

      if (typeof label === 'string') {
        /**
         * @private
         * @type {HTMLElement}
         */
        _this.label_ = document.createElement('span');
        _this.label_.textContent = label;
        _this.label_.className = expandClassName;
      } else {
        _this.label_ = label;
      }

      var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
      /**
       * @private
       * @type {HTMLElement}
       */

      _this.toggleButton_ = document.createElement('button');

      _this.toggleButton_.setAttribute('type', 'button');

      _this.toggleButton_.setAttribute('aria-expanded', String(!_this.collapsed_));

      _this.toggleButton_.title = tipLabel;

      _this.toggleButton_.appendChild(activeLabel);

      _this.toggleButton_.addEventListener(EventType.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this)), false);

      var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
      var element = _this.element;
      element.className = cssClasses;
      element.appendChild(_this.toggleButton_);
      element.appendChild(_this.ulElement_);
      /**
       * A list of currently rendered resolutions.
       * @type {Array<string>}
       * @private
       */

      _this.renderedAttributions_ = [];
      /**
       * @private
       * @type {boolean}
       */

      _this.renderedVisible_ = true;
      return _this;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */


    _createClass(Attribution, [{
      key: "collectSourceAttributions_",
      value: function collectSourceAttributions_(frameState) {
        /**
         * Used to determine if an attribution already exists.
         * @type {!Object<string, boolean>}
         */
        var lookup = {};
        /**
         * A list of visible attributions.
         * @type {Array<string>}
         */

        var visibleAttributions = [];
        var collapsible = true;
        var layerStatesArray = frameState.layerStatesArray;

        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
          var layerState = layerStatesArray[i];

          if (!inView(layerState, frameState.viewState)) {
            continue;
          }

          var source =
          /** @type {import("../layer/Layer.js").default} */
          layerState.layer.getSource();

          if (!source) {
            continue;
          }

          var attributionGetter = source.getAttributions();

          if (!attributionGetter) {
            continue;
          }

          var attributions = attributionGetter(frameState);

          if (!attributions) {
            continue;
          }

          collapsible = collapsible && source.getAttributionsCollapsible() !== false;

          if (Array.isArray(attributions)) {
            for (var j = 0, jj = attributions.length; j < jj; ++j) {
              if (!(attributions[j] in lookup)) {
                visibleAttributions.push(attributions[j]);
                lookup[attributions[j]] = true;
              }
            }
          } else {
            if (!(attributions in lookup)) {
              visibleAttributions.push(attributions);
              lookup[attributions] = true;
            }
          }
        }

        if (!this.overrideCollapsible_) {
          this.setCollapsible(collapsible);
        }

        return visibleAttributions;
      }
      /**
       * @private
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "updateElement_",
      value: function updateElement_(frameState) {
        if (!frameState) {
          if (this.renderedVisible_) {
            this.element.style.display = 'none';
            this.renderedVisible_ = false;
          }

          return;
        }

        var attributions = this.collectSourceAttributions_(frameState);
        var visible = attributions.length > 0;

        if (this.renderedVisible_ != visible) {
          this.element.style.display = visible ? '' : 'none';
          this.renderedVisible_ = visible;
        }

        if (equals$3(attributions, this.renderedAttributions_)) {
          return;
        }

        removeChildren(this.ulElement_); // append the attributions

        for (var i = 0, ii = attributions.length; i < ii; ++i) {
          var element = document.createElement('li');
          element.innerHTML = attributions[i];
          this.ulElement_.appendChild(element);
        }

        this.renderedAttributions_ = attributions;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */

    }, {
      key: "handleClick_",
      value: function handleClick_(event) {
        event.preventDefault();
        this.handleToggle_();
        this.userCollapsed_ = this.collapsed_;
      }
      /**
       * @private
       */

    }, {
      key: "handleToggle_",
      value: function handleToggle_() {
        this.element.classList.toggle(CLASS_COLLAPSED);

        if (this.collapsed_) {
          replaceNode(this.collapseLabel_, this.label_);
        } else {
          replaceNode(this.label_, this.collapseLabel_);
        }

        this.collapsed_ = !this.collapsed_;
        this.toggleButton_.setAttribute('aria-expanded', String(!this.collapsed_));
      }
      /**
       * Return `true` if the attribution is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */

    }, {
      key: "getCollapsible",
      value: function getCollapsible() {
        return this.collapsible_;
      }
      /**
       * Set whether the attribution should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */

    }, {
      key: "setCollapsible",
      value: function setCollapsible(collapsible) {
        if (this.collapsible_ === collapsible) {
          return;
        }

        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');

        if (this.userCollapsed_) {
          this.handleToggle_();
        }
      }
      /**
       * Collapse or expand the attribution according to the passed parameter. Will
       * not do anything if the attribution isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */

    }, {
      key: "setCollapsed",
      value: function setCollapsed(collapsed) {
        this.userCollapsed_ = collapsed;

        if (!this.collapsible_ || this.collapsed_ === collapsed) {
          return;
        }

        this.handleToggle_();
      }
      /**
       * Return `true` when the attribution is currently collapsed or `false`
       * otherwise.
       * @return {boolean} True if the widget is collapsed.
       * @api
       */

    }, {
      key: "getCollapsed",
      value: function getCollapsed() {
        return this.collapsed_;
      }
      /**
       * Update the attribution element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */

    }, {
      key: "render",
      value: function render(mapEvent) {
        this.updateElement_(mapEvent.frameState);
      }
    }]);

    return Attribution;
  }(Control);

  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-rotate'] CSS class name.
   * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
   * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
   * be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {function():void} [resetNorth] Function called when the control is clicked.
   * This will override the default `resetNorth`.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */

  /**
   * @classdesc
   * A button control to reset rotation to 0.
   * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
   * selector is added to the button when the rotation is 0.
   *
   * @api
   */

  var Rotate = /*#__PURE__*/function (_Control) {
    _inherits(Rotate, _Control);

    var _super = _createSuper(Rotate);

    /**
     * @param {Options} [options] Rotate options.
     */
    function Rotate(options) {
      var _this;

      _classCallCheck(this, Rotate);

      options = options ? options : {};
      _this = _super.call(this, {
        element: document.createElement('div'),
        render: options.render,
        target: options.target
      });
      var className = options.className !== undefined ? options.className : 'ol-rotate';
      var label = options.label !== undefined ? options.label : "\u21E7";
      var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
      /**
       * @type {HTMLElement}
       * @private
       */

      _this.label_ = null;

      if (typeof label === 'string') {
        _this.label_ = document.createElement('span');
        _this.label_.className = compassClassName;
        _this.label_.textContent = label;
      } else {
        _this.label_ = label;

        _this.label_.classList.add(compassClassName);
      }

      var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
      var button = document.createElement('button');
      button.className = className + '-reset';
      button.setAttribute('type', 'button');
      button.title = tipLabel;
      button.appendChild(_this.label_);
      button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this)), false);
      var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
      var element = _this.element;
      element.className = cssClasses;
      element.appendChild(button);
      _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
      /**
       * @type {number}
       * @private
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      /**
       * @type {boolean}
       * @private
       */

      _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.rotation_ = undefined;

      if (_this.autoHide_) {
        _this.element.classList.add(CLASS_HIDDEN);
      }

      return _this;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */


    _createClass(Rotate, [{
      key: "handleClick_",
      value: function handleClick_(event) {
        event.preventDefault();

        if (this.callResetNorth_ !== undefined) {
          this.callResetNorth_();
        } else {
          this.resetNorth_();
        }
      }
      /**
       * @private
       */

    }, {
      key: "resetNorth_",
      value: function resetNorth_() {
        var map = this.getMap();
        var view = map.getView();

        if (!view) {
          // the map does not have a view, so we can't act
          // upon it
          return;
        }

        var rotation = view.getRotation();

        if (rotation !== undefined) {
          if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
            view.animate({
              rotation: 0,
              duration: this.duration_,
              easing: easeOut
            });
          } else {
            view.setRotation(0);
          }
        }
      }
      /**
       * Update the rotate control element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */

    }, {
      key: "render",
      value: function render(mapEvent) {
        var frameState = mapEvent.frameState;

        if (!frameState) {
          return;
        }

        var rotation = frameState.viewState.rotation;

        if (rotation != this.rotation_) {
          var transform = 'rotate(' + rotation + 'rad)';

          if (this.autoHide_) {
            var contains = this.element.classList.contains(CLASS_HIDDEN);

            if (!contains && rotation === 0) {
              this.element.classList.add(CLASS_HIDDEN);
            } else if (contains && rotation !== 0) {
              this.element.classList.remove(CLASS_HIDDEN);
            }
          }

          this.label_.style.transform = transform;
        }

        this.rotation_ = rotation;
      }
    }]);

    return Rotate;
  }(Control);

  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {string} [className='ol-zoom'] CSS class name.
   * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
   * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
   * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
   * button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [zoomOutLabel=''] Text label to use for the zoom-out button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
   * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
   * @property {number} [delta=1] The zoom delta applied on each click.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */

  /**
   * @classdesc
   * A control with 2 buttons, one for zoom in and one for zoom out.
   * This control is one of the default controls of a map. To style this control
   * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
   *
   * @api
   */

  var Zoom = /*#__PURE__*/function (_Control) {
    _inherits(Zoom, _Control);

    var _super = _createSuper(Zoom);

    /**
     * @param {Options} [options] Zoom options.
     */
    function Zoom(options) {
      var _this;

      _classCallCheck(this, Zoom);

      options = options ? options : {};
      _this = _super.call(this, {
        element: document.createElement('div'),
        target: options.target
      });
      var className = options.className !== undefined ? options.className : 'ol-zoom';
      var delta = options.delta !== undefined ? options.delta : 1;
      var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
      var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
      var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
      var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : "\u2013";
      var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
      var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
      var inElement = document.createElement('button');
      inElement.className = zoomInClassName;
      inElement.setAttribute('type', 'button');
      inElement.title = zoomInTipLabel;
      inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
      inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this), delta), false);
      var outElement = document.createElement('button');
      outElement.className = zoomOutClassName;
      outElement.setAttribute('type', 'button');
      outElement.title = zoomOutTipLabel;
      outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
      outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_assertThisInitialized(_this), -delta), false);
      var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
      var element = _this.element;
      element.className = cssClasses;
      element.appendChild(inElement);
      element.appendChild(outElement);
      /**
       * @type {number}
       * @private
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      return _this;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */


    _createClass(Zoom, [{
      key: "handleClick_",
      value: function handleClick_(delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
      }
      /**
       * @param {number} delta Zoom delta.
       * @private
       */

    }, {
      key: "zoomByDelta_",
      value: function zoomByDelta_(delta) {
        var map = this.getMap();
        var view = map.getView();

        if (!view) {
          // the map does not have a view, so we can't act
          // upon it
          return;
        }

        var currentZoom = view.getZoom();

        if (currentZoom !== undefined) {
          var newZoom = view.getConstrainedZoom(currentZoom + delta);

          if (this.duration_ > 0) {
            if (view.getAnimating()) {
              view.cancelAnimations();
            }

            view.animate({
              zoom: newZoom,
              duration: this.duration_,
              easing: easeOut
            });
          } else {
            view.setZoom(newZoom);
          }
        }
      }
    }]);

    return Zoom;
  }(Control);

  /**
   * @module ol/control/defaults
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [attribution=true] Include
   * {@link module:ol/control/Attribution~Attribution}.
   * @property {import("./Attribution.js").Options} [attributionOptions]
   * Options for {@link module:ol/control/Attribution~Attribution}.
   * @property {boolean} [rotate=true] Include
   * {@link module:ol/control/Rotate~Rotate}.
   * @property {import("./Rotate.js").Options} [rotateOptions] Options
   * for {@link module:ol/control/Rotate~Rotate}.
   * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
   * @property {import("./Zoom.js").Options} [zoomOptions] Options for
   * {@link module:ol/control/Zoom~Zoom}.
   */

  /**
   * Set of controls included in maps by default. Unless configured otherwise,
   * this returns a collection containing an instance of each of the following
   * controls:
   * * {@link module:ol/control/Zoom~Zoom}
   * * {@link module:ol/control/Rotate~Rotate}
   * * {@link module:ol/control/Attribution~Attribution}
   *
   * @param {DefaultsOptions} [options] Options for the default controls.
   * @return {Collection<import("./Control.js").default>} A collection of controls
   * to be used with the {@link module:ol/Map~Map} constructor's `controls` option.
   * @api
   */

  function defaults$1(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Control.js").default>} */

    var controls = new Collection();
    var zoomControl = options.zoom !== undefined ? options.zoom : true;

    if (zoomControl) {
      controls.push(new Zoom(options.zoomOptions));
    }

    var rotateControl = options.rotate !== undefined ? options.rotate : true;

    if (rotateControl) {
      controls.push(new Rotate(options.rotateOptions));
    }

    var attributionControl = options.attribution !== undefined ? options.attribution : true;

    if (attributionControl) {
      controls.push(new Attribution(options.attributionOptions));
    }

    return controls;
  }

  /**
   * @module ol/interaction/Property
   */

  /**
   * @enum {string}
   */
  var InteractionProperty = {
    ACTIVE: 'active'
  };

  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
   *     'change:active', import("../Object").ObjectEvent, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
   *     'change:active', Return>} InteractionOnSignature
   */

  /**
   * Object literal with config options for interactions.
   * @typedef {Object} InteractionOptions
   * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. If the function returns a falsy value, propagation of
   * the event to other interactions in the map's interactions chain will be
   * prevented (this includes functions with no explicit return). The interactions
   * are traversed in reverse order of the interactions collection of the map.
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * User actions that change the state of the map. Some are similar to controls,
   * but are not associated with a DOM element.
   * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
   * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
   * by a keyboard event not a button element event.
   * Although interactions do not have a DOM element, some of them do render
   * vectors and so are visible on the screen.
   * @api
   */

  var Interaction = /*#__PURE__*/function (_BaseObject) {
    _inherits(Interaction, _BaseObject);

    var _super = _createSuper(Interaction);

    /**
     * @param {InteractionOptions} [options] Options.
     */
    function Interaction(options) {
      var _this;

      _classCallCheck(this, Interaction);

      _this = _super.call(this);
      /***
       * @type {InteractionOnSignature<import("../events").EventsKey>}
       */

      _this.on;
      /***
       * @type {InteractionOnSignature<import("../events").EventsKey>}
       */

      _this.once;
      /***
       * @type {InteractionOnSignature<void>}
       */

      _this.un;

      if (options && options.handleEvent) {
        _this.handleEvent = options.handleEvent;
      }
      /**
       * @private
       * @type {import("../Map.js").default|null}
       */


      _this.map_ = null;

      _this.setActive(true);

      return _this;
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */


    _createClass(Interaction, [{
      key: "getActive",
      value: function getActive() {
        return (
          /** @type {boolean} */
          this.get(InteractionProperty.ACTIVE)
        );
      }
      /**
       * Get the map associated with this interaction.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */

    }, {
      key: "getMap",
      value: function getMap() {
        return this.map_;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */

    }, {
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        return true;
      }
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */

    }, {
      key: "setActive",
      value: function setActive(active) {
        this.set(InteractionProperty.ACTIVE, active);
      }
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       */

    }, {
      key: "setMap",
      value: function setMap(map) {
        this.map_ = map;
      }
    }]);

    return Interaction;
  }(BaseObject);
  /**
   * @param {import("../View.js").default} view View.
   * @param {import("../coordinate.js").Coordinate} delta Delta.
   * @param {number} [duration] Duration.
   */


  function pan(view, delta, duration) {
    var currentCenter = view.getCenterInternal();

    if (currentCenter) {
      var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
      view.animateInternal({
        duration: duration !== undefined ? duration : 250,
        easing: linear,
        center: view.getConstrainedCenter(center)
      });
    }
  }
  /**
   * @param {import("../View.js").default} view View.
   * @param {number} delta Delta from previous zoom level.
   * @param {import("../coordinate.js").Coordinate} [anchor] Anchor coordinate in the user projection.
   * @param {number} [duration] Duration.
   */

  function zoomByDelta(view, delta, anchor, duration) {
    var currentZoom = view.getZoom();

    if (currentZoom === undefined) {
      return;
    }

    var newZoom = view.getConstrainedZoom(currentZoom + delta);
    var newResolution = view.getResolutionForZoom(newZoom);

    if (view.getAnimating()) {
      view.cancelAnimations();
    }

    view.animate({
      resolution: newResolution,
      anchor: anchor,
      duration: duration !== undefined ? duration : 250,
      easing: easeOut
    });
  }

  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [delta=1] The zoom delta applied on each double click.
   */

  /**
   * @classdesc
   * Allows the user to zoom by double-clicking on the map.
   * @api
   */

  var DoubleClickZoom = /*#__PURE__*/function (_Interaction) {
    _inherits(DoubleClickZoom, _Interaction);

    var _super = _createSuper(DoubleClickZoom);

    /**
     * @param {Options} [options] Options.
     */
    function DoubleClickZoom(options) {
      var _this;

      _classCallCheck(this, DoubleClickZoom);

      _this = _super.call(this);
      options = options ? options : {};
      /**
       * @private
       * @type {number}
       */

      _this.delta_ = options.delta ? options.delta : 1;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */


    _createClass(DoubleClickZoom, [{
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        var stopEvent = false;

        if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
          var browserEvent =
          /** @type {MouseEvent} */
          mapBrowserEvent.originalEvent;
          var map = mapBrowserEvent.map;
          var anchor = mapBrowserEvent.coordinate;
          var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
          var view = map.getView();
          zoomByDelta(view, delta, anchor, this.duration_);
          browserEvent.preventDefault();
          stopEvent = true;
        }

        return !stopEvent;
      }
    }]);

    return DoubleClickZoom;
  }(Interaction);

  /**
   * @typedef {Object} Options
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
   * Function handling "down" events. If the function returns `true` then a drag
   * sequence is started.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
   * Function handling "drag" events. This function is called on "move" events
   * during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. The function may return `false` to prevent the
   * propagation of the event to other interactions in the map's interactions
   * chain.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
   * Function handling "move" events. This function is called on "move" events.
   * This functions is also called during a drag sequence, so during a drag
   * sequence both the `handleDragEvent` function and this function are called.
   * If `handleDownEvent` is defined and it returns true this function will not
   * be called during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
   *  Function handling "up" events. If the function returns `false` then the
   * current drag sequence is stopped.
   * @property {function(boolean):boolean} [stopDown]
   * Should the down event be propagated to other interactions, or should be
   * stopped?
   */

  /**
   * @classdesc
   * Base class that calls user-defined functions on `down`, `move` and `up`
   * events. This class also manages "drag sequences".
   *
   * When the `handleDownEvent` user function returns `true` a drag sequence is
   * started. During a drag sequence the `handleDragEvent` user function is
   * called on `move` events. The drag sequence ends when the `handleUpEvent`
   * user function is called and returns `false`.
   * @api
   */

  var PointerInteraction = /*#__PURE__*/function (_Interaction) {
    _inherits(PointerInteraction, _Interaction);

    var _super = _createSuper(PointerInteraction);

    /**
     * @param {Options} [options] Options.
     */
    function PointerInteraction(options) {
      var _this;

      _classCallCheck(this, PointerInteraction);

      options = options ? options : {};
      _this = _super.call(this,
      /** @type {import("./Interaction.js").InteractionOptions} */
      options);

      if (options.handleDownEvent) {
        _this.handleDownEvent = options.handleDownEvent;
      }

      if (options.handleDragEvent) {
        _this.handleDragEvent = options.handleDragEvent;
      }

      if (options.handleMoveEvent) {
        _this.handleMoveEvent = options.handleMoveEvent;
      }

      if (options.handleUpEvent) {
        _this.handleUpEvent = options.handleUpEvent;
      }

      if (options.stopDown) {
        _this.stopDown = options.stopDown;
      }
      /**
       * @type {boolean}
       * @protected
       */


      _this.handlingDownUpSequence = false;
      /**
       * @type {Array<PointerEvent>}
       * @protected
       */

      _this.targetPointers = [];
      return _this;
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */


    _createClass(PointerInteraction, [{
      key: "getPointerCount",
      value: function getPointerCount() {
        return this.targetPointers.length;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        return false;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */

    }, {
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {}
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
       * detected.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */

    }, {
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        if (!mapBrowserEvent.originalEvent) {
          return true;
        }

        var stopEvent = false;
        this.updateTrackedPointers_(mapBrowserEvent);

        if (this.handlingDownUpSequence) {
          if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
            this.handleDragEvent(mapBrowserEvent); // prevent page scrolling during dragging

            mapBrowserEvent.originalEvent.preventDefault();
          } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
            var handledUp = this.handleUpEvent(mapBrowserEvent);
            this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
          }
        } else {
          if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
            var handled = this.handleDownEvent(mapBrowserEvent);
            this.handlingDownUpSequence = handled;
            stopEvent = this.stopDown(handled);
          } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
            this.handleMoveEvent(mapBrowserEvent);
          }
        }

        return !stopEvent;
      }
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */

    }, {
      key: "handleMoveEvent",
      value: function handleMoveEvent(mapBrowserEvent) {}
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        return false;
      }
      /**
       * This function is used to determine if "down" events should be propagated
       * to other interactions or should be stopped.
       * @param {boolean} handled Was the event handled by the interaction?
       * @return {boolean} Should the `down` event be stopped?
       */

    }, {
      key: "stopDown",
      value: function stopDown(handled) {
        return handled;
      }
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @private
       */

    }, {
      key: "updateTrackedPointers_",
      value: function updateTrackedPointers_(mapBrowserEvent) {
        if (mapBrowserEvent.activePointers) {
          this.targetPointers = mapBrowserEvent.activePointers;
        }
      }
    }]);

    return PointerInteraction;
  }(Interaction);
  /**
   * @param {Array<PointerEvent>} pointerEvents List of events.
   * @return {import("../pixel.js").Pixel} Centroid pixel.
   */


  function centroid(pointerEvents) {
    var length = pointerEvents.length;
    var clientX = 0;
    var clientY = 0;

    for (var i = 0; i < length; i++) {
      clientX += pointerEvents[i].clientX;
      clientY += pointerEvents[i].clientY;
    }

    return [clientX / length, clientY / length];
  }

  /**
   * @module ol/events/condition
   */
  /**
   * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * `{boolean}`. If the condition is met, true should be returned.
   *
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
   */

  /**
   * Creates a condition function that passes when all provided conditions pass.
   * @param {...Condition} var_args Conditions to check.
   * @return {Condition} Condition function.
   */

  function all(var_args) {
    var conditions = arguments;
    /**
     * @param {import("../MapBrowserEvent.js").default} event Event.
     * @return {boolean} All conditions passed.
     */

    return function (event) {
      var pass = true;

      for (var i = 0, ii = conditions.length; i < ii; ++i) {
        pass = pass && conditions[i](event);

        if (!pass) {
          break;
        }
      }

      return pass;
    };
  }
  /**
   * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
   * (e.g. when additionally the platform-modifier-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the alt and shift keys are pressed.
   * @api
   */

  var altShiftKeysOnly = function altShiftKeysOnly(mapBrowserEvent) {
    var originalEvent =
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent;
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
  };
  /**
   * Return `true` if the map has the focus. This condition requires a map target
   * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map has the focus.
   * @api
   */

  var focus = function focus(event) {
    var targetElement = event.map.getTargetElement();
    var activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
  };
  /**
   * Return `true` if the map has the focus or no 'tabindex' attribute set.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map container has the focus or no 'tabindex' attribute.
   */

  var focusWithTabindex = function focusWithTabindex(event) {
    return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
  };
  /**
   * Return always true.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True.
   * @api
   */

  var always = TRUE;
  /**
   * Return `true` if the event has an "action"-producing mouse button.
   *
   * By definition, this includes left-click on windows/linux, and left-click
   * without the ctrl key on Macs.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} The result.
   */

  var mouseActionButton = function mouseActionButton(mapBrowserEvent) {
    var originalEvent =
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };
  /**
   * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
   * pressed.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if there no modifier keys are pressed.
   * @api
   */

  var noModifierKeys = function noModifierKeys(mapBrowserEvent) {
    var originalEvent =
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
  };
  /**
   * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
   * additionally the alt-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the shift key is pressed.
   * @api
   */

  var shiftKeyOnly = function shiftKeyOnly(mapBrowserEvent) {
    var originalEvent =
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent;
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
  };
  /**
   * Return `true` if the target element is not editable, i.e. not an `input`,
   * `select`, or `textarea` element and no `contenteditable` attribute is
   * set or inherited, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if the target element is not editable.
   * @api
   */

  var targetNotEditable = function targetNotEditable(mapBrowserEvent) {
    var originalEvent =
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent;
    var tagName =
    /** @type {Element} */
    originalEvent.target.tagName;
    return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA' && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
  };
  /**
   * Return `true` if the event originates from a mouse device.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a mouse device.
   * @api
   */

  var mouseOnly = function mouseOnly(mapBrowserEvent) {
    var pointerEvent =
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent;
    assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
    // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

    return pointerEvent.pointerType == 'mouse';
  };
  /**
   * Return `true` if the event originates from a primary pointer in
   * contact with the surface or if the left mouse button is pressed.
   * See https://www.w3.org/TR/pointerevents/#button-states.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a primary pointer.
   * @api
   */

  var primaryAction = function primaryAction(mapBrowserEvent) {
    var pointerEvent =
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent;
    assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event

    return pointerEvent.isPrimary && pointerEvent.button === 0;
  };

  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
   */

  /**
   * @classdesc
   * Allows the user to pan the map by dragging the map.
   * @api
   */

  var DragPan = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(DragPan, _PointerInteraction);

    var _super = _createSuper(DragPan);

    /**
     * @param {Options} [options] Options.
     */
    function DragPan(options) {
      var _this;

      _classCallCheck(this, DragPan);

      _this = _super.call(this, {
        stopDown: FALSE
      });
      options = options ? options : {};
      /**
       * @private
       * @type {import("../Kinetic.js").default|undefined}
       */

      _this.kinetic_ = options.kinetic;
      /**
       * @type {import("../pixel.js").Pixel}
       */

      _this.lastCentroid = null;
      /**
       * @type {number}
       */

      _this.lastPointersCount_;
      /**
       * @type {boolean}
       */

      _this.panning_ = false;
      var condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */

      _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
      /**
       * @private
       * @type {boolean}
       */

      _this.noKinetic_ = false;
      return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */


    _createClass(DragPan, [{
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {
        if (!this.panning_) {
          this.panning_ = true;
          this.getMap().getView().beginInteraction();
        }

        var targetPointers = this.targetPointers;
        var centroid$1 = centroid(targetPointers);

        if (targetPointers.length == this.lastPointersCount_) {
          if (this.kinetic_) {
            this.kinetic_.update(centroid$1[0], centroid$1[1]);
          }

          if (this.lastCentroid) {
            var delta = [this.lastCentroid[0] - centroid$1[0], centroid$1[1] - this.lastCentroid[1]];
            var map = mapBrowserEvent.map;
            var view = map.getView();
            scale$2(delta, view.getResolution());
            rotate$1(delta, view.getRotation());
            view.adjustCenterInternal(delta);
          }
        } else if (this.kinetic_) {
          // reset so we don't overestimate the kinetic energy after
          // after one finger down, tiny drag, second finger down
          this.kinetic_.begin();
        }

        this.lastCentroid = centroid$1;
        this.lastPointersCount_ = targetPointers.length;
        mapBrowserEvent.originalEvent.preventDefault();
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        var map = mapBrowserEvent.map;
        var view = map.getView();

        if (this.targetPointers.length === 0) {
          if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
            var distance = this.kinetic_.getDistance();
            var angle = this.kinetic_.getAngle();
            var center = view.getCenterInternal();
            var centerpx = map.getPixelFromCoordinateInternal(center);
            var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
            view.animateInternal({
              center: view.getConstrainedCenter(dest),
              duration: 500,
              easing: easeOut
            });
          }

          if (this.panning_) {
            this.panning_ = false;
            view.endInteraction();
          }

          return false;
        } else {
          if (this.kinetic_) {
            // reset so we don't overestimate the kinetic energy after
            // after one finger up, tiny drag, second finger up
            this.kinetic_.begin();
          }

          this.lastCentroid = null;
          return true;
        }
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          this.lastCentroid = null; // stop any current animation

          if (view.getAnimating()) {
            view.cancelAnimations();
          }

          if (this.kinetic_) {
            this.kinetic_.begin();
          } // No kinetic as soon as more than one pointer on the screen is
          // detected. This is to prevent nasty pans after pinch.


          this.noKinetic_ = this.targetPointers.length > 1;
          return true;
        } else {
          return false;
        }
      }
    }]);

    return DragPan;
  }(PointerInteraction);

  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an
   * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition.altShiftKeysOnly}.
   * @property {number} [duration=250] Animation duration in milliseconds.
   */

  /**
   * @classdesc
   * Allows the user to rotate the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the alt and shift keys are held down.
   *
   * This interaction is only supported for mouse devices.
   * @api
   */

  var DragRotate = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(DragRotate, _PointerInteraction);

    var _super = _createSuper(DragRotate);

    /**
     * @param {Options} [options] Options.
     */
    function DragRotate(options) {
      var _this;

      _classCallCheck(this, DragRotate);

      options = options ? options : {};
      _this = _super.call(this, {
        stopDown: FALSE
      });
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */

      _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.lastAngle_ = undefined;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */


    _createClass(DragRotate, [{
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {
        if (!mouseOnly(mapBrowserEvent)) {
          return;
        }

        var map = mapBrowserEvent.map;
        var view = map.getView();

        if (view.getConstraints().rotation === disable) {
          return;
        }

        var size = map.getSize();
        var offset = mapBrowserEvent.pixel;
        var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

        if (this.lastAngle_ !== undefined) {
          var delta = theta - this.lastAngle_;
          view.adjustRotationInternal(-delta);
        }

        this.lastAngle_ = theta;
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        if (!mouseOnly(mapBrowserEvent)) {
          return true;
        }

        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.endInteraction(this.duration_);
        return false;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        if (!mouseOnly(mapBrowserEvent)) {
          return false;
        }

        if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
          var map = mapBrowserEvent.map;
          map.getView().beginInteraction();
          this.lastAngle_ = undefined;
          return true;
        } else {
          return false;
        }
      }
    }]);

    return DragRotate;
  }(PointerInteraction);

  var RenderBox = /*#__PURE__*/function (_Disposable) {
    _inherits(RenderBox, _Disposable);

    var _super = _createSuper(RenderBox);

    /**
     * @param {string} className CSS class name.
     */
    function RenderBox(className) {
      var _this;

      _classCallCheck(this, RenderBox);

      _this = _super.call(this);
      /**
       * @type {import("../geom/Polygon.js").default}
       * @private
       */

      _this.geometry_ = null;
      /**
       * @type {HTMLDivElement}
       * @private
       */

      _this.element_ = document.createElement('div');
      _this.element_.style.position = 'absolute';
      _this.element_.style.pointerEvents = 'auto';
      _this.element_.className = 'ol-box ' + className;
      /**
       * @private
       * @type {import("../Map.js").default|null}
       */

      _this.map_ = null;
      /**
       * @private
       * @type {import("../pixel.js").Pixel}
       */

      _this.startPixel_ = null;
      /**
       * @private
       * @type {import("../pixel.js").Pixel}
       */

      _this.endPixel_ = null;
      return _this;
    }
    /**
     * Clean up.
     */


    _createClass(RenderBox, [{
      key: "disposeInternal",
      value: function disposeInternal() {
        this.setMap(null);
      }
      /**
       * @private
       */

    }, {
      key: "render_",
      value: function render_() {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var px = 'px';
        var style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
      }
      /**
       * @param {import("../Map.js").default|null} map Map.
       */

    }, {
      key: "setMap",
      value: function setMap(map) {
        if (this.map_) {
          this.map_.getOverlayContainer().removeChild(this.element_);
          var style = this.element_.style;
          style.left = 'inherit';
          style.top = 'inherit';
          style.width = 'inherit';
          style.height = 'inherit';
        }

        this.map_ = map;

        if (this.map_) {
          this.map_.getOverlayContainer().appendChild(this.element_);
        }
      }
      /**
       * @param {import("../pixel.js").Pixel} startPixel Start pixel.
       * @param {import("../pixel.js").Pixel} endPixel End pixel.
       */

    }, {
      key: "setPixels",
      value: function setPixels(startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
      }
      /**
       * Creates or updates the cached geometry.
       */

    }, {
      key: "createOrUpdateGeometry",
      value: function createOrUpdateGeometry() {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
        var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_); // close the polygon

        coordinates[4] = coordinates[0].slice();

        if (!this.geometry_) {
          this.geometry_ = new Polygon([coordinates]);
        } else {
          this.geometry_.setCoordinates([coordinates]);
        }
      }
      /**
       * @return {import("../geom/Polygon.js").default} Geometry.
       */

    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this.geometry_;
      }
    }]);

    return RenderBox;
  }(Disposable);

  /**
   * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
   * true should be returned.
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
   */

  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link ol/events/condition~mouseActionButton}.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
   * `boxEndCondition` function.
   * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
   * Default is `true` if the area of the box is bigger than the `minArea` option.
   * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
   * before `boxend` is fired.
   */

  /**
   * @enum {string}
   */

  var DragBoxEventType = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: 'boxstart',

    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: 'boxdrag',

    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: 'boxend',

    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: 'boxcancel'
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
   * this type.
   */

  var DragBoxEvent = /*#__PURE__*/function (_Event) {
    _inherits(DragBoxEvent, _Event);

    var _super = _createSuper(DragBoxEvent);

    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    function DragBoxEvent(type, coordinate, mapBrowserEvent) {
      var _this;

      _classCallCheck(this, DragBoxEvent);

      _this = _super.call(this, type);
      /**
       * The coordinate of the drag event.
       * @const
       * @type {import("../coordinate.js").Coordinate}
       * @api
       */

      _this.coordinate = coordinate;
      /**
       * @const
       * @type {import("../MapBrowserEvent.js").default}
       * @api
       */

      _this.mapBrowserEvent = mapBrowserEvent;
      return _this;
    }

    return _createClass(DragBoxEvent);
  }(BaseEvent);
  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("../ObjectEventType").Types|
   *     'change:active', import("../Object").ObjectEvent, Return> &
   *   import("../Observable").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
   *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature
   */

  /**
   * @classdesc
   * Allows the user to draw a vector box by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the shift or other key is held down. This is used, for example,
   * for zooming to a specific area of the map
   * (see {@link module:ol/interaction/DragZoom~DragZoom} and
   * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).
   *
   * @fires DragBoxEvent
   * @api
   */

  var DragBox = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(DragBox, _PointerInteraction);

    var _super2 = _createSuper(DragBox);

    /**
     * @param {Options} [options] Options.
     */
    function DragBox(options) {
      var _this2;

      _classCallCheck(this, DragBox);

      _this2 = _super2.call(this);
      /***
       * @type {DragBoxOnSignature<import("../events").EventsKey>}
       */

      _this2.on;
      /***
       * @type {DragBoxOnSignature<import("../events").EventsKey>}
       */

      _this2.once;
      /***
       * @type {DragBoxOnSignature<void>}
       */

      _this2.un;
      options = options ? options : {};
      /**
       * @type {import("../render/Box.js").default}
       * @private
       */

      _this2.box_ = new RenderBox(options.className || 'ol-dragbox');
      /**
       * @type {number}
       * @private
       */

      _this2.minArea_ = options.minArea !== undefined ? options.minArea : 64;

      if (options.onBoxEnd) {
        _this2.onBoxEnd = options.onBoxEnd;
      }
      /**
       * @type {import("../pixel.js").Pixel}
       * @private
       */


      _this2.startPixel_ = null;
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */

      _this2.condition_ = options.condition ? options.condition : mouseActionButton;
      /**
       * @private
       * @type {EndCondition}
       */

      _this2.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this2.defaultBoxEndCondition;
      return _this2;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */


    _createClass(DragBox, [{
      key: "defaultBoxEndCondition",
      value: function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
        var width = endPixel[0] - startPixel[0];
        var height = endPixel[1] - startPixel[1];
        return width * width + height * height >= this.minArea_;
      }
      /**
       * Returns geometry of last drawn box.
       * @return {import("../geom/Polygon.js").default} Geometry.
       * @api
       */

    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this.box_.getGeometry();
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */

    }, {
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {
        this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        this.box_.setMap(null);
        var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);

        if (completeBox) {
          this.onBoxEnd(mapBrowserEvent);
        }

        this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
        return false;
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        if (this.condition_(mapBrowserEvent)) {
          this.startPixel_ = mapBrowserEvent.pixel;
          this.box_.setMap(mapBrowserEvent.map);
          this.box_.setPixels(this.startPixel_, this.startPixel_);
          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
          return true;
        } else {
          return false;
        }
      }
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */

    }, {
      key: "onBoxEnd",
      value: function onBoxEnd(event) {}
    }]);

    return DragBox;
  }(PointerInteraction);

  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragzoom'] CSS class name for styling the
   * box.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition.shiftKeyOnly}.
   * @property {number} [duration=200] Animation duration in milliseconds.
   * @property {boolean} [out=false] Use interaction for zooming out.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
   * `boxEndCondition` function.
   */

  /**
   * @classdesc
   * Allows the user to zoom the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when a key, shift by default, is held down.
   *
   * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
   * your custom one configured with `className`.
   * @api
   */

  var DragZoom = /*#__PURE__*/function (_DragBox) {
    _inherits(DragZoom, _DragBox);

    var _super = _createSuper(DragZoom);

    /**
     * @param {Options} [options] Options.
     */
    function DragZoom(options) {
      var _this;

      _classCallCheck(this, DragZoom);

      options = options ? options : {};
      var condition = options.condition ? options.condition : shiftKeyOnly;
      _this = _super.call(this, {
        condition: condition,
        className: options.className || 'ol-dragzoom',
        minArea: options.minArea
      });
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 200;
      /**
       * @private
       * @type {boolean}
       */

      _this.out_ = options.out !== undefined ? options.out : false;
      return _this;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */


    _createClass(DragZoom, [{
      key: "onBoxEnd",
      value: function onBoxEnd(event) {
        var map = this.getMap();
        var view =
        /** @type {!import("../View.js").default} */
        map.getView();
        var geometry = this.getGeometry();

        if (this.out_) {
          var rotatedExtent = view.rotatedExtentForGeometry(geometry);
          var resolution = view.getResolutionForExtentInternal(rotatedExtent);
          var factor = view.getResolution() / resolution;
          geometry = geometry.clone();
          geometry.scale(factor * factor);
        }

        view.fitInternal(geometry, {
          duration: this.duration_,
          easing: easeOut
        });
      }
    }]);

    return DragZoom;
  }(DragBox);

  /**
   * @module ol/events/KeyCode
   */

  /**
   * @enum {number}
   * @const
   */
  var KeyCode = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
  };

  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition.noModifierKeys} and
   * {@link module:ol/events/condition.targetNotEditable}.
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
   * press.
   */

  /**
   * @classdesc
   * Allows the user to pan the map using keyboard arrows.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
   * @api
   */

  var KeyboardPan = /*#__PURE__*/function (_Interaction) {
    _inherits(KeyboardPan, _Interaction);

    var _super = _createSuper(KeyboardPan);

    /**
     * @param {Options} [options] Options.
     */
    function KeyboardPan(options) {
      var _this;

      _classCallCheck(this, KeyboardPan);

      _this = _super.call(this);
      options = options || {};
      /**
       * @private
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
       * @return {boolean} Combined condition result.
       */

      _this.defaultCondition_ = function (mapBrowserEvent) {
        return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
      };
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */


      _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 100;
      /**
       * @private
       * @type {number}
       */

      _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
      return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardPan}
     */


    _createClass(KeyboardPan, [{
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        var stopEvent = false;

        if (mapBrowserEvent.type == EventType.KEYDOWN) {
          var keyEvent =
          /** @type {KeyboardEvent} */
          mapBrowserEvent.originalEvent;
          var keyCode = keyEvent.keyCode;

          if (this.condition_(mapBrowserEvent) && (keyCode == KeyCode.DOWN || keyCode == KeyCode.LEFT || keyCode == KeyCode.RIGHT || keyCode == KeyCode.UP)) {
            var map = mapBrowserEvent.map;
            var view = map.getView();
            var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
            var deltaX = 0,
                deltaY = 0;

            if (keyCode == KeyCode.DOWN) {
              deltaY = -mapUnitsDelta;
            } else if (keyCode == KeyCode.LEFT) {
              deltaX = -mapUnitsDelta;
            } else if (keyCode == KeyCode.RIGHT) {
              deltaX = mapUnitsDelta;
            } else {
              deltaY = mapUnitsDelta;
            }

            var delta = [deltaX, deltaY];
            rotate$1(delta, view.getRotation());
            pan(view, delta, this.duration_);
            keyEvent.preventDefault();
            stopEvent = true;
          }
        }

        return !stopEvent;
      }
    }]);

    return KeyboardPan;
  }(Interaction);

  /**
   * @typedef {Object} Options
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition.targetNotEditable}.
   * @property {number} [delta=1] The zoom level delta on each key press.
   */

  /**
   * @classdesc
   * Allows the user to zoom the map using keyboard + and -.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
   * @api
   */

  var KeyboardZoom = /*#__PURE__*/function (_Interaction) {
    _inherits(KeyboardZoom, _Interaction);

    var _super = _createSuper(KeyboardZoom);

    /**
     * @param {Options} [options] Options.
     */
    function KeyboardZoom(options) {
      var _this;

      _classCallCheck(this, KeyboardZoom);

      _this = _super.call(this);
      options = options ? options : {};
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */

      _this.condition_ = options.condition ? options.condition : targetNotEditable;
      /**
       * @private
       * @type {number}
       */

      _this.delta_ = options.delta ? options.delta : 1;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 100;
      return _this;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {KeyboardZoom}
     */


    _createClass(KeyboardZoom, [{
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        var stopEvent = false;

        if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {
          var keyEvent =
          /** @type {KeyboardEvent} */
          mapBrowserEvent.originalEvent;
          var charCode = keyEvent.charCode;

          if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
            var map = mapBrowserEvent.map;
            var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
            var view = map.getView();
            zoomByDelta(view, delta, undefined, this.duration_);
            keyEvent.preventDefault();
            stopEvent = true;
          }
        }

        return !stopEvent;
      }
    }]);

    return KeyboardZoom;
  }(Interaction);

  /**
   * @module ol/Kinetic
   */

  /**
   * @classdesc
   * Implementation of inertial deceleration for map movement.
   *
   * @api
   */
  var Kinetic = /*#__PURE__*/function () {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    function Kinetic(decay, minVelocity, delay) {
      _classCallCheck(this, Kinetic);

      /**
       * @private
       * @type {number}
       */
      this.decay_ = decay;
      /**
       * @private
       * @type {number}
       */

      this.minVelocity_ = minVelocity;
      /**
       * @private
       * @type {number}
       */

      this.delay_ = delay;
      /**
       * @private
       * @type {Array<number>}
       */

      this.points_ = [];
      /**
       * @private
       * @type {number}
       */

      this.angle_ = 0;
      /**
       * @private
       * @type {number}
       */

      this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */


    _createClass(Kinetic, [{
      key: "begin",
      value: function begin() {
        this.points_.length = 0;
        this.angle_ = 0;
        this.initialVelocity_ = 0;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       */

    }, {
      key: "update",
      value: function update(x, y) {
        this.points_.push(x, y, Date.now());
      }
      /**
       * @return {boolean} Whether we should do kinetic animation.
       */

    }, {
      key: "end",
      value: function end() {
        if (this.points_.length < 6) {
          // at least 2 points are required (i.e. there must be at least 6 elements
          // in the array)
          return false;
        }

        var delay = Date.now() - this.delay_;
        var lastIndex = this.points_.length - 3;

        if (this.points_[lastIndex + 2] < delay) {
          // the last tracked point is too old, which means that the user stopped
          // panning before releasing the map
          return false;
        } // get the first point which still falls into the delay time


        var firstIndex = lastIndex - 3;

        while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
          firstIndex -= 3;
        }

        var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
        // we also make sure the user panned for a duration of at least one frame
        // (1/60s) to compute sane displacement values

        if (duration < 1000 / 60) {
          return false;
        }

        var dx = this.points_[lastIndex] - this.points_[firstIndex];
        var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
        this.angle_ = Math.atan2(dy, dx);
        this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
        return this.initialVelocity_ > this.minVelocity_;
      }
      /**
       * @return {number} Total distance travelled (pixels).
       */

    }, {
      key: "getDistance",
      value: function getDistance() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
      }
      /**
       * @return {number} Angle of the kinetic panning animation (radians).
       */

    }, {
      key: "getAngle",
      value: function getAngle() {
        return this.angle_;
      }
    }]);

    return Kinetic;
  }();

  /**
   * @typedef {'trackpad' | 'wheel'} Mode
   */

  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition.always}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {number} [maxDelta=1] Maximum mouse wheel delta.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
   * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
   * location as the anchor. When set to `false`, zooming in and out will zoom to
   * the center of the screen instead of zooming on the mouse's location.
   * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
   * event will always animate to the closest zoom level after an interaction;
   * false means intermediary zoom levels are allowed.
   */

  /**
   * @classdesc
   * Allows the user to zoom the map by scrolling the mouse wheel.
   * @api
   */

  var MouseWheelZoom = /*#__PURE__*/function (_Interaction) {
    _inherits(MouseWheelZoom, _Interaction);

    var _super = _createSuper(MouseWheelZoom);

    /**
     * @param {Options} [options] Options.
     */
    function MouseWheelZoom(options) {
      var _this;

      _classCallCheck(this, MouseWheelZoom);

      options = options ? options : {};
      _this = _super.call(this,
      /** @type {import("./Interaction.js").InteractionOptions} */
      options);
      /**
       * @private
       * @type {number}
       */

      _this.totalDelta_ = 0;
      /**
       * @private
       * @type {number}
       */

      _this.lastDelta_ = 0;
      /**
       * @private
       * @type {number}
       */

      _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      /**
       * @private
       * @type {number}
       */

      _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
      /**
       * @private
       * @type {boolean}
       */

      _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
      /**
       * @private
       * @type {boolean}
       */

      _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
      var condition = options.condition ? options.condition : always;
      /**
       * @private
       * @type {import("../events/condition.js").Condition}
       */

      _this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
      /**
       * @private
       * @type {?import("../coordinate.js").Coordinate}
       */

      _this.lastAnchor_ = null;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.startTime_ = undefined;
      /**
       * @private
       * @type {?}
       */

      _this.timeoutId_;
      /**
       * @private
       * @type {Mode|undefined}
       */

      _this.mode_ = undefined;
      /**
       * Trackpad events separated by this delay will be considered separate
       * interactions.
       * @type {number}
       */

      _this.trackpadEventGap_ = 400;
      /**
       * @type {?}
       */

      _this.trackpadTimeoutId_;
      /**
       * The number of delta values per zoom level
       * @private
       * @type {number}
       */

      _this.deltaPerZoom_ = 300;
      return _this;
    }
    /**
     * @private
     */


    _createClass(MouseWheelZoom, [{
      key: "endInteraction_",
      value: function endInteraction_() {
        this.trackpadTimeoutId_ = undefined;
        var map = this.getMap();

        if (!map) {
          return;
        }

        var view = map.getView();
        view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
       * zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */

    }, {
      key: "handleEvent",
      value: function handleEvent(mapBrowserEvent) {
        if (!this.condition_(mapBrowserEvent)) {
          return true;
        }

        var type = mapBrowserEvent.type;

        if (type !== EventType.WHEEL) {
          return true;
        }

        var map = mapBrowserEvent.map;
        var wheelEvent =
        /** @type {WheelEvent} */
        mapBrowserEvent.originalEvent;
        wheelEvent.preventDefault();

        if (this.useAnchor_) {
          this.lastAnchor_ = mapBrowserEvent.coordinate;
        } // Delta normalisation inspired by
        // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


        var delta;

        if (mapBrowserEvent.type == EventType.WHEEL) {
          delta = wheelEvent.deltaY;

          if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
            delta /= DEVICE_PIXEL_RATIO;
          }

          if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
            delta *= 40;
          }
        }

        if (delta === 0) {
          return false;
        } else {
          this.lastDelta_ = delta;
        }

        var now = Date.now();

        if (this.startTime_ === undefined) {
          this.startTime_ = now;
        }

        if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
          this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';
        }

        var view = map.getView();

        if (this.mode_ === 'trackpad' && !(view.getConstrainResolution() || this.constrainResolution_)) {
          if (this.trackpadTimeoutId_) {
            clearTimeout(this.trackpadTimeoutId_);
          } else {
            if (view.getAnimating()) {
              view.cancelAnimations();
            }

            view.beginInteraction();
          }

          this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
          view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
          this.startTime_ = now;
          return false;
        }

        this.totalDelta_ += delta;
        var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
        clearTimeout(this.timeoutId_);
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
        return false;
      }
      /**
       * @private
       * @param {import("../Map.js").default} map Map.
       */

    }, {
      key: "handleWheelZoom_",
      value: function handleWheelZoom_(map) {
        var view = map.getView();

        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;

        if (view.getConstrainResolution() || this.constrainResolution_) {
          // view has a zoom constraint, zoom by 1
          delta = delta ? delta > 0 ? 1 : -1 : 0;
        }

        zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.totalDelta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
      }
      /**
       * Enable or disable using the mouse's location as an anchor when zooming
       * @param {boolean} useAnchor true to zoom to the mouse's location, false
       * to zoom to the center of the map
       * @api
       */

    }, {
      key: "setMouseAnchor",
      value: function setMouseAnchor(useAnchor) {
        this.useAnchor_ = useAnchor;

        if (!useAnchor) {
          this.lastAnchor_ = null;
        }
      }
    }]);

    return MouseWheelZoom;
  }(Interaction);

  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] The duration of the animation in
   * milliseconds.
   * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
   */

  /**
   * @classdesc
   * Allows the user to rotate the map by twisting with two fingers
   * on a touch screen.
   * @api
   */

  var PinchRotate = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(PinchRotate, _PointerInteraction);

    var _super = _createSuper(PinchRotate);

    /**
     * @param {Options} [options] Options.
     */
    function PinchRotate(options) {
      var _this;

      _classCallCheck(this, PinchRotate);

      options = options ? options : {};
      var pointerOptions =
      /** @type {import("./Pointer.js").Options} */
      options;

      if (!pointerOptions.stopDown) {
        pointerOptions.stopDown = FALSE;
      }

      _this = _super.call(this, pointerOptions);
      /**
       * @private
       * @type {import("../coordinate.js").Coordinate}
       */

      _this.anchor_ = null;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.lastAngle_ = undefined;
      /**
       * @private
       * @type {boolean}
       */

      _this.rotating_ = false;
      /**
       * @private
       * @type {number}
       */

      _this.rotationDelta_ = 0.0;
      /**
       * @private
       * @type {number}
       */

      _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 250;
      return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */


    _createClass(PinchRotate, [{
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {
        var rotationDelta = 0.0;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1]; // angle between touches

        var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

        if (this.lastAngle_ !== undefined) {
          var delta = angle - this.lastAngle_;
          this.rotationDelta_ += delta;

          if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
            this.rotating_ = true;
          }

          rotationDelta = delta;
        }

        this.lastAngle_ = angle;
        var map = mapBrowserEvent.map;
        var view = map.getView();

        if (view.getConstraints().rotation === disable) {
          return;
        } // rotate anchor point.
        // FIXME: should be the intersection point between the lines:
        //     touch0,touch1 and previousTouch0,previousTouch1


        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid$1 = centroid(this.targetPointers);
        centroid$1[0] -= viewportPosition.left;
        centroid$1[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1); // rotate

        if (this.rotating_) {
          map.render();
          view.adjustRotationInternal(rotationDelta, this.anchor_);
        }
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          view.endInteraction(this.duration_);
          return false;
        } else {
          return true;
        }
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
          var map = mapBrowserEvent.map;
          this.anchor_ = null;
          this.lastAngle_ = undefined;
          this.rotating_ = false;
          this.rotationDelta_ = 0.0;

          if (!this.handlingDownUpSequence) {
            map.getView().beginInteraction();
          }

          return true;
        } else {
          return false;
        }
      }
    }]);

    return PinchRotate;
  }(PointerInteraction);

  /**
   * @typedef {Object} Options
   * @property {number} [duration=400] Animation duration in milliseconds.
   */

  /**
   * @classdesc
   * Allows the user to zoom the map by pinching with two fingers
   * on a touch screen.
   * @api
   */

  var PinchZoom = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(PinchZoom, _PointerInteraction);

    var _super = _createSuper(PinchZoom);

    /**
     * @param {Options} [options] Options.
     */
    function PinchZoom(options) {
      var _this;

      _classCallCheck(this, PinchZoom);

      options = options ? options : {};
      var pointerOptions =
      /** @type {import("./Pointer.js").Options} */
      options;

      if (!pointerOptions.stopDown) {
        pointerOptions.stopDown = FALSE;
      }

      _this = _super.call(this, pointerOptions);
      /**
       * @private
       * @type {import("../coordinate.js").Coordinate}
       */

      _this.anchor_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.duration_ = options.duration !== undefined ? options.duration : 400;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.lastDistance_ = undefined;
      /**
       * @private
       * @type {number}
       */

      _this.lastScaleDelta_ = 1;
      return _this;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */


    _createClass(PinchZoom, [{
      key: "handleDragEvent",
      value: function handleDragEvent(mapBrowserEvent) {
        var scaleDelta = 1.0;
        var touch0 = this.targetPointers[0];
        var touch1 = this.targetPointers[1];
        var dx = touch0.clientX - touch1.clientX;
        var dy = touch0.clientY - touch1.clientY; // distance between touches

        var distance = Math.sqrt(dx * dx + dy * dy);

        if (this.lastDistance_ !== undefined) {
          scaleDelta = this.lastDistance_ / distance;
        }

        this.lastDistance_ = distance;
        var map = mapBrowserEvent.map;
        var view = map.getView();

        if (scaleDelta != 1.0) {
          this.lastScaleDelta_ = scaleDelta;
        } // scale anchor point.


        var viewportPosition = map.getViewport().getBoundingClientRect();
        var centroid$1 = centroid(this.targetPointers);
        centroid$1[0] -= viewportPosition.left;
        centroid$1[1] -= viewportPosition.top;
        this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1); // scale, bypass the resolution constraint

        map.render();
        view.adjustResolutionInternal(scaleDelta, this.anchor_);
      }
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleUpEvent",
      value: function handleUpEvent(mapBrowserEvent) {
        if (this.targetPointers.length < 2) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
          view.endInteraction(this.duration_, direction);
          return false;
        } else {
          return true;
        }
      }
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */

    }, {
      key: "handleDownEvent",
      value: function handleDownEvent(mapBrowserEvent) {
        if (this.targetPointers.length >= 2) {
          var map = mapBrowserEvent.map;
          this.anchor_ = null;
          this.lastDistance_ = undefined;
          this.lastScaleDelta_ = 1;

          if (!this.handlingDownUpSequence) {
            map.getView().beginInteraction();
          }

          return true;
        } else {
          return false;
        }
      }
    }]);

    return PinchZoom;
  }(PointerInteraction);

  /**
   * @module ol/interaction/defaults
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
   * desired.
   * @property {boolean} [onFocusOnly=false] Interact only when the map has the
   * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
   * useful when page scroll is desired for maps that do not have the browser's
   * focus.
   * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
   * desired.
   * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
   * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
   * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
   * @property {boolean} [dragPan=true] Whether drag pan is desired.
   * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
   * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
   * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
   * @property {number} [zoomDuration] Duration of the zoom animation in
   * milliseconds.
   */

  /**
   * Set of interactions included in maps by default. Specific interactions can be
   * excluded by setting the appropriate option to false in the constructor
   * options, but the order of the interactions is fixed.  If you want to specify
   * a different order for interactions, you will need to create your own
   * {@link module:ol/interaction/Interaction~Interaction} instances and insert
   * them into a {@link module:ol/Collection~Collection} in the order you want
   * before creating your {@link module:ol/Map~Map} instance. Changing the order can
   * be of interest if the event propagation needs to be stopped at a point.
   * The default set of interactions, in sequence, is:
   * * {@link module:ol/interaction/DragRotate~DragRotate}
   * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
   * * {@link module:ol/interaction/DragPan~DragPan}
   * * {@link module:ol/interaction/PinchRotate~PinchRotate}
   * * {@link module:ol/interaction/PinchZoom~PinchZoom}
   * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
   * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
   * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
   * * {@link module:ol/interaction/DragZoom~DragZoom}
   *
   * @param {DefaultsOptions} [options] Defaults options.
   * @return {Collection<import("./Interaction.js").default>}
   * A collection of interactions to be used with the {@link module:ol/Map~Map}
   * constructor's `interactions` option.
   * @api
   */

  function defaults(options) {
    options = options ? options : {};
    /** @type {Collection<import("./Interaction.js").default>} */

    var interactions = new Collection();
    var kinetic = new Kinetic(-0.005, 0.05, 100);
    var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

    if (altShiftDragRotate) {
      interactions.push(new DragRotate());
    }

    var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

    if (doubleClickZoom) {
      interactions.push(new DoubleClickZoom({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      }));
    }

    var dragPan = options.dragPan !== undefined ? options.dragPan : true;

    if (dragPan) {
      interactions.push(new DragPan({
        onFocusOnly: options.onFocusOnly,
        kinetic: kinetic
      }));
    }

    var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

    if (pinchRotate) {
      interactions.push(new PinchRotate());
    }

    var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

    if (pinchZoom) {
      interactions.push(new PinchZoom({
        duration: options.zoomDuration
      }));
    }

    var keyboard = options.keyboard !== undefined ? options.keyboard : true;

    if (keyboard) {
      interactions.push(new KeyboardPan());
      interactions.push(new KeyboardZoom({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      }));
    }

    var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

    if (mouseWheelZoom) {
      interactions.push(new MouseWheelZoom({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      }));
    }

    var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

    if (shiftDragZoom) {
      interactions.push(new DragZoom({
        duration: options.zoomDuration
      }));
    }

    return interactions;
  }

  /**
   * @module ol/size
   */
  /**
   * Determines if a size has a positive area.
   * @param {Size} size The size to test.
   * @return {boolean} The size has a positive area.
   */

  function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
  }
  /**
   * Returns a size scaled by a ratio. The result will be an array of integers.
   * @param {Size} size Size.
   * @param {number} ratio Ratio.
   * @param {Size} [dest] Optional reusable size array.
   * @return {Size} The scaled size.
   */

  function scale(size, ratio, dest) {
    if (dest === undefined) {
      dest = [0, 0];
    }

    dest[0] = size[0] * ratio + 0.5 | 0;
    dest[1] = size[1] * ratio + 0.5 | 0;
    return dest;
  }
  /**
   * Returns an `Size` array for the passed in number (meaning: square) or
   * `Size` array.
   * (meaning: non-square),
   * @param {number|Size} size Width and height.
   * @param {Size} [dest] Optional reusable size array.
   * @return {Size} Size.
   * @api
   */

  function toSize(size, dest) {
    if (Array.isArray(size)) {
      return size;
    } else {
      if (dest === undefined) {
        dest = [size, size];
      } else {
        dest[0] = size;
        dest[1] = size;
      }

      return dest;
    }
  }

  /**
   * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
   * be used in applications.
   * @typedef {Object} FrameState
   * @property {number} pixelRatio The pixel ratio of the frame.
   * @property {number} time The time when rendering of the frame was requested.
   * @property {import("./View.js").State} viewState The state of the current view.
   * @property {boolean} animate Animate.
   * @property {import("./transform.js").Transform} coordinateToPixelTransform CoordinateToPixelTransform.
   * @property {import("rbush").default} declutterTree DeclutterTree.
   * @property {null|import("./extent.js").Extent} extent Extent.
   * @property {import("./extent.js").Extent} [nextExtent] Next extent during an animation series.
   * @property {number} index Index.
   * @property {Array<import("./layer/Layer.js").State>} layerStatesArray LayerStatesArray.
   * @property {number} layerIndex LayerIndex.
   * @property {import("./transform.js").Transform} pixelToCoordinateTransform PixelToCoordinateTransform.
   * @property {Array<PostRenderFunction>} postRenderFunctions PostRenderFunctions.
   * @property {import("./size.js").Size} size Size.
   * @property {TileQueue} tileQueue TileQueue.
   * @property {!Object<string, Object<string, boolean>>} usedTiles UsedTiles.
   * @property {Array<number>} viewHints ViewHints.
   * @property {!Object<string, Object<string, boolean>>} wantedTiles WantedTiles.
   * @property {string} mapId The id of the map.
   * @property {Object<string, boolean>} renderTargets Identifiers of previously rendered elements.
   */

  /**
   * @typedef {function(Map, ?FrameState): any} PostRenderFunction
   */

  /**
   * @typedef {Object} AtPixelOptions
   * @property {undefined|function(import("./layer/Layer.js").default<import("./source/Source").default>): boolean} [layerFilter] Layer filter
   * function. The filter function will receive one argument, the
   * {@link module:ol/layer/Layer~Layer layer-candidate} and it should return a boolean value.
   * Only layers which are visible and for which this function returns `true`
   * will be tested for features. By default, all visible layers will be tested.
   * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
   * inside the radius around the given position will be checked for features.
   * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for wrapped geometries inside the range of
   *   +/- 1 world width. Works only if a projection is used that can be wrapped.
   */

  /**
   * @typedef {Object} MapOptionsInternal
   * @property {Collection<import("./control/Control.js").default>} [controls] Controls.
   * @property {Collection<import("./interaction/Interaction.js").default>} [interactions] Interactions.
   * @property {HTMLElement|Document} keyboardEventTarget KeyboardEventTarget.
   * @property {Collection<import("./Overlay.js").default>} overlays Overlays.
   * @property {Object<string, *>} values Values.
   */

  /**
   * @typedef {import("./ObjectEventType").Types|'change:layergroup'|'change:size'|'change:target'|'change:view'} MapObjectEventTypes
   */

  /***
   * @template Return
   * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
   *    import("./Observable").OnSignature<MapObjectEventTypes, import("./Object").ObjectEvent, Return> &
   *    import("./Observable").OnSignature<import("./MapBrowserEventType").Types, import("./MapBrowserEvent").default, Return> &
   *    import("./Observable").OnSignature<import("./MapEventType").Types, import("./MapEvent").default, Return> &
   *    import("./Observable").OnSignature<import("./render/EventType").MapRenderEventTypes, import("./render/Event").default, Return> &
   *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|MapObjectEventTypes|
   *      import("./MapBrowserEventType").Types|import("./MapEventType").Types|
   *      import("./render/EventType").MapRenderEventTypes, Return>} MapEventHandler
   */

  /**
   * Object literal with config options for the map.
   * @typedef {Object} MapOptions
   * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
   * Controls initially added to the map. If not specified,
   * {@link module:ol/control/defaults.defaults} is used.
   * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
   * physical pixels and device-independent pixels (dips) on the device.
   * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
   * Interactions that are initially added to the map. If not specified,
   * {@link module:ol/interaction/defaults.defaults} is used.
   * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
   * listen to keyboard events on. This determines when the `KeyboardPan` and
   * `KeyboardZoom` interactions trigger. For example, if this option is set to
   * `document` the keyboard interactions will always trigger. If this option is
   * not specified, the element the library listens to keyboard events on is the
   * map target (i.e. the user-provided div for the map). If this is not
   * `document`, the target element needs to be focused for key events to be
   * emitted, requiring that the target element has a `tabindex` attribute.
   * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
   * Layers. If this is not defined, a map with no layers will be rendered. Note
   * that layers are rendered in the order supplied, so if you want, for example,
   * a vector layer to appear on top of a tile layer, it must come after the tile
   * layer.
   * @property {number} [maxTilesLoading=16] Maximum number tiles to load
   * simultaneously.
   * @property {number} [moveTolerance=1] The minimum distance in pixels the
   * cursor must move to be detected as a map move event instead of a click.
   * Increasing this value can make it easier to click on the map.
   * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
   * Overlays initially added to the map. By default, no overlays are added.
   * @property {HTMLElement|string} [target] The container for the map, either the
   * element itself or the `id` of the element. If not specified at construction
   * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
   * rendered. If passed by element, the container can be in a secondary document.
   * @property {View|Promise<import("./View.js").ViewOptions>} [view] The map's view.  No layer sources will be
   * fetched unless this is specified at construction time or through
   * {@link module:ol/Map~Map#setView}.
   */

  /**
   * @param {import("./layer/Base.js").default} layer Layer.
   */

  function removeLayerMapProperty(layer) {
    if (layer instanceof Layer) {
      layer.setMapInternal(null);
      return;
    }

    if (layer instanceof LayerGroup) {
      layer.getLayers().forEach(removeLayerMapProperty);
    }
  }
  /**
   * @param {import("./layer/Base.js").default} layer Layer.
   * @param {Map} map Map.
   */


  function setLayerMapProperty(layer, map) {
    if (layer instanceof Layer) {
      layer.setMapInternal(map);
      return;
    }

    if (layer instanceof LayerGroup) {
      var layers = layer.getLayers().getArray();

      for (var i = 0, ii = layers.length; i < ii; ++i) {
        setLayerMapProperty(layers[i], map);
      }
    }
  }
  /**
   * @classdesc
   * The map is the core component of OpenLayers. For a map to render, a view,
   * one or more layers, and a target container are needed:
   *
   *     import Map from 'ol/Map';
   *     import View from 'ol/View';
   *     import TileLayer from 'ol/layer/Tile';
   *     import OSM from 'ol/source/OSM';
   *
   *     const map = new Map({
   *       view: new View({
   *         center: [0, 0],
   *         zoom: 1,
   *       }),
   *       layers: [
   *         new TileLayer({
   *           source: new OSM(),
   *         }),
   *       ],
   *       target: 'map',
   *     });
   *
   * The above snippet creates a map using a {@link module:ol/layer/Tile~TileLayer} to
   * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
   * element with the id `map`.
   *
   * The constructor places a viewport container (with CSS class name
   * `ol-viewport`) in the target element (see `getViewport()`), and then two
   * further elements within the viewport: one with CSS class name
   * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
   * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
   * option of {@link module:ol/Overlay~Overlay} for the difference). The map
   * itself is placed in a further element within the viewport.
   *
   * Layers are stored as a {@link module:ol/Collection~Collection} in
   * layerGroups. A top-level group is provided by the library. This is what is
   * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
   * options are added to this group, and `addLayer` and `removeLayer` change the
   * layer collection in the group. `getLayers` is a convenience function for
   * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~LayerGroup}
   * is a subclass of {@link module:ol/layer/Base~BaseLayer}, so layers entered in the
   * options or added with `addLayer` can be groups, which can contain further
   * groups, and so on.
   *
   * @fires import("./MapBrowserEvent.js").MapBrowserEvent
   * @fires import("./MapEvent.js").MapEvent
   * @fires import("./render/Event.js").default#precompose
   * @fires import("./render/Event.js").default#postcompose
   * @fires import("./render/Event.js").default#rendercomplete
   * @api
   */


  var Map$1 = /*#__PURE__*/function (_BaseObject) {
    _inherits(Map, _BaseObject);

    var _super = _createSuper(Map);

    /**
     * @param {MapOptions} [options] Map options.
     */
    function Map(options) {
      var _this;

      _classCallCheck(this, Map);

      _this = _super.call(this);
      options = options || {};
      /***
       * @type {MapEventHandler<import("./events").EventsKey>}
       */

      _this.on;
      /***
       * @type {MapEventHandler<import("./events").EventsKey>}
       */

      _this.once;
      /***
       * @type {MapEventHandler<void>}
       */

      _this.un;
      var optionsInternal = createOptionsInternal(options);
      /**
       * @private
       * @type {boolean|undefined}
       */

      _this.renderComplete_;
      /**
       * @private
       * @type {boolean}
       */

      _this.loaded_ = true;
      /** @private */

      _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_assertThisInitialized(_this));
      /**
       * @type {number}
       * @private
       */

      _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
      /**
       * @private
       * @type {number}
       */

      _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : DEVICE_PIXEL_RATIO;
      /**
       * @private
       * @type {*}
       */

      _this.postRenderTimeoutHandle_;
      /**
       * @private
       * @type {number|undefined}
       */

      _this.animationDelayKey_;
      /**
       * @private
       */

      _this.animationDelay_ = _this.animationDelay_.bind(_assertThisInitialized(_this));
      /**
       * @private
       * @type {import("./transform.js").Transform}
       */

      _this.coordinateToPixelTransform_ = create$1();
      /**
       * @private
       * @type {import("./transform.js").Transform}
       */

      _this.pixelToCoordinateTransform_ = create$1();
      /**
       * @private
       * @type {number}
       */

      _this.frameIndex_ = 0;
      /**
       * @private
       * @type {?FrameState}
       */

      _this.frameState_ = null;
      /**
       * The extent at the previous 'moveend' event.
       * @private
       * @type {import("./extent.js").Extent}
       */

      _this.previousExtent_ = null;
      /**
       * @private
       * @type {?import("./events.js").EventsKey}
       */

      _this.viewPropertyListenerKey_ = null;
      /**
       * @private
       * @type {?import("./events.js").EventsKey}
       */

      _this.viewChangeListenerKey_ = null;
      /**
       * @private
       * @type {?Array<import("./events.js").EventsKey>}
       */

      _this.layerGroupPropertyListenerKeys_ = null;
      /**
       * @private
       * @type {!HTMLElement}
       */

      _this.viewport_ = document.createElement('div');
      _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
      _this.viewport_.style.position = 'relative';
      _this.viewport_.style.overflow = 'hidden';
      _this.viewport_.style.width = '100%';
      _this.viewport_.style.height = '100%';
      /**
       * @private
       * @type {!HTMLElement}
       */

      _this.overlayContainer_ = document.createElement('div');
      _this.overlayContainer_.style.position = 'absolute';
      _this.overlayContainer_.style.zIndex = '0';
      _this.overlayContainer_.style.width = '100%';
      _this.overlayContainer_.style.height = '100%';
      _this.overlayContainer_.style.pointerEvents = 'none';
      _this.overlayContainer_.className = 'ol-overlaycontainer';

      _this.viewport_.appendChild(_this.overlayContainer_);
      /**
       * @private
       * @type {!HTMLElement}
       */


      _this.overlayContainerStopEvent_ = document.createElement('div');
      _this.overlayContainerStopEvent_.style.position = 'absolute';
      _this.overlayContainerStopEvent_.style.zIndex = '0';
      _this.overlayContainerStopEvent_.style.width = '100%';
      _this.overlayContainerStopEvent_.style.height = '100%';
      _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
      _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';

      _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
      /**
       * @private
       * @type {MapBrowserEventHandler}
       */


      _this.mapBrowserEventHandler_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.moveTolerance_ = options.moveTolerance;
      /**
       * @private
       * @type {HTMLElement|Document}
       */

      _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
      /**
       * @private
       * @type {?Array<import("./events.js").EventsKey>}
       */

      _this.targetChangeHandlerKeys_ = null;
      /**
       * @type {Collection<import("./control/Control.js").default>}
       * @protected
       */

      _this.controls = optionsInternal.controls || defaults$1();
      /**
       * @type {Collection<import("./interaction/Interaction.js").default>}
       * @protected
       */

      _this.interactions = optionsInternal.interactions || defaults({
        onFocusOnly: true
      });
      /**
       * @type {Collection<import("./Overlay.js").default>}
       * @private
       */

      _this.overlays_ = optionsInternal.overlays;
      /**
       * A lookup of overlays by id.
       * @private
       * @type {Object<string, import("./Overlay.js").default>}
       */

      _this.overlayIdIndex_ = {};
      /**
       * @type {import("./renderer/Map.js").default|null}
       * @private
       */

      _this.renderer_ = null;
      /**
       * @private
       * @type {!Array<PostRenderFunction>}
       */

      _this.postRenderFunctions_ = [];
      /**
       * @private
       * @type {TileQueue}
       */

      _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_assertThisInitialized(_this)), _this.handleTileChange_.bind(_assertThisInitialized(_this)));

      _this.addChangeListener(MapProperty.LAYERGROUP, _this.handleLayerGroupChanged_);

      _this.addChangeListener(MapProperty.VIEW, _this.handleViewChanged_);

      _this.addChangeListener(MapProperty.SIZE, _this.handleSizeChanged_);

      _this.addChangeListener(MapProperty.TARGET, _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map
      // is "defined" already.


      _this.setProperties(optionsInternal.values);

      var map = _assertThisInitialized(_this);

      if (options.view && !(options.view instanceof View)) {
        options.view.then(function (viewOptions) {
          map.setView(new View(viewOptions));
        });
      }

      _this.controls.addEventListener(CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      function (event) {
        event.element.setMap(this);
      }.bind(_assertThisInitialized(_this)));

      _this.controls.addEventListener(CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      function (event) {
        event.element.setMap(null);
      }.bind(_assertThisInitialized(_this)));

      _this.interactions.addEventListener(CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      function (event) {
        event.element.setMap(this);
      }.bind(_assertThisInitialized(_this)));

      _this.interactions.addEventListener(CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      function (event) {
        event.element.setMap(null);
      }.bind(_assertThisInitialized(_this)));

      _this.overlays_.addEventListener(CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      function (event) {
        this.addOverlayInternal_(event.element);
      }.bind(_assertThisInitialized(_this)));

      _this.overlays_.addEventListener(CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      function (event) {
        var id = event.element.getId();

        if (id !== undefined) {
          delete this.overlayIdIndex_[id.toString()];
        }

        event.element.setMap(null);
      }.bind(_assertThisInitialized(_this)));

      _this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       * @this {Map}
       */
      function (control) {
        control.setMap(this);
      }.bind(_assertThisInitialized(_this)));

      _this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       * @this {Map}
       */
      function (interaction) {
        interaction.setMap(this);
      }.bind(_assertThisInitialized(_this)));

      _this.overlays_.forEach(_this.addOverlayInternal_.bind(_assertThisInitialized(_this)));

      return _this;
    }
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */


    _createClass(Map, [{
      key: "addControl",
      value: function addControl(control) {
        this.getControls().push(control);
      }
      /**
       * Add the given interaction to the map. If you want to add an interaction
       * at another point of the collection use `getInteractions()` and the methods
       * available on {@link module:ol/Collection~Collection}. This can be used to
       * stop the event propagation from the handleEvent function. The interactions
       * get to handle the events in the reverse order of this collection.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
       * @api
       */

    }, {
      key: "addInteraction",
      value: function addInteraction(interaction) {
        this.getInteractions().push(interaction);
      }
      /**
       * Adds the given layer to the top of this map. If you want to add a layer
       * elsewhere in the stack, use `getLayers()` and the methods available on
       * {@link module:ol/Collection~Collection}.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @api
       */

    }, {
      key: "addLayer",
      value: function addLayer(layer) {
        var layers = this.getLayerGroup().getLayers();
        layers.push(layer);
      }
      /**
       * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
       * @private
       */

    }, {
      key: "handleLayerAdd_",
      value: function handleLayerAdd_(event) {
        setLayerMapProperty(event.layer, this);
      }
      /**
       * Add the given overlay to the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @api
       */

    }, {
      key: "addOverlay",
      value: function addOverlay(overlay) {
        this.getOverlays().push(overlay);
      }
      /**
       * This deals with map's overlay collection changes.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @private
       */

    }, {
      key: "addOverlayInternal_",
      value: function addOverlayInternal_(overlay) {
        var id = overlay.getId();

        if (id !== undefined) {
          this.overlayIdIndex_[id.toString()] = overlay;
        }

        overlay.setMap(this);
      }
      /**
       *
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        this.controls.clear();
        this.interactions.clear();
        this.overlays_.clear();
        this.setTarget(null);

        _get(_getPrototypeOf(Map.prototype), "disposeInternal", this).call(this);
      }
      /**
       * Detect features that intersect a pixel on the viewport, and execute a
       * callback with each intersecting feature. Layers included in the detection can
       * be configured through the `layerFilter` option in `options`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
       *     called with two arguments. The first argument is one
       *     {@link module:ol/Feature~Feature feature} or
       *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
       *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
       *     unmanaged layers. To stop detection, callback functions can return a
       *     truthy value.
       * @param {AtPixelOptions} [options] Optional options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template T
       * @api
       */

    }, {
      key: "forEachFeatureAtPixel",
      value: function forEachFeatureAtPixel(pixel, callback, options) {
        if (!this.frameState_ || !this.renderer_) {
          return;
        }

        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;
        var checkWrapped = options.checkWrapped !== false;
        return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
      }
      /**
       * Get all features that intersect a pixel on the viewport.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions} [options] Optional options.
       * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
       * an empty array if none were found.
       * @api
       */

    }, {
      key: "getFeaturesAtPixel",
      value: function getFeaturesAtPixel(pixel, options) {
        var features = [];
        this.forEachFeatureAtPixel(pixel, function (feature) {
          features.push(feature);
        }, options);
        return features;
      }
      /**
       * Get all layers from all layer groups.
       * @return {Array<import("./layer/Layer.js").default>} Layers.
       * @api
       */

    }, {
      key: "getAllLayers",
      value: function getAllLayers() {
        var layers = [];

        function addLayersFrom(layerGroup) {
          layerGroup.forEach(function (layer) {
            if (layer instanceof LayerGroup) {
              addLayersFrom(layer.getLayers());
            } else {
              layers.push(layer);
            }
          });
        }

        addLayersFrom(this.getLayers());
        return layers;
      }
      /**
       * Detect if features intersect a pixel on the viewport. Layers included in the
       * detection can be configured through the `layerFilter` option.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions} [options] Optional options.
       * @return {boolean} Is there a feature at the given pixel?
       * @api
       */

    }, {
      key: "hasFeatureAtPixel",
      value: function hasFeatureAtPixel(pixel, options) {
        if (!this.frameState_ || !this.renderer_) {
          return false;
        }

        var coordinate = this.getCoordinateFromPixelInternal(pixel);
        options = options !== undefined ? options : {};
        var layerFilter = options.layerFilter !== undefined ? options.layerFilter : TRUE;
        var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
        var checkWrapped = options.checkWrapped !== false;
        return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
      }
      /**
       * Returns the coordinate in user projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       * @api
       */

    }, {
      key: "getEventCoordinate",
      value: function getEventCoordinate(event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
      }
      /**
       * Returns the coordinate in view projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       */

    }, {
      key: "getEventCoordinateInternal",
      value: function getEventCoordinateInternal(event) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
      }
      /**
       * Returns the map pixel position for a browser event relative to the viewport.
       * @param {UIEvent} event Event.
       * @return {import("./pixel.js").Pixel} Pixel.
       * @api
       */

    }, {
      key: "getEventPixel",
      value: function getEventPixel(event) {
        var viewportPosition = this.viewport_.getBoundingClientRect();
        var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
        'changedTouches' in event ?
        /** @type {TouchEvent} */
        event.changedTouches[0] :
        /** @type {MouseEvent} */
        event;
        return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
      }
      /**
       * Get the target in which this map is rendered.
       * Note that this returns what is entered as an option or in setTarget:
       * if that was an element, it returns an element; if a string, it returns that.
       * @return {HTMLElement|string|undefined} The Element or id of the Element that the
       *     map is rendered in.
       * @observable
       * @api
       */

    }, {
      key: "getTarget",
      value: function getTarget() {
        return (
          /** @type {HTMLElement|string|undefined} */
          this.get(MapProperty.TARGET)
        );
      }
      /**
       * Get the DOM element into which this map is rendered. In contrast to
       * `getTarget` this method always return an `Element`, or `null` if the
       * map has no target.
       * @return {HTMLElement} The element that the map is rendered in.
       * @api
       */

    }, {
      key: "getTargetElement",
      value: function getTargetElement() {
        var target = this.getTarget();

        if (target !== undefined) {
          return typeof target === 'string' ? document.getElementById(target) : target;
        } else {
          return null;
        }
      }
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * user projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       * @api
       */

    }, {
      key: "getCoordinateFromPixel",
      value: function getCoordinateFromPixel(pixel) {
        return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
      }
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * map view projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       */

    }, {
      key: "getCoordinateFromPixelInternal",
      value: function getCoordinateFromPixelInternal(pixel) {
        var frameState = this.frameState_;

        if (!frameState) {
          return null;
        } else {
          return apply(frameState.pixelToCoordinateTransform, pixel.slice());
        }
      }
      /**
       * Get the map controls. Modifying this collection changes the controls
       * associated with the map.
       * @return {Collection<import("./control/Control.js").default>} Controls.
       * @api
       */

    }, {
      key: "getControls",
      value: function getControls() {
        return this.controls;
      }
      /**
       * Get the map overlays. Modifying this collection changes the overlays
       * associated with the map.
       * @return {Collection<import("./Overlay.js").default>} Overlays.
       * @api
       */

    }, {
      key: "getOverlays",
      value: function getOverlays() {
        return this.overlays_;
      }
      /**
       * Get an overlay by its identifier (the value returned by overlay.getId()).
       * Note that the index treats string and numeric identifiers as the same. So
       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
       * @param {string|number} id Overlay identifier.
       * @return {import("./Overlay.js").default} Overlay.
       * @api
       */

    }, {
      key: "getOverlayById",
      value: function getOverlayById(id) {
        var overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
      }
      /**
       * Get the map interactions. Modifying this collection changes the interactions
       * associated with the map.
       *
       * Interactions are used for e.g. pan, zoom and rotate.
       * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
       * @api
       */

    }, {
      key: "getInteractions",
      value: function getInteractions() {
        return this.interactions;
      }
      /**
       * Get the layergroup associated with this map.
       * @return {LayerGroup} A layer group containing the layers in this map.
       * @observable
       * @api
       */

    }, {
      key: "getLayerGroup",
      value: function getLayerGroup() {
        return (
          /** @type {LayerGroup} */
          this.get(MapProperty.LAYERGROUP)
        );
      }
      /**
       * Clear any existing layers and add layers to the map.
       * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
       * @api
       */

    }, {
      key: "setLayers",
      value: function setLayers(layers) {
        var group = this.getLayerGroup();

        if (layers instanceof Collection) {
          group.setLayers(layers);
          return;
        }

        var collection = group.getLayers();
        collection.clear();
        collection.extend(layers);
      }
      /**
       * Get the collection of layers associated with this map.
       * @return {!Collection<import("./layer/Base.js").default>} Layers.
       * @api
       */

    }, {
      key: "getLayers",
      value: function getLayers() {
        var layers = this.getLayerGroup().getLayers();
        return layers;
      }
      /**
       * @return {boolean} Layers have sources that are still loading.
       */

    }, {
      key: "getLoadingOrNotReady",
      value: function getLoadingOrNotReady() {
        var layerStatesArray = this.getLayerGroup().getLayerStatesArray();

        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
          var state = layerStatesArray[i];

          if (!state.visible) {
            continue;
          }

          var renderer = state.layer.getRenderer();

          if (renderer && !renderer.ready) {
            return true;
          }

          var source = state.layer.getSource();

          if (source && source.loading) {
            return true;
          }
        }

        return false;
      }
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the user
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       * @api
       */

    }, {
      key: "getPixelFromCoordinate",
      value: function getPixelFromCoordinate(coordinate) {
        var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(viewCoordinate);
      }
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the map view
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       */

    }, {
      key: "getPixelFromCoordinateInternal",
      value: function getPixelFromCoordinateInternal(coordinate) {
        var frameState = this.frameState_;

        if (!frameState) {
          return null;
        } else {
          return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
        }
      }
      /**
       * Get the map renderer.
       * @return {import("./renderer/Map.js").default|null} Renderer
       */

    }, {
      key: "getRenderer",
      value: function getRenderer() {
        return this.renderer_;
      }
      /**
       * Get the size of this map.
       * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
       * @observable
       * @api
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return (
          /** @type {import("./size.js").Size|undefined} */
          this.get(MapProperty.SIZE)
        );
      }
      /**
       * Get the view associated with this map. A view manages properties such as
       * center and resolution.
       * @return {View} The view that controls this map.
       * @observable
       * @api
       */

    }, {
      key: "getView",
      value: function getView() {
        return (
          /** @type {View} */
          this.get(MapProperty.VIEW)
        );
      }
      /**
       * Get the element that serves as the map viewport.
       * @return {HTMLElement} Viewport.
       * @api
       */

    }, {
      key: "getViewport",
      value: function getViewport() {
        return this.viewport_;
      }
      /**
       * Get the element that serves as the container for overlays.  Elements added to
       * this container will let mousedown and touchstart events through to the map,
       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
       * events.
       * @return {!HTMLElement} The map's overlay container.
       */

    }, {
      key: "getOverlayContainer",
      value: function getOverlayContainer() {
        return this.overlayContainer_;
      }
      /**
       * Get the element that serves as a container for overlays that don't allow
       * event propagation. Elements added to this container won't let mousedown and
       * touchstart events through to the map, so clicks and gestures on an overlay
       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
       * @return {!HTMLElement} The map's overlay container that stops events.
       */

    }, {
      key: "getOverlayContainerStopEvent",
      value: function getOverlayContainerStopEvent() {
        return this.overlayContainerStopEvent_;
      }
      /**
       * @return {!Document} The document where the map is displayed.
       */

    }, {
      key: "getOwnerDocument",
      value: function getOwnerDocument() {
        var targetElement = this.getTargetElement();
        return targetElement ? targetElement.ownerDocument : document;
      }
      /**
       * @param {import("./Tile.js").default} tile Tile.
       * @param {string} tileSourceKey Tile source key.
       * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
       * @param {number} tileResolution Tile resolution.
       * @return {number} Tile priority.
       */

    }, {
      key: "getTilePriority",
      value: function getTilePriority$1(tile, tileSourceKey, tileCenter, tileResolution) {
        return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
      }
      /**
       * @param {UIEvent} browserEvent Browser event.
       * @param {string} [type] Type.
       */

    }, {
      key: "handleBrowserEvent",
      value: function handleBrowserEvent(browserEvent, type) {
        type = type || browserEvent.type;
        var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
      }
      /**
       * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
       */

    }, {
      key: "handleMapBrowserEvent",
      value: function handleMapBrowserEvent(mapBrowserEvent) {
        if (!this.frameState_) {
          // With no view defined, we cannot translate pixels into geographical
          // coordinates so interactions cannot be used.
          return;
        }

        var originalEvent =
        /** @type {PointerEvent} */
        mapBrowserEvent.originalEvent;
        var eventType = originalEvent.type;

        if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {
          var doc = this.getOwnerDocument();
          var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
          var target =
          /** @type {Node} */
          originalEvent.target;

          if ( // Abort if the target is a child of the container for elements whose events are not meant
          // to be handled by map interactions.
          this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
          // It's possible for the target to no longer be in the page if it has been removed in an
          // event listener, this might happen in a Control that recreates it's content based on
          // user interaction either manually or via a render in something like https://reactjs.org/
          !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
            return;
          }
        }

        mapBrowserEvent.frameState = this.frameState_;

        if (this.dispatchEvent(mapBrowserEvent) !== false) {
          var interactionsArray = this.getInteractions().getArray().slice();

          for (var i = interactionsArray.length - 1; i >= 0; i--) {
            var interaction = interactionsArray[i];

            if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
              continue;
            }

            var cont = interaction.handleEvent(mapBrowserEvent);

            if (!cont || mapBrowserEvent.propagationStopped) {
              break;
            }
          }
        }
      }
      /**
       * @protected
       */

    }, {
      key: "handlePostRender",
      value: function handlePostRender() {
        var frameState = this.frameState_; // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.

        var tileQueue = this.tileQueue_;

        if (!tileQueue.isEmpty()) {
          var maxTotalLoading = this.maxTilesLoading_;
          var maxNewLoads = maxTotalLoading;

          if (frameState) {
            var hints = frameState.viewHints;

            if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
              var lowOnFrameBudget = Date.now() - frameState.time > 8;
              maxTotalLoading = lowOnFrameBudget ? 0 : 8;
              maxNewLoads = lowOnFrameBudget ? 0 : 2;
            }
          }

          if (tileQueue.getTilesLoading() < maxTotalLoading) {
            tileQueue.reprioritize(); // FIXME only call if view has changed

            tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
          }
        }

        if (frameState && this.renderer_ && !frameState.animate) {
          if (this.renderComplete_ === true) {
            if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {
              this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, frameState);
            }

            if (this.loaded_ === false) {
              this.loaded_ = true;
              this.dispatchEvent(new MapEvent(MapEventType.LOADEND, this, frameState));
            }
          } else if (this.loaded_ === true) {
            this.loaded_ = false;
            this.dispatchEvent(new MapEvent(MapEventType.LOADSTART, this, frameState));
          }
        }

        var postRenderFunctions = this.postRenderFunctions_;

        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
          postRenderFunctions[i](this, frameState);
        }

        postRenderFunctions.length = 0;
      }
      /**
       * @private
       */

    }, {
      key: "handleSizeChanged_",
      value: function handleSizeChanged_() {
        if (this.getView() && !this.getView().getAnimating()) {
          this.getView().resolveConstraints(0);
        }

        this.render();
      }
      /**
       * @private
       */

    }, {
      key: "handleTargetChanged_",
      value: function handleTargetChanged_() {
        if (this.mapBrowserEventHandler_) {
          for (var i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
            unlistenByKey(this.targetChangeHandlerKeys_[i]);
          }

          this.targetChangeHandlerKeys_ = null;
          this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
          this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
          this.mapBrowserEventHandler_.dispose();
          this.mapBrowserEventHandler_ = null;
          removeNode$1(this.viewport_);
        } // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.


        var targetElement = this.getTargetElement();

        if (!targetElement) {
          if (this.renderer_) {
            clearTimeout(this.postRenderTimeoutHandle_);
            this.postRenderTimeoutHandle_ = undefined;
            this.postRenderFunctions_.length = 0;
            this.renderer_.dispose();
            this.renderer_ = null;
          }

          if (this.animationDelayKey_) {
            cancelAnimationFrame(this.animationDelayKey_);
            this.animationDelayKey_ = undefined;
          }
        } else {
          targetElement.appendChild(this.viewport_);

          if (!this.renderer_) {
            this.renderer_ = new CompositeMapRenderer(this);
          }

          this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);

          for (var key in MapBrowserEventType) {
            this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
          }

          this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
          this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {
            passive: false
          } : false);
          var defaultView = this.getOwnerDocument().defaultView;
          var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
          this.targetChangeHandlerKeys_ = [listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this), listen(defaultView, EventType.RESIZE, this.updateSize, this)];
        }

        this.updateSize(); // updateSize calls setSize, so no need to call this.render
        // ourselves here.
      }
      /**
       * @private
       */

    }, {
      key: "handleTileChange_",
      value: function handleTileChange_() {
        this.render();
      }
      /**
       * @private
       */

    }, {
      key: "handleViewPropertyChanged_",
      value: function handleViewPropertyChanged_() {
        this.render();
      }
      /**
       * @private
       */

    }, {
      key: "handleViewChanged_",
      value: function handleViewChanged_() {
        if (this.viewPropertyListenerKey_) {
          unlistenByKey(this.viewPropertyListenerKey_);
          this.viewPropertyListenerKey_ = null;
        }

        if (this.viewChangeListenerKey_) {
          unlistenByKey(this.viewChangeListenerKey_);
          this.viewChangeListenerKey_ = null;
        }

        var view = this.getView();

        if (view) {
          this.updateViewportSize_();
          this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
          this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
          view.resolveConstraints(0);
        }

        this.render();
      }
      /**
       * @private
       */

    }, {
      key: "handleLayerGroupChanged_",
      value: function handleLayerGroupChanged_() {
        if (this.layerGroupPropertyListenerKeys_) {
          this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
          this.layerGroupPropertyListenerKeys_ = null;
        }

        var layerGroup = this.getLayerGroup();

        if (layerGroup) {
          this.handleLayerAdd_(new GroupEvent('addlayer', layerGroup));
          this.layerGroupPropertyListenerKeys_ = [listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(layerGroup, EventType.CHANGE, this.render, this), listen(layerGroup, 'addlayer', this.handleLayerAdd_, this), listen(layerGroup, 'removelayer', this.handleLayerRemove_, this)];
        }

        this.render();
      }
      /**
       * @return {boolean} Is rendered.
       */

    }, {
      key: "isRendered",
      value: function isRendered() {
        return !!this.frameState_;
      }
      /**
       * @private
       */

    }, {
      key: "animationDelay_",
      value: function animationDelay_() {
        this.animationDelayKey_ = undefined;
        this.renderFrame_(Date.now());
      }
      /**
       * Requests an immediate render in a synchronous manner.
       * @api
       */

    }, {
      key: "renderSync",
      value: function renderSync() {
        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
        }

        this.animationDelay_();
      }
      /**
       * Redraws all text after new fonts have loaded
       */

    }, {
      key: "redrawText",
      value: function redrawText() {
        var layerStates = this.getLayerGroup().getLayerStatesArray();

        for (var i = 0, ii = layerStates.length; i < ii; ++i) {
          var layer = layerStates[i].layer;

          if (layer.hasRenderer()) {
            layer.getRenderer().handleFontsChanged();
          }
        }
      }
      /**
       * Request a map rendering (at the next animation frame).
       * @api
       */

    }, {
      key: "render",
      value: function render() {
        if (this.renderer_ && this.animationDelayKey_ === undefined) {
          this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
        }
      }
      /**
       * Remove the given control from the map.
       * @param {import("./control/Control.js").default} control Control.
       * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
       *     if the control was not found).
       * @api
       */

    }, {
      key: "removeControl",
      value: function removeControl(control) {
        return this.getControls().remove(control);
      }
      /**
       * Remove the given interaction from the map.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
       * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
       *     undefined if the interaction was not found).
       * @api
       */

    }, {
      key: "removeInteraction",
      value: function removeInteraction(interaction) {
        return this.getInteractions().remove(interaction);
      }
      /**
       * Removes the given layer from the map.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
       *     layer was not found).
       * @api
       */

    }, {
      key: "removeLayer",
      value: function removeLayer(layer) {
        var layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
      }
      /**
       * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
       * @private
       */

    }, {
      key: "handleLayerRemove_",
      value: function handleLayerRemove_(event) {
        removeLayerMapProperty(event.layer);
      }
      /**
       * Remove the given overlay from the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
       *     if the overlay was not found).
       * @api
       */

    }, {
      key: "removeOverlay",
      value: function removeOverlay(overlay) {
        return this.getOverlays().remove(overlay);
      }
      /**
       * @param {number} time Time.
       * @private
       */

    }, {
      key: "renderFrame_",
      value: function renderFrame_(time) {
        var _this2 = this;

        var size = this.getSize();
        var view = this.getView();
        var previousFrameState = this.frameState_;
        /** @type {?FrameState} */

        var frameState = null;

        if (size !== undefined && hasArea(size) && view && view.isDef()) {
          var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
          var viewState = view.getState();
          frameState = {
            animate: false,
            coordinateToPixelTransform: this.coordinateToPixelTransform_,
            declutterTree: null,
            extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
            index: this.frameIndex_++,
            layerIndex: 0,
            layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
            pixelRatio: this.pixelRatio_,
            pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
            postRenderFunctions: [],
            size: size,
            tileQueue: this.tileQueue_,
            time: time,
            usedTiles: {},
            viewState: viewState,
            viewHints: viewHints,
            wantedTiles: {},
            mapId: getUid(this),
            renderTargets: {}
          };

          if (viewState.nextCenter && viewState.nextResolution) {
            var rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
            frameState.nextExtent = getForViewAndSize(viewState.nextCenter, viewState.nextResolution, rotation, size);
          }
        }

        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);

        if (frameState) {
          if (frameState.animate) {
            this.render();
          }

          Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

          if (previousFrameState) {
            var moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals$2(frameState.extent, this.previousExtent_);

            if (moveStart) {
              this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
              this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
            }
          }

          var idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$2(frameState.extent, this.previousExtent_);

          if (idle) {
            this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
            clone(frameState.extent, this.previousExtent_);
          }
        }

        this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
        this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : undefined;

        if (!this.postRenderTimeoutHandle_) {
          this.postRenderTimeoutHandle_ = setTimeout(function () {
            _this2.postRenderTimeoutHandle_ = undefined;

            _this2.handlePostRender();
          }, 0);
        }
      }
      /**
       * Sets the layergroup of this map.
       * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
       * @observable
       * @api
       */

    }, {
      key: "setLayerGroup",
      value: function setLayerGroup(layerGroup) {
        var oldLayerGroup = this.getLayerGroup();

        if (oldLayerGroup) {
          this.handleLayerRemove_(new GroupEvent('removelayer', oldLayerGroup));
        }

        this.set(MapProperty.LAYERGROUP, layerGroup);
      }
      /**
       * Set the size of this map.
       * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
       * @observable
       * @api
       */

    }, {
      key: "setSize",
      value: function setSize(size) {
        this.set(MapProperty.SIZE, size);
      }
      /**
       * Set the target element to render this map into.
       * @param {HTMLElement|string} [target] The Element or id of the Element
       *     that the map is rendered in.
       * @observable
       * @api
       */

    }, {
      key: "setTarget",
      value: function setTarget(target) {
        this.set(MapProperty.TARGET, target);
      }
      /**
       * Set the view for this map.
       * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
       * It is also possible to pass a promise that resolves to options for constructing a view.  This
       * alternative allows view properties to be resolved by sources or other components that load
       * view-related metadata.
       * @observable
       * @api
       */

    }, {
      key: "setView",
      value: function setView(view) {
        if (!view || view instanceof View) {
          this.set(MapProperty.VIEW, view);
          return;
        }

        this.set(MapProperty.VIEW, new View());
        var map = this;
        view.then(function (viewOptions) {
          map.setView(new View(viewOptions));
        });
      }
      /**
       * Force a recalculation of the map viewport size.  This should be called when
       * third-party code changes the size of the map viewport.
       * @api
       */

    }, {
      key: "updateSize",
      value: function updateSize() {
        var targetElement = this.getTargetElement();
        var size = undefined;

        if (targetElement) {
          var computedStyle = getComputedStyle(targetElement);
          var width = targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']);
          var height = targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth']);

          if (!isNaN(width) && !isNaN(height)) {
            size = [width, height];

            if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
              // eslint-disable-next-line
              console.warn("No map visible because the map container's width or height are 0.");
            }
          }
        }

        this.setSize(size);
        this.updateViewportSize_();
      }
      /**
       * Recomputes the viewport size and save it on the view object (if any)
       * @private
       */

    }, {
      key: "updateViewportSize_",
      value: function updateViewportSize_() {
        var view = this.getView();

        if (view) {
          var size = undefined;
          var computedStyle = getComputedStyle(this.viewport_);

          if (computedStyle.width && computedStyle.height) {
            size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];
          }

          view.setViewportSize(size);
        }
      }
    }]);

    return Map;
  }(BaseObject);
  /**
   * @param {MapOptions} options Map options.
   * @return {MapOptionsInternal} Internal map options.
   */


  function createOptionsInternal(options) {
    /**
     * @type {HTMLElement|Document}
     */
    var keyboardEventTarget = null;

    if (options.keyboardEventTarget !== undefined) {
      keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    }
    /**
     * @type {Object<string, *>}
     */


    var values = {};
    var layerGroup = options.layers && typeof
    /** @type {?} */
    options.layers.getLayers === 'function' ?
    /** @type {LayerGroup} */
    options.layers : new LayerGroup({
      layers:
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    });
    values[MapProperty.LAYERGROUP] = layerGroup;
    values[MapProperty.TARGET] = options.target;
    values[MapProperty.VIEW] = options.view instanceof View ? options.view : new View();
    /** @type {Collection<import("./control/Control.js").default>} */

    var controls;

    if (options.controls !== undefined) {
      if (Array.isArray(options.controls)) {
        controls = new Collection(options.controls.slice());
      } else {
        assert(typeof
        /** @type {?} */
        options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`

        controls = options.controls;
      }
    }
    /** @type {Collection<import("./interaction/Interaction").default>} */


    var interactions;

    if (options.interactions !== undefined) {
      if (Array.isArray(options.interactions)) {
        interactions = new Collection(options.interactions.slice());
      } else {
        assert(typeof
        /** @type {?} */
        options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`

        interactions = options.interactions;
      }
    }
    /** @type {Collection<import("./Overlay.js").default>} */


    var overlays;

    if (options.overlays !== undefined) {
      if (Array.isArray(options.overlays)) {
        overlays = new Collection(options.overlays.slice());
      } else {
        assert(typeof
        /** @type {?} */
        options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`

        overlays = options.overlays;
      }
    } else {
      overlays = new Collection();
    }

    return {
      controls: controls,
      interactions: interactions,
      keyboardEventTarget: keyboardEventTarget,
      overlays: overlays,
      values: values
    };
  }

  /**
   * @typedef {Object} Entry
   * @property {string} key_ Key.
   * @property {Object} newer Newer.
   * @property {Object} older Older.
   * @property {*} value_ Value.
   */

  /**
   * @classdesc
   * Implements a Least-Recently-Used cache where the keys do not conflict with
   * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
   * items from the cache is the responsibility of the user.
   *
   * @fires import("../events/Event.js").default
   * @template T
   */

  var LRUCache = /*#__PURE__*/function () {
    /**
     * @param {number} [highWaterMark] High water mark.
     */
    function LRUCache(highWaterMark) {
      _classCallCheck(this, LRUCache);

      /**
       * Desired max cache size after expireCache(). If set to 0, no cache entries
       * will be pruned at all.
       * @type {number}
       */
      this.highWaterMark = highWaterMark !== undefined ? highWaterMark : 2048;
      /**
       * @private
       * @type {number}
       */

      this.count_ = 0;
      /**
       * @private
       * @type {!Object<string, Entry>}
       */

      this.entries_ = {};
      /**
       * @private
       * @type {?Entry}
       */

      this.oldest_ = null;
      /**
       * @private
       * @type {?Entry}
       */

      this.newest_ = null;
    }
    /**
     * @return {boolean} Can expire cache.
     */


    _createClass(LRUCache, [{
      key: "canExpireCache",
      value: function canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
      }
      /**
       * Expire the cache.
       * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
       */

    }, {
      key: "expireCache",
      value: function expireCache(keep) {
        while (this.canExpireCache()) {
          this.pop();
        }
      }
      /**
       * FIXME empty description for jsdoc
       */

    }, {
      key: "clear",
      value: function clear() {
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
      }
      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */

    }, {
      key: "containsKey",
      value: function containsKey(key) {
        return this.entries_.hasOwnProperty(key);
      }
      /**
       * @param {function(T, string, LRUCache<T>): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       */

    }, {
      key: "forEach",
      value: function forEach(f) {
        var entry = this.oldest_;

        while (entry) {
          f(entry.value_, entry.key_, this);
          entry = entry.newer;
        }
      }
      /**
       * @param {string} key Key.
       * @param {*} [options] Options (reserved for subclasses).
       * @return {T} Value.
       */

    }, {
      key: "get",
      value: function get(key, options) {
        var entry = this.entries_[key];
        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

        if (entry === this.newest_) {
          return entry.value_;
        } else if (entry === this.oldest_) {
          this.oldest_ =
          /** @type {Entry} */
          this.oldest_.newer;
          this.oldest_.older = null;
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }

        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
      }
      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */

    }, {
      key: "remove",
      value: function remove(key) {
        var entry = this.entries_[key];
        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

        if (entry === this.newest_) {
          this.newest_ =
          /** @type {Entry} */
          entry.older;

          if (this.newest_) {
            this.newest_.newer = null;
          }
        } else if (entry === this.oldest_) {
          this.oldest_ =
          /** @type {Entry} */
          entry.newer;

          if (this.oldest_) {
            this.oldest_.older = null;
          }
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }

        delete this.entries_[key];
        --this.count_;
        return entry.value_;
      }
      /**
       * @return {number} Count.
       */

    }, {
      key: "getCount",
      value: function getCount() {
        return this.count_;
      }
      /**
       * @return {Array<string>} Keys.
       */

    }, {
      key: "getKeys",
      value: function getKeys() {
        var keys = new Array(this.count_);
        var i = 0;
        var entry;

        for (entry = this.newest_; entry; entry = entry.older) {
          keys[i++] = entry.key_;
        }

        return keys;
      }
      /**
       * @return {Array<T>} Values.
       */

    }, {
      key: "getValues",
      value: function getValues() {
        var values = new Array(this.count_);
        var i = 0;
        var entry;

        for (entry = this.newest_; entry; entry = entry.older) {
          values[i++] = entry.value_;
        }

        return values;
      }
      /**
       * @return {T} Last value.
       */

    }, {
      key: "peekLast",
      value: function peekLast() {
        return this.oldest_.value_;
      }
      /**
       * @return {string} Last key.
       */

    }, {
      key: "peekLastKey",
      value: function peekLastKey() {
        return this.oldest_.key_;
      }
      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */

    }, {
      key: "peekFirstKey",
      value: function peekFirstKey() {
        return this.newest_.key_;
      }
      /**
       * Return an entry without updating least recently used time.
       * @param {string} key Key.
       * @return {T} Value.
       */

    }, {
      key: "peek",
      value: function peek(key) {
        if (!this.containsKey(key)) {
          return undefined;
        }

        return this.entries_[key].value_;
      }
      /**
       * @return {T} value Value.
       */

    }, {
      key: "pop",
      value: function pop() {
        var entry = this.oldest_;
        delete this.entries_[entry.key_];

        if (entry.newer) {
          entry.newer.older = null;
        }

        this.oldest_ =
        /** @type {Entry} */
        entry.newer;

        if (!this.oldest_) {
          this.newest_ = null;
        }

        --this.count_;
        return entry.value_;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */

    }, {
      key: "replace",
      value: function replace(key, value) {
        this.get(key); // update `newest_`

        this.entries_[key].value_ = value;
      }
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */

    }, {
      key: "set",
      value: function set(key, value) {
        assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already

        var entry = {
          key_: key,
          newer: null,
          older: this.newest_,
          value_: value
        };

        if (!this.newest_) {
          this.oldest_ = entry;
        } else {
          this.newest_.newer = entry;
        }

        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
      }
      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */

    }, {
      key: "setSize",
      value: function setSize(size) {
        this.highWaterMark = size;
      }
    }]);

    return LRUCache;
  }();

  /**
   * A function that takes an {@link module:ol/Tile~Tile} for the tile and a
   * `{string}` for the url as arguments. The default is
   * ```js
   * source.setTileLoadFunction(function(tile, src) {
   *   tile.getImage().src = src;
   * });
   * ```
   * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
   * error handling:
   *
   * ```js
   * import TileState from 'ol/TileState';
   *
   * source.setTileLoadFunction(function(tile, src) {
   *   const xhr = new XMLHttpRequest();
   *   xhr.responseType = 'blob';
   *   xhr.addEventListener('loadend', function (evt) {
   *     const data = this.response;
   *     if (data !== undefined) {
   *       tile.getImage().src = URL.createObjectURL(data);
   *     } else {
   *       tile.setState(TileState.ERROR);
   *     }
   *   });
   *   xhr.addEventListener('error', function () {
   *     tile.setState(TileState.ERROR);
   *   });
   *   xhr.open('GET', src);
   *   xhr.send();
   * });
   * ```
   *
   * @typedef {function(Tile, string): void} LoadFunction
   * @api
   */

  /**
   * {@link module:ol/source/Tile~TileSource} sources use a function of this type to get
   * the url that provides a tile for a given tile coordinate.
   *
   * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
   * coordinate, a `{number}` representing the pixel ratio and a
   * {@link module:ol/proj/Projection~Projection} for the projection  as arguments
   * and returns a `{string}` representing the tile URL, or undefined if no tile
   * should be requested for the passed tile coordinate.
   *
   * @typedef {function(import("./tilecoord.js").TileCoord, number,
   *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
   * @api
   */

  /**
   * @typedef {Object} Options
   * @property {number} [transition=250] A duration for tile opacity
   * transitions in milliseconds. A duration of 0 disables the opacity transition.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   * @api
   */

  /**
   * @classdesc
   * Base class for tiles.
   *
   * @abstract
   */

  var Tile = /*#__PURE__*/function (_EventTarget) {
    _inherits(Tile, _EventTarget);

    var _super = _createSuper(Tile);

    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {Options} [options] Tile options.
     */
    function Tile(tileCoord, state, options) {
      var _this;

      _classCallCheck(this, Tile);

      _this = _super.call(this);
      options = options ? options : {};
      /**
       * @type {import("./tilecoord.js").TileCoord}
       */

      _this.tileCoord = tileCoord;
      /**
       * @protected
       * @type {import("./TileState.js").default}
       */

      _this.state = state;
      /**
       * An "interim" tile for this tile. The interim tile may be used while this
       * one is loading, for "smooth" transitions when changing params/dimensions
       * on the source.
       * @type {Tile}
       */

      _this.interimTile = null;
      /**
       * A key assigned to the tile. This is used by the tile source to determine
       * if this tile can effectively be used, or if a new tile should be created
       * and this one be used as an interim tile for this new tile.
       * @type {string}
       */

      _this.key = '';
      /**
       * The duration for the opacity transition.
       * @type {number}
       */

      _this.transition_ = options.transition === undefined ? 250 : options.transition;
      /**
       * Lookup of start times for rendering transitions.  If the start time is
       * equal to -1, the transition is complete.
       * @type {Object<string, number>}
       */

      _this.transitionStarts_ = {};
      /**
       * @type {boolean}
       */

      _this.interpolate = !!options.interpolate;
      return _this;
    }
    /**
     * @protected
     */


    _createClass(Tile, [{
      key: "changed",
      value: function changed() {
        this.dispatchEvent(EventType.CHANGE);
      }
      /**
       * Called by the tile cache when the tile is removed from the cache due to expiry
       */

    }, {
      key: "release",
      value: function release() {
        if (this.state === TileState.ERROR) {
          // to remove the `change` listener on this tile in `ol/TileQueue#handleTileChange`
          this.setState(TileState.EMPTY);
        }
      }
      /**
       * @return {string} Key.
       */

    }, {
      key: "getKey",
      value: function getKey() {
        return this.key + '/' + this.tileCoord;
      }
      /**
       * Get the interim tile most suitable for rendering using the chain of interim
       * tiles. This corresponds to the  most recent tile that has been loaded, if no
       * such tile exists, the original tile is returned.
       * @return {!Tile} Best tile for rendering.
       */

    }, {
      key: "getInterimTile",
      value: function getInterimTile() {
        if (!this.interimTile) {
          //empty chain
          return this;
        }

        var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)

        do {
          if (tile.getState() == TileState.LOADED) {
            // Show tile immediately instead of fading it in after loading, because
            // the interim tile is in place already
            this.transition_ = 0;
            return tile;
          }

          tile = tile.interimTile;
        } while (tile); // we can not find a better tile


        return this;
      }
      /**
       * Goes through the chain of interim tiles and discards sections of the chain
       * that are no longer relevant.
       */

    }, {
      key: "refreshInterimChain",
      value: function refreshInterimChain() {
        if (!this.interimTile) {
          return;
        }

        var tile = this.interimTile;
        /**
         * @type {Tile}
         */

        var prev = this;

        do {
          if (tile.getState() == TileState.LOADED) {
            //we have a loaded tile, we can discard the rest of the list
            //we would could abort any LOADING tile request
            //older than this tile (i.e. any LOADING tile following this entry in the chain)
            tile.interimTile = null;
            break;
          } else if (tile.getState() == TileState.LOADING) {
            //keep this LOADING tile any loaded tiles later in the chain are
            //older than this tile, so we're still interested in the request
            prev = tile;
          } else if (tile.getState() == TileState.IDLE) {
            //the head of the list is the most current tile, we don't need
            //to start any other requests for this chain
            prev.interimTile = tile.interimTile;
          } else {
            prev = tile;
          }

          tile = prev.interimTile;
        } while (tile);
      }
      /**
       * Get the tile coordinate for this tile.
       * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
       * @api
       */

    }, {
      key: "getTileCoord",
      value: function getTileCoord() {
        return this.tileCoord;
      }
      /**
       * @return {import("./TileState.js").default} State.
       */

    }, {
      key: "getState",
      value: function getState() {
        return this.state;
      }
      /**
       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
       * when the tile cannot be loaded. Otherwise the tile cannot be removed from
       * the tile queue and will block other requests.
       * @param {import("./TileState.js").default} state State.
       * @api
       */

    }, {
      key: "setState",
      value: function setState(state) {
        if (this.state !== TileState.ERROR && this.state > state) {
          throw new Error('Tile load sequence violation');
        }

        this.state = state;
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */

    }, {
      key: "load",
      value: function load() {
        _abstract();
      }
      /**
       * Get the alpha value for rendering.
       * @param {string} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */

    }, {
      key: "getAlpha",
      value: function getAlpha(id, time) {
        if (!this.transition_) {
          return 1;
        }

        var start = this.transitionStarts_[id];

        if (!start) {
          start = time;
          this.transitionStarts_[id] = start;
        } else if (start === -1) {
          return 1;
        }

        var delta = time - start + 1000 / 60; // avoid rendering at 0

        if (delta >= this.transition_) {
          return 1;
        }

        return easeIn(delta / this.transition_);
      }
      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {string} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */

    }, {
      key: "inTransition",
      value: function inTransition(id) {
        if (!this.transition_) {
          return false;
        }

        return this.transitionStarts_[id] !== -1;
      }
      /**
       * Mark a transition as complete.
       * @param {string} id An id for the renderer.
       */

    }, {
      key: "endTransition",
      value: function endTransition(id) {
        if (this.transition_) {
          this.transitionStarts_[id] = -1;
        }
      }
    }]);

    return Tile;
  }(Target);

  /**
   * @module ol/ImageState
   */

  /**
   * @enum {number}
   */
  var ImageState = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
  };

  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
   * @param {function():any} loadHandler Load callback function.
   * @param {function():any} errorHandler Error callback function.
   * @return {function():void} Callback to stop listening.
   */


  function listenImage(image, loadHandler, errorHandler) {
    var img =
    /** @type {HTMLImageElement} */
    image;
    var listening = true;
    var decoding = false;
    var loaded = false;
    var listenerKeys = [listenOnce(img, EventType.LOAD, function () {
      loaded = true;

      if (!decoding) {
        loadHandler();
      }
    })];

    if (img.src && IMAGE_DECODE) {
      decoding = true;
      img.decode().then(function () {
        if (listening) {
          loadHandler();
        }
      })["catch"](function (error) {
        if (listening) {
          if (loaded) {
            loadHandler();
          } else {
            errorHandler();
          }
        }
      });
    } else {
      listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
    }

    return function unlisten() {
      listening = false;
      listenerKeys.forEach(unlistenByKey);
    };
  }

  var ImageTile = /*#__PURE__*/function (_Tile) {
    _inherits(ImageTile, _Tile);

    var _super = _createSuper(ImageTile);

    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @param {import("./TileState.js").default} state State.
     * @param {string} src Image source URI.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
     * @param {import("./Tile.js").Options} [options] Tile options.
     */
    function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
      var _this;

      _classCallCheck(this, ImageTile);

      _this = _super.call(this, tileCoord, state, options);
      /**
       * @private
       * @type {?string}
       */

      _this.crossOrigin_ = crossOrigin;
      /**
       * Image URI
       *
       * @private
       * @type {string}
       */

      _this.src_ = src;
      _this.key = src;
      /**
       * @private
       * @type {HTMLImageElement|HTMLCanvasElement}
       */

      _this.image_ = new Image();

      if (crossOrigin !== null) {
        _this.image_.crossOrigin = crossOrigin;
      }
      /**
       * @private
       * @type {?function():void}
       */


      _this.unlisten_ = null;
      /**
       * @private
       * @type {import("./Tile.js").LoadFunction}
       */

      _this.tileLoadFunction_ = tileLoadFunction;
      return _this;
    }
    /**
     * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
     * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
     * @api
     */


    _createClass(ImageTile, [{
      key: "getImage",
      value: function getImage() {
        return this.image_;
      }
      /**
       * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
       * @param {HTMLCanvasElement|HTMLImageElement} element Element.
       */

    }, {
      key: "setImage",
      value: function setImage(element) {
        this.image_ = element;
        this.state = TileState.LOADED;
        this.unlistenImage_();
        this.changed();
      }
      /**
       * Tracks loading or read errors.
       *
       * @private
       */

    }, {
      key: "handleImageError_",
      value: function handleImageError_() {
        this.state = TileState.ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
      }
      /**
       * Tracks successful image load.
       *
       * @private
       */

    }, {
      key: "handleImageLoad_",
      value: function handleImageLoad_() {
        var image =
        /** @type {HTMLImageElement} */
        this.image_;

        if (image.naturalWidth && image.naturalHeight) {
          this.state = TileState.LOADED;
        } else {
          this.state = TileState.EMPTY;
        }

        this.unlistenImage_();
        this.changed();
      }
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       *
       * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
       * that checks for error status codes and reloads only when the status code is
       * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
       * made already:
       *
       * ```js
       * const retryCodes = [408, 429, 500, 502, 503, 504];
       * const retries = {};
       * source.setTileLoadFunction((tile, src) => {
       *   const image = tile.getImage();
       *   fetch(src)
       *     .then((response) => {
       *       if (retryCodes.includes(response.status)) {
       *         retries[src] = (retries[src] || 0) + 1;
       *         if (retries[src] <= 3) {
       *           setTimeout(() => tile.load(), retries[src] * 1000);
       *         }
       *         return Promise.reject();
       *       }
       *       return response.blob();
       *     })
       *     .then((blob) => {
       *       const imageUrl = URL.createObjectURL(blob);
       *       image.src = imageUrl;
       *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
       *     })
       *     .catch(() => tile.setState(3)); // error
       * });
       * ```
       *
       * @api
       */

    }, {
      key: "load",
      value: function load() {
        if (this.state == TileState.ERROR) {
          this.state = TileState.IDLE;
          this.image_ = new Image();

          if (this.crossOrigin_ !== null) {
            this.image_.crossOrigin = this.crossOrigin_;
          }
        }

        if (this.state == TileState.IDLE) {
          this.state = TileState.LOADING;
          this.changed();
          this.tileLoadFunction_(this, this.src_);
          this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
        }
      }
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */

    }, {
      key: "unlistenImage_",
      value: function unlistenImage_() {
        if (this.unlisten_) {
          this.unlisten_();
          this.unlisten_ = null;
        }
      }
    }]);

    return ImageTile;
  }(Tile);
  /**
   * Get a 1-pixel blank image.
   * @return {HTMLCanvasElement} Blank image.
   */


  function getBlankImage() {
    var ctx = createCanvasContext2D(1, 1);
    ctx.fillStyle = 'rgba(0,0,0,0)';
    ctx.fillRect(0, 0, 1, 1);
    return ctx.canvas;
  }

  /**
   * @module ol/reproj/common
   */

  /**
   * Default maximum allowed threshold  (in pixels) for reprojection
   * triangulation.
   * @type {number}
   */
  var ERROR_THRESHOLD = 0.5;

  /**
   * Single triangle; consists of 3 source points and 3 target points.
   * @typedef {Object} Triangle
   * @property {Array<import("../coordinate.js").Coordinate>} source Source.
   * @property {Array<import("../coordinate.js").Coordinate>} target Target.
   */

  /**
   * Maximum number of subdivision steps during raster reprojection triangulation.
   * Prevents high memory usage and large number of proj4 calls (for certain
   * transformations and areas). At most `2*(2^this)` triangles are created for
   * each triangulated extent (tile/image).
   * @type {number}
   */

  var MAX_SUBDIVISION = 10;
  /**
   * Maximum allowed size of triangle relative to world width. When transforming
   * corners of world extent between certain projections, the resulting
   * triangulation seems to have zero error and no subdivision is performed. If
   * the triangle width is more than this (relative to world width; 0-1),
   * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
   * @type {number}
   */

  var MAX_TRIANGLE_WIDTH = 0.25;
  /**
   * @classdesc
   * Class containing triangulation of the given target extent.
   * Used for determining source data and the reprojection itself.
   */

  var Triangulation = /*#__PURE__*/function () {
    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
     * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
     * @param {number} errorThreshold Acceptable error (in source units).
     * @param {?number} destinationResolution The (optional) resolution of the destination.
     */
    function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
      _classCallCheck(this, Triangulation);

      /**
       * @type {import("../proj/Projection.js").default}
       * @private
       */
      this.sourceProj_ = sourceProj;
      /**
       * @type {import("../proj/Projection.js").default}
       * @private
       */

      this.targetProj_ = targetProj;
      /** @type {!Object<string, import("../coordinate.js").Coordinate>} */

      var transformInvCache = {};
      var transformInv = getTransform(this.targetProj_, this.sourceProj_);
      /**
       * @param {import("../coordinate.js").Coordinate} c A coordinate.
       * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
       * @private
       */

      this.transformInv_ = function (c) {
        var key = c[0] + '/' + c[1];

        if (!transformInvCache[key]) {
          transformInvCache[key] = transformInv(c);
        }

        return transformInvCache[key];
      };
      /**
       * @type {import("../extent.js").Extent}
       * @private
       */


      this.maxSourceExtent_ = maxSourceExtent;
      /**
       * @type {number}
       * @private
       */

      this.errorThresholdSquared_ = errorThreshold * errorThreshold;
      /**
       * @type {Array<Triangle>}
       * @private
       */

      this.triangles_ = [];
      /**
       * Indicates that the triangulation crosses edge of the source projection.
       * @type {boolean}
       * @private
       */

      this.wrapsXInSource_ = false;
      /**
       * @type {boolean}
       * @private
       */

      this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
      /**
       * @type {?number}
       * @private
       */

      this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
      /**
       * @type {?number}
       * @private
       */

      this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
      var destinationTopLeft = getTopLeft(targetExtent);
      var destinationTopRight = getTopRight(targetExtent);
      var destinationBottomRight = getBottomRight(targetExtent);
      var destinationBottomLeft = getBottomLeft(targetExtent);
      var sourceTopLeft = this.transformInv_(destinationTopLeft);
      var sourceTopRight = this.transformInv_(destinationTopRight);
      var sourceBottomRight = this.transformInv_(destinationBottomRight);
      var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
      /*
       * The maxSubdivision controls how many splittings of the target area can
       * be done. The idea here is to do a linear mapping of the target areas
       * but the actual overal reprojection (can be) extremely non-linear. The
       * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
       * tile size. However this function is also called to remap canvas rendered
       * layers which can be much larger. This calculation increases the maxSubdivision
       * value by the right factor so that each 256x256 pixel area has
       * MAX_SUBDIVISION divisions.
       */

      var maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(0, Math.ceil(Math.log2(getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)))) : 0);
      this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);

      if (this.wrapsXInSource_) {
        var leftBound = Infinity;
        this.triangles_.forEach(function (triangle, i, arr) {
          leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
        }); // Shift triangles to be as close to `leftBound` as possible
        // (if the distance is more than `worldWidth / 2` it can be closer.

        this.triangles_.forEach(function (triangle) {
          if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
            var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

            if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
              newTriangle[0][0] -= this.sourceWorldWidth_;
            }

            if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
              newTriangle[1][0] -= this.sourceWorldWidth_;
            }

            if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
              newTriangle[2][0] -= this.sourceWorldWidth_;
            } // Rarely (if the extent contains both the dateline and prime meridian)
            // the shift can in turn break some triangles.
            // Detect this here and don't shift in such cases.


            var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
            var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

            if (maxX - minX < this.sourceWorldWidth_ / 2) {
              triangle.source = newTriangle;
            }
          }
        }.bind(this));
      }

      transformInvCache = {};
    }
    /**
     * Adds triangle to the triangulation.
     * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
     * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
     * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
     * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
     * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
     * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
     * @private
     */


    _createClass(Triangulation, [{
      key: "addTriangle_",
      value: function addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
        this.triangles_.push({
          source: [aSrc, bSrc, cSrc],
          target: [a, b, c]
        });
      }
      /**
       * Adds quad (points in clock-wise order) to the triangulation
       * (and reprojects the vertices) if valid.
       * Performs quad subdivision if needed to increase precision.
       *
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
       * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
       * @private
       */

    }, {
      key: "addQuad_",
      value: function addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
        var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
        var sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
        var sourceWorldWidth =
        /** @type {number} */
        this.sourceWorldWidth_; // when the quad is wrapped in the source projection
        // it covers most of the projection extent, but not fully

        var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
        var needsSubdivision = false;

        if (maxSubdivision > 0) {
          if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
            var targetQuadExtent = boundingExtent([a, b, c, d]);
            var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
            needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }

          if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
            needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
          }
        }

        if (!needsSubdivision && this.maxSourceExtent_) {
          if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
            if (!intersects$1(sourceQuadExtent, this.maxSourceExtent_)) {
              // whole quad outside source projection extent -> ignore
              return;
            }
          }
        }

        var isNotFinite = 0;

        if (!needsSubdivision) {
          if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
            if (maxSubdivision > 0) {
              needsSubdivision = true;
            } else {
              // It might be the case that only 1 of the points is infinite. In this case
              // we can draw a single triangle with the other three points
              isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);

              if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
                return;
              }
            }
          }
        }

        if (maxSubdivision > 0) {
          if (!needsSubdivision) {
            var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
            var centerSrc = this.transformInv_(center);
            var dx;

            if (wrapsX) {
              var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
              dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
            } else {
              dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
            }

            var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
            var centerSrcErrorSquared = dx * dx + dy * dy;
            needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
          }

          if (needsSubdivision) {
            if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
              // split horizontally (top & bottom)
              var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
              var bcSrc = this.transformInv_(bc);
              var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
              var daSrc = this.transformInv_(da);
              this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
              this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
            } else {
              // split vertically (left & right)
              var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
              var abSrc = this.transformInv_(ab);
              var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
              var cdSrc = this.transformInv_(cd);
              this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
              this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
            }

            return;
          }
        }

        if (wrapsX) {
          if (!this.canWrapXInSource_) {
            return;
          }

          this.wrapsXInSource_ = true;
        } // Exactly zero or one of *Src is not finite
        // The triangles must have the diagonal line as the first side
        // This is to allow easy code in reproj.s to make it straight for broken
        // browsers that can't handle diagonal clipping


        if ((isNotFinite & 0xb) == 0) {
          this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
        }

        if ((isNotFinite & 0xe) == 0) {
          this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
        }

        if (isNotFinite) {
          // Try the other two triangles
          if ((isNotFinite & 0xd) == 0) {
            this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
          }

          if ((isNotFinite & 0x7) == 0) {
            this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
          }
        }
      }
      /**
       * Calculates extent of the `source` coordinates from all the triangles.
       *
       * @return {import("../extent.js").Extent} Calculated extent.
       */

    }, {
      key: "calculateSourceExtent",
      value: function calculateSourceExtent() {
        var extent = createEmpty();
        this.triangles_.forEach(function (triangle, i, arr) {
          var src = triangle.source;
          extendCoordinate(extent, src[0]);
          extendCoordinate(extent, src[1]);
          extendCoordinate(extent, src[2]);
        });
        return extent;
      }
      /**
       * @return {Array<Triangle>} Array of the calculated triangles.
       */

    }, {
      key: "getTriangles",
      value: function getTriangles() {
        return this.triangles_;
      }
    }]);

    return Triangulation;
  }();

  /**
   * @module ol/reproj
   */
  var brokenDiagonalRendering_;
  /**
   * @type {Array<HTMLCanvasElement>}
   */

  var canvasPool = [];
  /**
   * This draws a small triangle into a canvas by setting the triangle as the clip region
   * and then drawing a (too large) rectangle
   *
   * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
   * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
   * @param {number} v1 The y-coordinate of the second point.
   * @param {number} u2 The x-coordinate of the third point.
   * @param {number} v2 The y-coordinate of the third point.
   */

  function drawTestTriangle(ctx, u1, v1, u2, v2) {
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(u1, v1);
    ctx.lineTo(u2, v2);
    ctx.closePath();
    ctx.save();
    ctx.clip();
    ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
    ctx.restore();
  }
  /**
   * Given the data from getImageData, see if the right values appear at the provided offset.
   * Returns true if either the color or transparency is off
   *
   * @param {Uint8ClampedArray} data The data returned from getImageData
   * @param {number} offset The pixel offset from the start of data.
   * @return {boolean} true if the diagonal rendering is broken
   */


  function verifyBrokenDiagonalRendering(data, offset) {
    // the values ought to be close to the rgba(210, 0, 0, 0.75)
    return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
  }
  /**
   * Determines if the current browser configuration can render triangular clip regions correctly.
   * This value is cached so the function is only expensive the first time called.
   * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
   * Chrome works, and everything seems to work on OSX and Android. This function caches the
   * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
   * running, but lets hope not.
   *
   * @return {boolean} true if the Diagonal Rendering is broken.
   */


  function isBrokenDiagonalRendering() {
    if (brokenDiagonalRendering_ === undefined) {
      var ctx = document.createElement('canvas').getContext('2d');
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
      drawTestTriangle(ctx, 4, 5, 4, 0);
      drawTestTriangle(ctx, 4, 5, 0, 5);
      var data = ctx.getImageData(0, 0, 3, 3).data;
      brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    }

    return brokenDiagonalRendering_;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */


  function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
    var sourceCenter = transform(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data

    var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
    var targetMetersPerUnit = targetProj.getMetersPerUnit();

    if (targetMetersPerUnit !== undefined) {
      sourceResolution *= targetMetersPerUnit;
    }

    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

    if (sourceMetersPerUnit !== undefined) {
      sourceResolution /= sourceMetersPerUnit;
    } // Based on the projection properties, the point resolution at the specified
    // coordinates may be slightly different. We need to reverse-compensate this
    // in order to achieve optimal results.


    var sourceExtent = sourceProj.getExtent();

    if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
      var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

      if (isFinite(compensationFactor) && compensationFactor > 0) {
        sourceResolution /= compensationFactor;
      }
    }

    return sourceResolution;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./extent.js").Extent} targetExtent Target extent
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */

  function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
    var targetCenter = getCenter(targetExtent);
    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      forEachCorner(targetExtent, function (corner) {
        sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
        return isFinite(sourceResolution) && sourceResolution > 0;
      });
    }

    return sourceResolution;
  }
  /**
   * @typedef {Object} ImageExtent
   * @property {import("./extent.js").Extent} extent Extent.
   * @property {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */

  /**
   * Renders the source data into new canvas based on the triangulation.
   *
   * @param {number} width Width of the canvas.
   * @param {number} height Height of the canvas.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} sourceResolution Source resolution.
   * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
   * @param {number} targetResolution Target resolution.
   * @param {import("./extent.js").Extent} targetExtent Target extent.
   * @param {import("./reproj/Triangulation.js").default} triangulation Calculated triangulation.
   * @param {Array<ImageExtent>} sources Array of sources.
   * @param {number} gutter Gutter of the sources.
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {boolean} [interpolate] Use linear interpolation when resampling.
   * @return {HTMLCanvasElement} Canvas with reprojected data.
   */

  function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate) {
    var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height), canvasPool);

    if (!interpolate) {
      context.imageSmoothingEnabled = false;
    }

    if (sources.length === 0) {
      return context.canvas;
    }

    context.scale(pixelRatio, pixelRatio);

    function pixelRound(value) {
      return Math.round(value * pixelRatio) / pixelRatio;
    }

    context.globalCompositeOperation = 'lighter';
    var sourceDataExtent = createEmpty();
    sources.forEach(function (src, i, arr) {
      extend(sourceDataExtent, src.extent);
    });
    var canvasWidthInUnits = getWidth(sourceDataExtent);
    var canvasHeightInUnits = getHeight(sourceDataExtent);
    var stitchContext = createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }

    var stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function (src, i, arr) {
      var xPos = src.extent[0] - sourceDataExtent[0];
      var yPos = -(src.extent[3] - sourceDataExtent[3]);
      var srcWidth = getWidth(src.extent);
      var srcHeight = getHeight(src.extent); // This test should never fail -- but it does. Need to find a fix the upstream condition

      if (src.image.width > 0 && src.image.height > 0) {
        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
      }
    });
    var targetTopLeft = getTopLeft(targetExtent);
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      /* Calculate affine transform (src -> dst)
       * Resulting matrix can be used to transform coordinate
       * from `sourceProjection` to destination pixels.
       *
       * To optimize number of context calls and increase numerical stability,
       * we also do the following operations:
       * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
       * here before solving the linear system so [ui, vi] are pixel coordinates.
       *
       * Src points: xi, yi
       * Dst points: ui, vi
       * Affine coefficients: aij
       *
       * | x0 y0 1  0  0 0 |   |a00|   |u0|
       * | x1 y1 1  0  0 0 |   |a01|   |u1|
       * | x2 y2 1  0  0 0 | x |a02| = |u2|
       * |  0  0 0 x0 y0 1 |   |a10|   |v0|
       * |  0  0 0 x1 y1 1 |   |a11|   |v1|
       * |  0  0 0 x2 y2 1 |   |a12|   |v2|
       */
      var source = triangle.source;
      var target = triangle.target;
      var x0 = source[0][0],
          y0 = source[0][1];
      var x1 = source[1][0],
          y1 = source[1][1];
      var x2 = source[2][0],
          y2 = source[2][1]; // Make sure that everything is on pixel boundaries

      var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
      var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
      var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
      var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
      var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
      var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution); // Shift all the source points to improve numerical stability
      // of all the subsequent calculations. The [x0, y0] is used here.
      // This is also used to simplify the linear system.

      var sourceNumericalShiftX = x0;
      var sourceNumericalShiftY = y0;
      x0 = 0;
      y0 = 0;
      x1 -= sourceNumericalShiftX;
      y1 -= sourceNumericalShiftY;
      x2 -= sourceNumericalShiftX;
      y2 -= sourceNumericalShiftY;
      var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
      var affineCoefs = solveLinearSystem(augmentedMatrix);

      if (!affineCoefs) {
        return;
      }

      context.save();
      context.beginPath();

      if (isBrokenDiagonalRendering() || !interpolate) {
        // Make sure that all lines are horizontal or vertical
        context.moveTo(u1, v1); // This is the diagonal line. Do it in 4 steps

        var steps = 4;
        var ud = u0 - u1;
        var vd = v0 - v1;

        for (var step = 0; step < steps; step++) {
          // Go horizontally
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1))); // Go vertically

          if (step != steps - 1) {
            context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
          }
        } // We are almost at u0r, v0r


        context.lineTo(u2, v2);
      } else {
        context.moveTo(u1, v1);
        context.lineTo(u0, v0);
        context.lineTo(u2, v2);
      }

      context.clip();
      context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
      context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
      context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
      context.drawImage(stitchContext.canvas, 0, 0);
      context.restore();
    });

    if (renderEdges) {
      context.save();
      context.globalCompositeOperation = 'source-over';
      context.strokeStyle = 'black';
      context.lineWidth = 1;
      triangulation.getTriangles().forEach(function (triangle, i, arr) {
        var target = triangle.target;
        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
        var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
        var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
        var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
        context.beginPath();
        context.moveTo(u1, v1);
        context.lineTo(u0, v0);
        context.lineTo(u2, v2);
        context.closePath();
        context.stroke();
      });
      context.restore();
    }

    return context.canvas;
  }

  /**
   * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
   */

  /**
   * @classdesc
   * Class encapsulating single reprojected tile.
   * See {@link module:ol/source/TileImage~TileImage}.
   *
   */

  var ReprojTile = /*#__PURE__*/function (_Tile) {
    _inherits(ReprojTile, _Tile);

    var _super = _createSuper(ReprojTile);

    /**
     * @param {import("../proj/Projection.js").default} sourceProj Source projection.
     * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
     * @param {import("../proj/Projection.js").default} targetProj Target projection.
     * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
     * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
     * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} gutter Gutter of the source tiles.
     * @param {FunctionType} getTileFunction
     *     Function returning source tiles (z, x, y, pixelRatio).
     * @param {number} [errorThreshold] Acceptable reprojection error (in px).
     * @param {boolean} [renderEdges] Render reprojection edges.
     * @param {boolean} [interpolate] Use linear interpolation when resampling.
     */
    function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, interpolate) {
      var _this;

      _classCallCheck(this, ReprojTile);

      _this = _super.call(this, tileCoord, TileState.IDLE, {
        interpolate: !!interpolate
      });
      /**
       * @private
       * @type {boolean}
       */

      _this.renderEdges_ = renderEdges !== undefined ? renderEdges : false;
      /**
       * @private
       * @type {number}
       */

      _this.pixelRatio_ = pixelRatio;
      /**
       * @private
       * @type {number}
       */

      _this.gutter_ = gutter;
      /**
       * @private
       * @type {HTMLCanvasElement}
       */

      _this.canvas_ = null;
      /**
       * @private
       * @type {import("../tilegrid/TileGrid.js").default}
       */

      _this.sourceTileGrid_ = sourceTileGrid;
      /**
       * @private
       * @type {import("../tilegrid/TileGrid.js").default}
       */

      _this.targetTileGrid_ = targetTileGrid;
      /**
       * @private
       * @type {import("../tilecoord.js").TileCoord}
       */

      _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
      /**
       * @private
       * @type {!Array<import("../Tile.js").default>}
       */

      _this.sourceTiles_ = [];
      /**
       * @private
       * @type {?Array<import("../events.js").EventsKey>}
       */

      _this.sourcesListenerKeys_ = null;
      /**
       * @private
       * @type {number}
       */

      _this.sourceZ_ = 0;
      var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);

      var maxTargetExtent = _this.targetTileGrid_.getExtent();

      var maxSourceExtent = _this.sourceTileGrid_.getExtent();

      var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;

      if (getArea(limitedTargetExtent) === 0) {
        // Tile is completely outside range -> EMPTY
        // TODO: is it actually correct that the source even creates the tile ?
        _this.state = TileState.EMPTY;
        return _possibleConstructorReturn(_this);
      }

      var sourceProjExtent = sourceProj.getExtent();

      if (sourceProjExtent) {
        if (!maxSourceExtent) {
          maxSourceExtent = sourceProjExtent;
        } else {
          maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
        }
      }

      var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
      var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);

      if (!isFinite(sourceResolution) || sourceResolution <= 0) {
        // invalid sourceResolution -> EMPTY
        // probably edges of the projections when no extent is defined
        _this.state = TileState.EMPTY;
        return _possibleConstructorReturn(_this);
      }

      var errorThresholdInPixels = errorThreshold !== undefined ? errorThreshold : ERROR_THRESHOLD;
      /**
       * @private
       * @type {!import("./Triangulation.js").default}
       */

      _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);

      if (_this.triangulation_.getTriangles().length === 0) {
        // no valid triangles -> EMPTY
        _this.state = TileState.EMPTY;
        return _possibleConstructorReturn(_this);
      }

      _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);

      var sourceExtent = _this.triangulation_.calculateSourceExtent();

      if (maxSourceExtent) {
        if (sourceProj.canWrapX()) {
          sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
          sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
        } else {
          sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
        }
      }

      if (!getArea(sourceExtent)) {
        _this.state = TileState.EMPTY;
      } else {
        var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);

        for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);

            if (tile) {
              _this.sourceTiles_.push(tile);
            }
          }
        }

        if (_this.sourceTiles_.length === 0) {
          _this.state = TileState.EMPTY;
        }
      }

      return _this;
    }
    /**
     * Get the HTML Canvas element for this tile.
     * @return {HTMLCanvasElement} Canvas.
     */


    _createClass(ReprojTile, [{
      key: "getImage",
      value: function getImage() {
        return this.canvas_;
      }
      /**
       * @private
       */

    }, {
      key: "reproject_",
      value: function reproject_() {
        var sources = [];
        this.sourceTiles_.forEach(function (tile, i, arr) {
          if (tile && tile.getState() == TileState.LOADED) {
            sources.push({
              extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
              image: tile.getImage()
            });
          }
        }.bind(this));
        this.sourceTiles_.length = 0;

        if (sources.length === 0) {
          this.state = TileState.ERROR;
        } else {
          var z = this.wrappedTileCoord_[0];
          var size = this.targetTileGrid_.getTileSize(z);
          var width = typeof size === 'number' ? size : size[0];
          var height = typeof size === 'number' ? size : size[1];
          var targetResolution = this.targetTileGrid_.getResolution(z);
          var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
          var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
          this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.interpolate);
          this.state = TileState.LOADED;
        }

        this.changed();
      }
      /**
       * Load not yet loaded URI.
       */

    }, {
      key: "load",
      value: function load() {
        if (this.state == TileState.IDLE) {
          this.state = TileState.LOADING;
          this.changed();
          var leftToLoad = 0;
          this.sourcesListenerKeys_ = [];
          this.sourceTiles_.forEach(function (tile, i, arr) {
            var state = tile.getState();

            if (state == TileState.IDLE || state == TileState.LOADING) {
              leftToLoad++;
              var sourceListenKey = listen(tile, EventType.CHANGE, function (e) {
                var state = tile.getState();

                if (state == TileState.LOADED || state == TileState.ERROR || state == TileState.EMPTY) {
                  unlistenByKey(sourceListenKey);
                  leftToLoad--;

                  if (leftToLoad === 0) {
                    this.unlistenSources_();
                    this.reproject_();
                  }
                }
              }, this);
              this.sourcesListenerKeys_.push(sourceListenKey);
            }
          }.bind(this));

          if (leftToLoad === 0) {
            setTimeout(this.reproject_.bind(this), 0);
          } else {
            this.sourceTiles_.forEach(function (tile, i, arr) {
              var state = tile.getState();

              if (state == TileState.IDLE) {
                tile.load();
              }
            });
          }
        }
      }
      /**
       * @private
       */

    }, {
      key: "unlistenSources_",
      value: function unlistenSources_() {
        this.sourcesListenerKeys_.forEach(unlistenByKey);
        this.sourcesListenerKeys_ = null;
      }
      /**
       * Remove from the cache due to expiry
       */

    }, {
      key: "release",
      value: function release() {
        if (this.canvas_) {
          releaseCanvas$1(this.canvas_.getContext('2d'));
          canvasPool.push(this.canvas_);
          this.canvas_ = null;
        }

        _get(_getPrototypeOf(ReprojTile.prototype), "release", this).call(this);
      }
    }]);

    return ReprojTile;
  }(Tile);

  /**
   * @module ol/tilecoord
   */

  /**
   * An array of three numbers representing the location of a tile in a tile
   * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
   * @typedef {Array<number>} TileCoord
   * @api
   */

  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {TileCoord} [tileCoord] Tile coordinate.
   * @return {TileCoord} Tile coordinate.
   */
  function createOrUpdate$1(z, x, y, tileCoord) {
    if (tileCoord !== undefined) {
      tileCoord[0] = z;
      tileCoord[1] = x;
      tileCoord[2] = y;
      return tileCoord;
    } else {
      return [z, x, y];
    }
  }
  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {string} Key.
   */

  function getKeyZXY(z, x, y) {
    return z + '/' + x + '/' + y;
  }
  /**
   * Get the key for a tile coord.
   * @param {TileCoord} tileCoord The tile coord.
   * @return {string} Key.
   */

  function getKey(tileCoord) {
    return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
  }
  /**
   * Get a tile coord given a key.
   * @param {string} key The tile coord key.
   * @return {TileCoord} The tile coord.
   */

  function fromKey(key) {
    return key.split('/').map(Number);
  }
  /**
   * @param {TileCoord} tileCoord Tile coord.
   * @return {number} Hash.
   */

  function hash(tileCoord) {
    return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
  }
  /**
   * @param {TileCoord} tileCoord Tile coordinate.
   * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {boolean} Tile coordinate is within extent and zoom level range.
   */

  function withinExtentAndZ(tileCoord, tileGrid) {
    var z = tileCoord[0];
    var x = tileCoord[1];
    var y = tileCoord[2];

    if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
      return false;
    }

    var tileRange = tileGrid.getFullTileRange(z);

    if (!tileRange) {
      return true;
    } else {
      return tileRange.containsXY(x, y);
    }
  }

  var TileCache = /*#__PURE__*/function (_LRUCache) {
    _inherits(TileCache, _LRUCache);

    var _super = _createSuper(TileCache);

    function TileCache() {
      _classCallCheck(this, TileCache);

      return _super.apply(this, arguments);
    }

    _createClass(TileCache, [{
      key: "clear",
      value: function clear() {
        while (this.getCount() > 0) {
          this.pop().release();
        }

        _get(_getPrototypeOf(TileCache.prototype), "clear", this).call(this);
      }
      /**
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */

    }, {
      key: "expireCache",
      value: function expireCache(usedTiles) {
        while (this.canExpireCache()) {
          var tile = this.peekLast();

          if (tile.getKey() in usedTiles) {
            break;
          } else {
            this.pop().release();
          }
        }
      }
      /**
       * Prune all tiles from the cache that don't have the same z as the newest tile.
       */

    }, {
      key: "pruneExceptNewestZ",
      value: function pruneExceptNewestZ() {
        if (this.getCount() === 0) {
          return;
        }

        var key = this.peekFirstKey();
        var tileCoord = fromKey(key);
        var z = tileCoord[0];
        this.forEach(function (tile) {
          if (tile.tileCoord[0] !== z) {
            this.remove(getKey(tile.tileCoord));
            tile.release();
          }
        }.bind(this));
      }
    }]);

    return TileCache;
  }(LRUCache);

  /**
   * @module ol/source/TileEventType
   */

  /**
   * @enum {string}
   */
  var TileEventType = {
    /**
     * Triggered when a tile starts loading.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
     * @api
     */
    TILELOADSTART: 'tileloadstart',

    /**
     * Triggered when a tile finishes loading, either when its data is loaded,
     * or when loading was aborted because the tile is no longer needed.
     * @event module:ol/source/Tile.TileSourceEvent#tileloadend
     * @api
     */
    TILELOADEND: 'tileloadend',

    /**
     * Triggered if tile loading results in an error. Note that this is not the
     * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
     * for details.
     * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
     * @api
     */
    TILELOADERROR: 'tileloaderror'
  };
  /**
   * @typedef {'tileloadstart'|'tileloadend'|'tileloaderror'} TileSourceEventTypes
   */

  /**
   * @typedef {'undefined' | 'loading' | 'ready' | 'error'} State
   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
   */

  /**
   * A function that takes a {@link module:ol/Map~FrameState} and returns a string or
   * an array of strings representing source attributions.
   *
   * @typedef {function(import("../Map.js").FrameState): (string|Array<string>)} Attribution
   */

  /**
   * A type that can be used to provide attribution information for data sources.
   *
   * It represents either
   * * a simple string (e.g. `' Acme Inc.'`)
   * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)
   * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
   *
   * @typedef {string|Array<string>|Attribution} AttributionLike
   */

  /**
   * @typedef {Object} Options
   * @property {AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {import("./Source.js").State} [state='ready'] State.
   * @property {boolean} [wrapX=false] WrapX.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for {@link module:ol/layer/Layer~Layer} sources.
   *
   * A generic `change` event is triggered when the state of the source changes.
   * @abstract
   * @api
   */

  var Source = /*#__PURE__*/function (_BaseObject) {
    _inherits(Source, _BaseObject);

    var _super = _createSuper(Source);

    /**
     * @param {Options} options Source options.
     */
    function Source(options) {
      var _this;

      _classCallCheck(this, Source);

      _this = _super.call(this);
      /**
       * @protected
       * @type {import("../proj/Projection.js").default|null}
       */

      _this.projection = get$1(options.projection);
      /**
       * @private
       * @type {?Attribution}
       */

      _this.attributions_ = adaptAttributions(options.attributions);
      /**
       * @private
       * @type {boolean}
       */

      _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
      /**
       * This source is currently loading data. Sources that defer loading to the
       * map's tile queue never set this to `true`.
       * @type {boolean}
       */

      _this.loading = false;
      /**
       * @private
       * @type {import("./Source.js").State}
       */

      _this.state_ = options.state !== undefined ? options.state : 'ready';
      /**
       * @private
       * @type {boolean}
       */

      _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
      /**
       * @private
       * @type {boolean}
       */

      _this.interpolate_ = !!options.interpolate;
      /**
       * @protected
       * @type {function(import("../View.js").ViewOptions):void}
       */

      _this.viewResolver = null;
      /**
       * @protected
       * @type {function(Error):void}
       */

      _this.viewRejector = null;

      var self = _assertThisInitialized(_this);
      /**
       * @private
       * @type {Promise<import("../View.js").ViewOptions>}
       */


      _this.viewPromise_ = new Promise(function (resolve, reject) {
        self.viewResolver = resolve;
        self.viewRejector = reject;
      });
      return _this;
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */


    _createClass(Source, [{
      key: "getAttributions",
      value: function getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */

    }, {
      key: "getAttributionsCollapsible",
      value: function getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */

    }, {
      key: "getProjection",
      value: function getProjection() {
        return this.projection;
      }
      /**
       * @abstract
       * @return {Array<number>|null} Resolutions.
       */

    }, {
      key: "getResolutions",
      value: function getResolutions() {
        return _abstract();
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */

    }, {
      key: "getView",
      value: function getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */

    }, {
      key: "getState",
      value: function getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */

    }, {
      key: "getWrapX",
      value: function getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */

    }, {
      key: "getInterpolate",
      value: function getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */

    }, {
      key: "refresh",
      value: function refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */

    }, {
      key: "setAttributions",
      value: function setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */

    }, {
      key: "setState",
      value: function setState(state) {
        this.state_ = state;
        this.changed();
      }
    }]);

    return Source;
  }(BaseObject);
  /**
   * Turns the attributions option into an attributions function.
   * @param {AttributionLike|undefined} attributionLike The attribution option.
   * @return {Attribution|null} An attribution function (or null).
   */


  function adaptAttributions(attributionLike) {
    if (!attributionLike) {
      return null;
    }

    if (Array.isArray(attributionLike)) {
      return function (frameState) {
        return attributionLike;
      };
    }

    if (typeof attributionLike === 'function') {
      return attributionLike;
    }

    return function (frameState) {
      return [attributionLike];
    };
  }

  /**
   * @module ol/TileRange
   */

  /**
   * A representation of a contiguous block of tiles.  A tile range is specified
   * by its min/max tile coordinates and is inclusive of coordinates.
   */
  var TileRange = /*#__PURE__*/function () {
    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     */
    function TileRange(minX, maxX, minY, maxY) {
      _classCallCheck(this, TileRange);

      /**
       * @type {number}
       */
      this.minX = minX;
      /**
       * @type {number}
       */

      this.maxX = maxX;
      /**
       * @type {number}
       */

      this.minY = minY;
      /**
       * @type {number}
       */

      this.maxY = maxY;
    }
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */


    _createClass(TileRange, [{
      key: "contains",
      value: function contains(tileCoord) {
        return this.containsXY(tileCoord[1], tileCoord[2]);
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Contains.
       */

    }, {
      key: "containsTileRange",
      value: function containsTileRange(tileRange) {
        return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
      }
      /**
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @return {boolean} Contains coordinate.
       */

    }, {
      key: "containsXY",
      value: function containsXY(x, y) {
        return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Equals.
       */

    }, {
      key: "equals",
      value: function equals(tileRange) {
        return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       */

    }, {
      key: "extend",
      value: function extend(tileRange) {
        if (tileRange.minX < this.minX) {
          this.minX = tileRange.minX;
        }

        if (tileRange.maxX > this.maxX) {
          this.maxX = tileRange.maxX;
        }

        if (tileRange.minY < this.minY) {
          this.minY = tileRange.minY;
        }

        if (tileRange.maxY > this.maxY) {
          this.maxY = tileRange.maxY;
        }
      }
      /**
       * @return {number} Height.
       */

    }, {
      key: "getHeight",
      value: function getHeight() {
        return this.maxY - this.minY + 1;
      }
      /**
       * @return {import("./size.js").Size} Size.
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return [this.getWidth(), this.getHeight()];
      }
      /**
       * @return {number} Width.
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.maxX - this.minX + 1;
      }
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Intersects.
       */

    }, {
      key: "intersects",
      value: function intersects(tileRange) {
        return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
      }
    }]);

    return TileRange;
  }();
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   * @param {TileRange} [tileRange] TileRange.
   * @return {TileRange} Tile range.
   */


  function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
    if (tileRange !== undefined) {
      tileRange.minX = minX;
      tileRange.maxX = maxX;
      tileRange.minY = minY;
      tileRange.maxY = maxY;
      return tileRange;
    } else {
      return new TileRange(minX, maxX, minY, maxY);
    }
  }

  /**
   * @private
   * @type {import("../tilecoord.js").TileCoord}
   */

  var tmpTileCoord = [0, 0, 0];
  /**
   * Number of decimal digits to consider in integer values when rounding.
   * @type {number}
   */

  var DECIMALS = 5;
  /**
   * @typedef {Object} Options
   * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
   * extent will be requested by {@link module:ol/source/Tile~TileSource} sources. When no `origin` or
   * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
   * @property {number} [minZoom=0] Minimum zoom.
   * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
   * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
   * specified, `extent` or `origins` must be provided.
   * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
   * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
   * `origin` must be provided.
   * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
   * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
   * array will have a length of `maxZoom + 1`.
   * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
   * of the grid for each zoom level. If specified the values
   * define each zoom level's extent together with the `origin` or `origins`.
   * A grid `extent` can be configured in addition, and will further limit the extent
   * for which tile requests are made by sources. If the bottom-left corner of
   * an extent is used as `origin` or `origins`, then the `y` value must be
   * negative because OpenLayers tile coordinates use the top left as the origin.
   * @property {number|import("../size.js").Size} [tileSize] Tile size.
   * Default is `[256, 256]`.
   * @property {Array<number|import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * tile size.
   */

  /**
   * @classdesc
   * Base class for setting the grid pattern for sources accessing tiled-image
   * servers.
   * @api
   */

  var TileGrid = /*#__PURE__*/function () {
    /**
     * @param {Options} options Tile grid options.
     */
    function TileGrid(options) {
      _classCallCheck(this, TileGrid);

      /**
       * @protected
       * @type {number}
       */
      this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
      /**
       * @private
       * @type {!Array<number>}
       */

      this.resolutions_ = options.resolutions;
      assert(isSorted(this.resolutions_, function (a, b) {
        return b - a;
      }, true), 17); // `resolutions` must be sorted in descending order
      // check if we've got a consistent zoom factor and origin

      var zoomFactor;

      if (!options.origins) {
        for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
          if (!zoomFactor) {
            zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
          } else {
            if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
              zoomFactor = undefined;
              break;
            }
          }
        }
      }
      /**
       * @private
       * @type {number|undefined}
       */


      this.zoomFactor_ = zoomFactor;
      /**
       * @protected
       * @type {number}
       */

      this.maxZoom = this.resolutions_.length - 1;
      /**
       * @private
       * @type {import("../coordinate.js").Coordinate|null}
       */

      this.origin_ = options.origin !== undefined ? options.origin : null;
      /**
       * @private
       * @type {Array<import("../coordinate.js").Coordinate>}
       */

      this.origins_ = null;

      if (options.origins !== undefined) {
        this.origins_ = options.origins;
        assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
      }

      var extent = options.extent;

      if (extent !== undefined && !this.origin_ && !this.origins_) {
        this.origin_ = getTopLeft(extent);
      }

      assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

      /**
       * @private
       * @type {Array<number|import("../size.js").Size>}
       */

      this.tileSizes_ = null;

      if (options.tileSizes !== undefined) {
        this.tileSizes_ = options.tileSizes;
        assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
      }
      /**
       * @private
       * @type {number|import("../size.js").Size}
       */


      this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
      assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

      /**
       * @private
       * @type {import("../extent.js").Extent}
       */

      this.extent_ = extent !== undefined ? extent : null;
      /**
       * @private
       * @type {Array<import("../TileRange.js").default>}
       */

      this.fullTileRanges_ = null;
      /**
       * @private
       * @type {import("../size.js").Size}
       */

      this.tmpSize_ = [0, 0];
      /**
       * @private
       * @type {import("../extent.js").Extent}
       */

      this.tmpExtent_ = [0, 0, 0, 0];

      if (options.sizes !== undefined) {
        this.fullTileRanges_ = options.sizes.map(function (size, z) {
          var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));

          if (extent) {
            var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
            tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
            tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
            tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
            tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
          }

          return tileRange;
        }, this);
      } else if (extent) {
        this.calculateTileRanges_(extent);
      }
    }
    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
     * @api
     */


    _createClass(TileGrid, [{
      key: "forEachTileCoord",
      value: function forEachTileCoord(extent, zoom, callback) {
        var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

        for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
          for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
            callback([zoom, i, j]);
          }
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {boolean} Callback succeeded.
       */

    }, {
      key: "forEachTileCoordParentTileRange",
      value: function forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
        var tileRange, x, y;
        var tileCoordExtent = null;
        var z = tileCoord[0] - 1;

        if (this.zoomFactor_ === 2) {
          x = tileCoord[1];
          y = tileCoord[2];
        } else {
          tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
        }

        while (z >= this.minZoom) {
          if (this.zoomFactor_ === 2) {
            x = Math.floor(x / 2);
            y = Math.floor(y / 2);
            tileRange = createOrUpdate(x, x, y, y, tempTileRange);
          } else {
            tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
          }

          if (callback(z, tileRange)) {
            return true;
          }

          --z;
        }

        return false;
      }
      /**
       * Get the extent for this tile grid, if it was configured.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */

    }, {
      key: "getExtent",
      value: function getExtent() {
        return this.extent_;
      }
      /**
       * Get the maximum zoom level for the grid.
       * @return {number} Max zoom.
       * @api
       */

    }, {
      key: "getMaxZoom",
      value: function getMaxZoom() {
        return this.maxZoom;
      }
      /**
       * Get the minimum zoom level for the grid.
       * @return {number} Min zoom.
       * @api
       */

    }, {
      key: "getMinZoom",
      value: function getMinZoom() {
        return this.minZoom;
      }
      /**
       * Get the origin for the grid at the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {import("../coordinate.js").Coordinate} Origin.
       * @api
       */

    }, {
      key: "getOrigin",
      value: function getOrigin(z) {
        if (this.origin_) {
          return this.origin_;
        } else {
          return this.origins_[z];
        }
      }
      /**
       * Get the resolution for the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {number} Resolution.
       * @api
       */

    }, {
      key: "getResolution",
      value: function getResolution(z) {
        return this.resolutions_[z];
      }
      /**
       * Get the list of resolutions for the tile grid.
       * @return {Array<number>} Resolutions.
       * @api
       */

    }, {
      key: "getResolutions",
      value: function getResolutions() {
        return this.resolutions_;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */

    }, {
      key: "getTileCoordChildTileRange",
      value: function getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
        if (tileCoord[0] < this.maxZoom) {
          if (this.zoomFactor_ === 2) {
            var minX = tileCoord[1] * 2;
            var minY = tileCoord[2] * 2;
            return createOrUpdate(minX, minX + 1, minY, minY + 1, tempTileRange);
          }

          var tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent || this.tmpExtent_);
          return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, tempTileRange);
        }

        return null;
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
       * @return {import("../TileRange.js").default|null} Tile range.
       */

    }, {
      key: "getTileRangeForTileCoordAndZ",
      value: function getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
        if (z > this.maxZoom || z < this.minZoom) {
          return null;
        }

        var tileCoordZ = tileCoord[0];
        var tileCoordX = tileCoord[1];
        var tileCoordY = tileCoord[2];

        if (z === tileCoordZ) {
          return createOrUpdate(tileCoordX, tileCoordY, tileCoordX, tileCoordY, tempTileRange);
        }

        if (this.zoomFactor_) {
          var factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
          var minX = Math.floor(tileCoordX * factor);
          var minY = Math.floor(tileCoordY * factor);

          if (z < tileCoordZ) {
            return createOrUpdate(minX, minX, minY, minY, tempTileRange);
          }

          var maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
          var maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
          return createOrUpdate(minX, maxX, minY, maxY, tempTileRange);
        }

        var tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
      }
      /**
       * Get the extent for a tile range.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
       * @return {import("../extent.js").Extent} Extent.
       */

    }, {
      key: "getTileRangeExtent",
      value: function getTileRangeExtent(z, tileRange, tempExtent) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
        var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
        var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
        var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
        var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
        return createOrUpdate$2(minX, minY, maxX, maxY, tempExtent);
      }
      /**
       * Get a tile range for the given extent and integer zoom level.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
       * @return {import("../TileRange.js").default} Tile range.
       */

    }, {
      key: "getTileRangeForExtentAndZ",
      value: function getTileRangeForExtentAndZ(extent, z, tempTileRange) {
        var tileCoord = tmpTileCoord;
        this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
        var minX = tileCoord[1];
        var minY = tileCoord[2];
        this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
        return createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], tempTileRange);
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {import("../coordinate.js").Coordinate} Tile center.
       */

    }, {
      key: "getTileCoordCenter",
      value: function getTileCoordCenter(tileCoord) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
      }
      /**
       * Get the extent of a tile coordinate.
       *
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */

    }, {
      key: "getTileCoordExtent",
      value: function getTileCoordExtent(tileCoord, tempExtent) {
        var origin = this.getOrigin(tileCoord[0]);
        var resolution = this.getResolution(tileCoord[0]);
        var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
        var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
        var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
        var maxX = minX + tileSize[0] * resolution;
        var maxY = minY + tileSize[1] * resolution;
        return createOrUpdate$2(minX, minY, maxX, maxY, tempExtent);
      }
      /**
       * Get the tile coordinate for the given map coordinate and resolution.  This
       * method considers that coordinates that intersect tile boundaries should be
       * assigned the higher tile coordinate.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */

    }, {
      key: "getTileCoordForCoordAndResolution",
      value: function getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
        return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
      }
      /**
       * Note that this method should not be called for resolutions that correspond
       * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {number} resolution Resolution (for a non-integer zoom level).
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */

    }, {
      key: "getTileCoordForXYAndResolution_",
      value: function getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
        var z = this.getZForResolution(resolution);
        var scale = resolution / this.getResolution(z);
        var origin = this.getOrigin(z);
        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
        var tileCoordX = scale * (x - origin[0]) / resolution / tileSize[0];
        var tileCoordY = scale * (origin[1] - y) / resolution / tileSize[1];

        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }

        return createOrUpdate$1(z, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
       * they should have separate implementations.  This method is for integer zoom
       * levels.  The other method should only be called for resolutions corresponding
       * to non-integer zoom levels.
       * @param {number} x Map x coordinate.
       * @param {number} y Map y coordinate.
       * @param {number} z Integer zoom level.
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */

    }, {
      key: "getTileCoordForXYAndZ_",
      value: function getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
        var origin = this.getOrigin(z);
        var resolution = this.getResolution(z);
        var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
        var tileCoordX = (x - origin[0]) / resolution / tileSize[0];
        var tileCoordY = (origin[1] - y) / resolution / tileSize[1];

        if (reverseIntersectionPolicy) {
          tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
          tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
        } else {
          tileCoordX = floor(tileCoordX, DECIMALS);
          tileCoordY = floor(tileCoordY, DECIMALS);
        }

        return createOrUpdate$1(z, tileCoordX, tileCoordY, opt_tileCoord);
      }
      /**
       * Get a tile coordinate given a map coordinate and zoom level.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} z Zoom level.
       * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */

    }, {
      key: "getTileCoordForCoordAndZ",
      value: function getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
        return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {number} Tile resolution.
       */

    }, {
      key: "getTileCoordResolution",
      value: function getTileCoordResolution(tileCoord) {
        return this.resolutions_[tileCoord[0]];
      }
      /**
       * Get the tile size for a zoom level. The type of the return value matches the
       * `tileSize` or `tileSizes` that the tile grid was configured with. To always
       * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
       * @param {number} z Z.
       * @return {number|import("../size.js").Size} Tile size.
       * @api
       */

    }, {
      key: "getTileSize",
      value: function getTileSize(z) {
        if (this.tileSize_) {
          return this.tileSize_;
        } else {
          return this.tileSizes_[z];
        }
      }
      /**
       * @param {number} z Zoom level.
       * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
       */

    }, {
      key: "getFullTileRange",
      value: function getFullTileRange(z) {
        if (!this.fullTileRanges_) {
          return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
        } else {
          return this.fullTileRanges_[z];
        }
      }
      /**
       * @param {number} resolution Resolution.
       * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
       *     If 0, the nearest resolution will be used.
       *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
       *     nearest lower resolution (higher Z) will be used. Default is 0.
       *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
       *
       * For example to change tile Z at the midpoint of zoom levels
       * ```js
       * function(value, high, low) {
       *   return value - low * Math.sqrt(high / low);
       * }
       * ```
       * @return {number} Z.
       * @api
       */

    }, {
      key: "getZForResolution",
      value: function getZForResolution(resolution, opt_direction) {
        var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
        return clamp(z, this.minZoom, this.maxZoom);
      }
      /**
       * The tile with the provided tile coordinate intersects the given viewport.
       * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
       * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
       * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
       */

    }, {
      key: "tileCoordIntersectsViewport",
      value: function tileCoordIntersectsViewport(tileCoord, viewport) {
        return intersectsLinearRing(viewport, 0, viewport.length, 2, this.getTileCoordExtent(tileCoord));
      }
      /**
       * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
       * @private
       */

    }, {
      key: "calculateTileRanges_",
      value: function calculateTileRanges_(extent) {
        var length = this.resolutions_.length;
        var fullTileRanges = new Array(length);

        for (var z = this.minZoom; z < length; ++z) {
          fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
        }

        this.fullTileRanges_ = fullTileRanges;
      }
    }]);

    return TileGrid;
  }();

  /**
   * @module ol/tilegrid
   */
  /**
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {!TileGrid} Default tile grid for the
   * passed projection.
   */

  function getForProjection(projection) {
    var tileGrid = projection.getDefaultTileGrid();

    if (!tileGrid) {
      tileGrid = createForProjection(projection);
      projection.setDefaultTileGrid(tileGrid);
    }

    return tileGrid;
  }
  /**
   * @param {TileGrid} tileGrid Tile grid.
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
   */

  function wrapX(tileGrid, tileCoord, projection) {
    var z = tileCoord[0];
    var center = tileGrid.getTileCoordCenter(tileCoord);
    var projectionExtent = extentFromProjection(projection);

    if (!containsCoordinate(projectionExtent, center)) {
      var worldWidth = getWidth(projectionExtent);
      var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
      center[0] += worldWidth * worldsAway;
      return tileGrid.getTileCoordForCoordAndZ(center, z);
    } else {
      return tileCoord;
    }
  }
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} [maxZoom] Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */

  function createForExtent(extent, maxZoom, tileSize, corner) {
    corner = corner !== undefined ? corner : 'top-left';
    var resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
    return new TileGrid({
      extent: extent,
      origin: getCorner(extent, corner),
      resolutions: resolutions,
      tileSize: tileSize
    });
  }
  /**
   * @typedef {Object} XYZOptions
   * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
   * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
   * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
   * @property {number} [maxResolution] Resolution at level zero.
   * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
   * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
   * @property {number} [minZoom=0] Minimum zoom.
   * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
   */

  /**
   * Creates a tile grid with a standard XYZ tiling scheme.
   * @param {XYZOptions} [options] Tile grid options.
   * @return {!TileGrid} Tile grid instance.
   * @api
   */

  function createXYZ(options) {
    var xyzOptions = options || {};
    var extent = xyzOptions.extent || get$1('EPSG:3857').getExtent();
    var gridOptions = {
      extent: extent,
      minZoom: xyzOptions.minZoom,
      tileSize: xyzOptions.tileSize,
      resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
    };
    return new TileGrid(gridOptions);
  }
  /**
   * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} [maxZoom] Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {number} [maxResolution] Resolution at level zero.
   * @return {!Array<number>} Resolutions array.
   */

  function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
    maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;
    tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);
    var height = getHeight(extent);
    var width = getWidth(extent);
    maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
    var length = maxZoom + 1;
    var resolutions = new Array(length);

    for (var z = 0; z < length; ++z) {
      resolutions[z] = maxResolution / Math.pow(2, z);
    }

    return resolutions;
  }
  /**
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @param {number} [maxZoom] Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size} [tileSize] Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent.js").Corner} [corner] Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */


  function createForProjection(projection, maxZoom, tileSize, corner) {
    var extent = extentFromProjection(projection);
    return createForExtent(extent, maxZoom, tileSize, corner);
  }
  /**
   * Generate a tile grid extent from a projection.  If the projection has an
   * extent, it is used.  If not, a global extent is assumed.
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @return {import("./extent.js").Extent} Extent.
   */

  function extentFromProjection(projection) {
    projection = get$1(projection);
    var extent = projection.getExtent();

    if (!extent) {
      var half = 180 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit();
      extent = createOrUpdate$2(-half, -half, half, half);
    }

    return extent;
  }

  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("../ObjectEventType").Types, import("../Object").ObjectEvent, Return> &
   *   import("../Observable").OnSignature<import("./TileEventType").TileSourceEventTypes, TileSourceEvent, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("../ObjectEventType").Types|
   *     import("./TileEventType").TileSourceEventTypes, Return>} TileSourceOnSignature
   */

  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] CacheSize.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {number} [tilePixelRatio] TilePixelRatio.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection.
   * @property {import("./Source.js").State} [state] State.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
   * @property {boolean} [wrapX=false] WrapX.
   * @property {number} [transition] Transition.
   * @property {string} [key] Key.
   * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   */

  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for sources providing images divided into a tile grid.
   * @abstract
   * @api
   */

  var TileSource = /*#__PURE__*/function (_Source) {
    _inherits(TileSource, _Source);

    var _super = _createSuper(TileSource);

    /**
     * @param {Options} options SourceTile source options.
     */
    function TileSource(options) {
      var _this;

      _classCallCheck(this, TileSource);

      _this = _super.call(this, {
        attributions: options.attributions,
        attributionsCollapsible: options.attributionsCollapsible,
        projection: options.projection,
        state: options.state,
        wrapX: options.wrapX,
        interpolate: options.interpolate
      });
      /***
       * @type {TileSourceOnSignature<import("../events").EventsKey>}
       */

      _this.on;
      /***
       * @type {TileSourceOnSignature<import("../events").EventsKey>}
       */

      _this.once;
      /***
       * @type {TileSourceOnSignature<void>}
       */

      _this.un;
      /**
       * @private
       * @type {boolean}
       */

      _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
      /**
       * @private
       * @type {number}
       */

      _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
      /**
       * @type {import("../tilegrid/TileGrid.js").default|null}
       */

      _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
      var tileSize = [256, 256];

      if (_this.tileGrid) {
        toSize(_this.tileGrid.getTileSize(_this.tileGrid.getMinZoom()), tileSize);
      }
      /**
       * @protected
       * @type {import("../TileCache.js").default}
       */


      _this.tileCache = new TileCache(options.cacheSize || 0);
      /**
       * @protected
       * @type {import("../size.js").Size}
       */

      _this.tmpSize = [0, 0];
      /**
       * @private
       * @type {string}
       */

      _this.key_ = options.key || '';
      /**
       * @protected
       * @type {import("../Tile.js").Options}
       */

      _this.tileOptions = {
        transition: options.transition,
        interpolate: options.interpolate
      };
      /**
       * zDirection hint, read by the renderer. Indicates which resolution should be used
       * by a renderer if the views resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @type {number|import("../array.js").NearestDirectionFunction}
       */

      _this.zDirection = options.zDirection ? options.zDirection : 0;
      return _this;
    }
    /**
     * @return {boolean} Can expire cache.
     */


    _createClass(TileSource, [{
      key: "canExpireCache",
      value: function canExpireCache() {
        return this.tileCache.canExpireCache();
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */

    }, {
      key: "expireCache",
      value: function expireCache(projection, usedTiles) {
        var tileCache = this.getTileCacheForProjection(projection);

        if (tileCache) {
          tileCache.expireCache(usedTiles);
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {number} z Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
       *     loaded tile.  If the callback returns `false`, the tile will not be
       *     considered loaded.
       * @return {boolean} The tile range is fully covered with loaded tiles.
       */

    }, {
      key: "forEachLoadedTile",
      value: function forEachLoadedTile(projection, z, tileRange, callback) {
        var tileCache = this.getTileCacheForProjection(projection);

        if (!tileCache) {
          return false;
        }

        var covered = true;
        var tile, tileCoordKey, loaded;

        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
            tileCoordKey = getKeyZXY(z, x, y);
            loaded = false;

            if (tileCache.containsKey(tileCoordKey)) {
              tile =
              /** @type {!import("../Tile.js").default} */
              tileCache.get(tileCoordKey);
              loaded = tile.getState() === TileState.LOADED;

              if (loaded) {
                loaded = callback(tile) !== false;
              }
            }

            if (!loaded) {
              covered = false;
            }
          }
        }

        return covered;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */

    }, {
      key: "getGutterForProjection",
      value: function getGutterForProjection(projection) {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       */

    }, {
      key: "getKey",
      value: function getKey() {
        return this.key_;
      }
      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */

    }, {
      key: "setKey",
      value: function setKey(key) {
        if (this.key_ !== key) {
          this.key_ = key;
          this.changed();
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */

    }, {
      key: "getOpaque",
      value: function getOpaque(projection) {
        return this.opaque_;
      }
      /**
       * @return {Array<number>|null} Resolutions.
       */

    }, {
      key: "getResolutions",
      value: function getResolutions() {
        if (!this.tileGrid) {
          return null;
        }

        return this.tileGrid.getResolutions();
      }
      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       */

    }, {
      key: "getTile",
      value: function getTile(z, x, y, pixelRatio, projection) {
        return _abstract();
      }
      /**
       * Return the tile grid of the tile source.
       * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
       * @api
       */

    }, {
      key: "getTileGrid",
      value: function getTileGrid() {
        return this.tileGrid;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */

    }, {
      key: "getTileGridForProjection",
      value: function getTileGridForProjection(projection) {
        if (!this.tileGrid) {
          return getForProjection(projection);
        } else {
          return this.tileGrid;
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       * @protected
       */

    }, {
      key: "getTileCacheForProjection",
      value: function getTileCacheForProjection(projection) {
        var sourceProjection = this.getProjection();
        assert(sourceProjection === null || equivalent(sourceProjection, projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
        );
        return this.tileCache;
      }
      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */

    }, {
      key: "getTilePixelRatio",
      value: function getTilePixelRatio(pixelRatio) {
        return this.tilePixelRatio_;
      }
      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../size.js").Size} Tile size.
       */

    }, {
      key: "getTilePixelSize",
      value: function getTilePixelSize(z, pixelRatio, projection) {
        var tileGrid = this.getTileGridForProjection(projection);
        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);

        if (tilePixelRatio == 1) {
          return tileSize;
        } else {
          return scale(tileSize, tilePixelRatio, this.tmpSize);
        }
      }
      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../proj/Projection.js").default} [projection] Projection.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */

    }, {
      key: "getTileCoordForTileUrlFunction",
      value: function getTileCoordForTileUrlFunction(tileCoord, projection) {
        projection = projection !== undefined ? projection : this.getProjection();
        var tileGrid = this.getTileGridForProjection(projection);

        if (this.getWrapX() && projection.isGlobal()) {
          tileCoord = wrapX(tileGrid, tileCoord, projection);
        }

        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      }
      /**
       * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
       * @api
       */

    }, {
      key: "clear",
      value: function clear() {
        this.tileCache.clear();
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this.clear();

        _get(_getPrototypeOf(TileSource.prototype), "refresh", this).call(this);
      }
      /**
       * Increases the cache size if needed
       * @param {number} tileCount Minimum number of tiles needed.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */

    }, {
      key: "updateCacheSize",
      value: function updateCacheSize(tileCount, projection) {
        var tileCache = this.getTileCacheForProjection(projection);

        if (tileCount > tileCache.highWaterMark) {
          tileCache.highWaterMark = tileCount;
        }
      }
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */

    }, {
      key: "useTile",
      value: function useTile(z, x, y, projection) {}
    }]);

    return TileSource;
  }(Source);
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
   * type.
   */


  var TileSourceEvent = /*#__PURE__*/function (_Event) {
    _inherits(TileSourceEvent, _Event);

    var _super2 = _createSuper(TileSourceEvent);

    /**
     * @param {string} type Type.
     * @param {import("../Tile.js").default} tile The tile.
     */
    function TileSourceEvent(type, tile) {
      var _this2;

      _classCallCheck(this, TileSourceEvent);

      _this2 = _super2.call(this, type);
      /**
       * The tile related to the event.
       * @type {import("../Tile.js").default}
       * @api
       */

      _this2.tile = tile;
      return _this2;
    }

    return _createClass(TileSourceEvent);
  }(BaseEvent);

  /**
   * @module ol/tileurlfunction
   */
  /**
   * @param {string} template Template.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */

  function createFromTemplate(template, tileGrid) {
    var zRegEx = /\{z\}/g;
    var xRegEx = /\{x\}/g;
    var yRegEx = /\{y\}/g;
    var dashYRegEx = /\{-y\}/g;
    return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            assert(range, 55); // The {-y} placeholder requires a tile grid with extent

            var y = range.getHeight() - tileCoord[2] - 1;
            return y.toString();
          });
        }
      }
    );
  }
  /**
   * @param {Array<string>} templates Templates.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */

  function createFromTemplates(templates, tileGrid) {
    var len = templates.length;
    var tileUrlFunctions = new Array(len);

    for (var i = 0; i < len; ++i) {
      tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
    }

    return createFromTileUrlFunctions(tileUrlFunctions);
  }
  /**
   * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */

  function createFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) {
      return tileUrlFunctions[0];
    }

    return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          var h = hash(tileCoord);
          var index = modulo(h, tileUrlFunctions.length);
          return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
        }
      }
    );
  }
  /**
   * @param {string} url URL.
   * @return {Array<string>} Array of urls.
   */

  function expandUrl(url) {
    var urls = [];
    var match = /\{([a-z])-([a-z])\}/.exec(url);

    if (match) {
      // char range
      var startCharCode = match[1].charCodeAt(0);
      var stopCharCode = match[2].charCodeAt(0);
      var charCode;

      for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
        urls.push(url.replace(match[0], String.fromCharCode(charCode)));
      }

      return urls;
    }

    match = /\{(\d+)-(\d+)\}/.exec(url);

    if (match) {
      // number range
      var stop = parseInt(match[2], 10);

      for (var i = parseInt(match[1], 10); i <= stop; i++) {
        urls.push(url.replace(match[0], i.toString()));
      }

      return urls;
    }

    urls.push(url);
    return urls;
  }

  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Cache size.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection.
   * @property {import("./Source.js").State} [state] State.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] TileGrid.
   * @property {import("../Tile.js").LoadFunction} tileLoadFunction TileLoadFunction.
   * @property {number} [tilePixelRatio] TilePixelRatio.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] TileUrlFunction.
   * @property {string} [url] Url.
   * @property {Array<string>} [urls] Urls.
   * @property {boolean} [wrapX=true] WrapX.
   * @property {number} [transition] Transition.
   * @property {string} [key] Key.
   * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0] ZDirection.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   */

  /**
   * @classdesc
   * Base class for sources providing tiles divided into a tile grid over http.
   *
   * @fires import("./Tile.js").TileSourceEvent
   */

  var UrlTile = /*#__PURE__*/function (_TileSource) {
    _inherits(UrlTile, _TileSource);

    var _super = _createSuper(UrlTile);

    /**
     * @param {Options} options Image tile options.
     */
    function UrlTile(options) {
      var _this;

      _classCallCheck(this, UrlTile);

      _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        opaque: options.opaque,
        projection: options.projection,
        state: options.state,
        tileGrid: options.tileGrid,
        tilePixelRatio: options.tilePixelRatio,
        wrapX: options.wrapX,
        transition: options.transition,
        interpolate: options.interpolate,
        key: options.key,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      });
      /**
       * @private
       * @type {boolean}
       */

      _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
      /**
       * @protected
       * @type {import("../Tile.js").LoadFunction}
       */

      _this.tileLoadFunction = options.tileLoadFunction;

      if (options.tileUrlFunction) {
        _this.tileUrlFunction = options.tileUrlFunction;
      }
      /**
       * @protected
       * @type {!Array<string>|null}
       */


      _this.urls = null;

      if (options.urls) {
        _this.setUrls(options.urls);
      } else if (options.url) {
        _this.setUrl(options.url);
      }
      /**
       * @private
       * @type {!Object<string, boolean>}
       */


      _this.tileLoadingKeys_ = {};
      return _this;
    }
    /**
     * Return the tile load function of the source.
     * @return {import("../Tile.js").LoadFunction} TileLoadFunction
     * @api
     */


    _createClass(UrlTile, [{
      key: "getTileLoadFunction",
      value: function getTileLoadFunction() {
        return this.tileLoadFunction;
      }
      /**
       * Return the tile URL function of the source.
       * @return {import("../Tile.js").UrlFunction} TileUrlFunction
       * @api
       */

    }, {
      key: "getTileUrlFunction",
      value: function getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
      }
      /**
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array<string>|null} URLs.
       * @api
       */

    }, {
      key: "getUrls",
      value: function getUrls() {
        return this.urls;
      }
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */

    }, {
      key: "handleTileChange",
      value: function handleTileChange(event) {
        var tile =
        /** @type {import("../Tile.js").default} */
        event.target;
        var uid = getUid(tile);
        var tileState = tile.getState();
        var type;

        if (tileState == TileState.LOADING) {
          this.tileLoadingKeys_[uid] = true;
          type = TileEventType.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
          delete this.tileLoadingKeys_[uid];
          type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;
        }

        if (type != undefined) {
          this.dispatchEvent(new TileSourceEvent(type, tile));
        }
      }
      /**
       * Set the tile load function of the source.
       * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @api
       */

    }, {
      key: "setTileLoadFunction",
      value: function setTileLoadFunction(tileLoadFunction) {
        this.tileCache.clear();
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
      }
      /**
       * Set the tile URL function of the source.
       * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
       * @param {string} [key] Optional new tile key for the source.
       * @api
       */

    }, {
      key: "setTileUrlFunction",
      value: function setTileUrlFunction(tileUrlFunction, key) {
        this.tileUrlFunction = tileUrlFunction;
        this.tileCache.pruneExceptNewestZ();

        if (typeof key !== 'undefined') {
          this.setKey(key);
        } else {
          this.changed();
        }
      }
      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */

    }, {
      key: "setUrl",
      value: function setUrl(url) {
        var urls = expandUrl(url);
        this.urls = urls;
        this.setUrls(urls);
      }
      /**
       * Set the URLs to use for requests.
       * @param {Array<string>} urls URLs.
       * @api
       */

    }, {
      key: "setUrls",
      value: function setUrls(urls) {
        this.urls = urls;
        var key = urls.join('\n');

        if (this.generateTileUrlFunction_) {
          this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
        } else {
          this.setKey(key);
        }
      }
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */

    }, {
      key: "tileUrlFunction",
      value: function tileUrlFunction(tileCoord, pixelRatio, projection) {
        return undefined;
      }
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       */

    }, {
      key: "useTile",
      value: function useTile(z, x, y) {
        var tileCoordKey = getKeyZXY(z, x, y);

        if (this.tileCache.containsKey(tileCoordKey)) {
          this.tileCache.get(tileCoordKey);
        }
      }
    }]);

    return UrlTile;
  }(TileSource);

  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
   * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("./Source.js").State} [state] Source state.
   * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
   * Default is {@link module:ol/ImageTile~ImageTile}.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
   * service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
   * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
   * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
   * used instead of defining each one separately in the `urls` option.
   * @property {Array<string>} [urls] An array of URL templates.
   * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
   * request out-of-bounds tiles from the server. When set to `false`, only one
   * world will be rendered. When set to `true`, tiles will be requested for one
   * world only, but they will be wrapped horizontally to render multiple worlds.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {string} [key] Optional tile key for proper cache fetching
   * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
   * Choose whether to use tiles with a higher or lower zoom level when between integer
   * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
   */

  /**
   * @classdesc
   * Base class for sources providing images divided into a tile grid.
   *
   * @fires import("./Tile.js").TileSourceEvent
   * @api
   */

  var TileImage = /*#__PURE__*/function (_UrlTile) {
    _inherits(TileImage, _UrlTile);

    var _super = _createSuper(TileImage);

    /**
     * @param {!Options} options Image tile options.
     */
    function TileImage(options) {
      var _this;

      _classCallCheck(this, TileImage);

      _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        opaque: options.opaque,
        projection: options.projection,
        state: options.state,
        tileGrid: options.tileGrid,
        tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
        tilePixelRatio: options.tilePixelRatio,
        tileUrlFunction: options.tileUrlFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX,
        transition: options.transition,
        interpolate: options.interpolate !== undefined ? options.interpolate : true,
        key: options.key,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      });
      /**
       * @protected
       * @type {?string}
       */

      _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
      /**
       * @protected
       * @type {typeof ImageTile}
       */

      _this.tileClass = options.tileClass !== undefined ? options.tileClass : ImageTile;
      /**
       * @protected
       * @type {!Object<string, TileCache>}
       */

      _this.tileCacheForProjection = {};
      /**
       * @protected
       * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
       */

      _this.tileGridForProjection = {};
      /**
       * @private
       * @type {number|undefined}
       */

      _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
      /**
       * @private
       * @type {boolean}
       */

      _this.renderReprojectionEdges_ = false;
      return _this;
    }
    /**
     * @return {boolean} Can expire cache.
     */


    _createClass(TileImage, [{
      key: "canExpireCache",
      value: function canExpireCache() {
        if (this.tileCache.canExpireCache()) {
          return true;
        } else {
          for (var key in this.tileCacheForProjection) {
            if (this.tileCacheForProjection[key].canExpireCache()) {
              return true;
            }
          }
        }

        return false;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */

    }, {
      key: "expireCache",
      value: function expireCache(projection, usedTiles) {
        var usedTileCache = this.getTileCacheForProjection(projection);
        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

        for (var id in this.tileCacheForProjection) {
          var tileCache = this.tileCacheForProjection[id];
          tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */

    }, {
      key: "getGutterForProjection",
      value: function getGutterForProjection(projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return 0;
        } else {
          return this.getGutter();
        }
      }
      /**
       * @return {number} Gutter.
       */

    }, {
      key: "getGutter",
      value: function getGutter() {
        return 0;
      }
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       */

    }, {
      key: "getKey",
      value: function getKey() {
        var key = _get(_getPrototypeOf(TileImage.prototype), "getKey", this).call(this);

        if (!this.getInterpolate()) {
          key += ':disable-interpolation';
        }

        return key;
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */

    }, {
      key: "getOpaque",
      value: function getOpaque(projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return false;
        } else {
          return _get(_getPrototypeOf(TileImage.prototype), "getOpaque", this).call(this, projection);
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */

    }, {
      key: "getTileGridForProjection",
      value: function getTileGridForProjection(projection) {
        var thisProj = this.getProjection();

        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
          return this.tileGrid;
        } else {
          var projKey = getUid(projection);

          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = getForProjection(projection);
          }

          return this.tileGridForProjection[projKey];
        }
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       */

    }, {
      key: "getTileCacheForProjection",
      value: function getTileCacheForProjection(projection) {
        var thisProj = this.getProjection();

        if (!thisProj || equivalent(thisProj, projection)) {
          return this.tileCache;
        } else {
          var projKey = getUid(projection);

          if (!(projKey in this.tileCacheForProjection)) {
            this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
          }

          return this.tileCacheForProjection[projKey];
        }
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!ImageTile} Tile.
       * @private
       */

    }, {
      key: "createTile_",
      value: function createTile_(z, x, y, pixelRatio, projection, key) {
        var tileCoord = [z, x, y];
        var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
        var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
        tile.key = key;
        tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
        return tile;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!(ImageTile|ReprojTile)} Tile.
       */

    }, {
      key: "getTile",
      value: function getTile(z, x, y, pixelRatio, projection) {
        var sourceProjection = this.getProjection();

        if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
        } else {
          var cache = this.getTileCacheForProjection(projection);
          var tileCoord = [z, x, y];
          var tile;
          var tileCoordKey = getKey(tileCoord);

          if (cache.containsKey(tileCoordKey)) {
            tile = cache.get(tileCoordKey);
          }

          var key = this.getKey();

          if (tile && tile.key == key) {
            return tile;
          } else {
            var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
            var targetTileGrid = this.getTileGridForProjection(projection);
            var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
            var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
            }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.getInterpolate());
            newTile.key = key;

            if (tile) {
              newTile.interimTile = tile;
              newTile.refreshInterimChain();
              cache.replace(tileCoordKey, newTile);
            } else {
              cache.set(tileCoordKey, newTile);
            }

            return newTile;
          }
        }
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!import("../proj/Projection.js").default} projection Projection.
       * @return {!(ImageTile|ReprojTile)} Tile.
       * @protected
       */

    }, {
      key: "getTileInternal",
      value: function getTileInternal(z, x, y, pixelRatio, projection) {
        var tile = null;
        var tileCoordKey = getKeyZXY(z, x, y);
        var key = this.getKey();

        if (!this.tileCache.containsKey(tileCoordKey)) {
          tile = this.createTile_(z, x, y, pixelRatio, projection, key);
          this.tileCache.set(tileCoordKey, tile);
        } else {
          tile = this.tileCache.get(tileCoordKey);

          if (tile.key != key) {
            // The source's params changed. If the tile has an interim tile and if we
            // can use it then we use it. Otherwise we create a new tile.  In both
            // cases we attempt to assign an interim tile to the new tile.
            var interimTile = tile;
            tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

            if (interimTile.getState() == TileState.IDLE) {
              //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
              tile.interimTile = interimTile.interimTile;
            } else {
              tile.interimTile = interimTile;
            }

            tile.refreshInterimChain();
            this.tileCache.replace(tileCoordKey, tile);
          }
        }

        return tile;
      }
      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */

    }, {
      key: "setRenderReprojectionEdges",
      value: function setRenderReprojectionEdges(render) {
        if (this.renderReprojectionEdges_ == render) {
          return;
        }

        this.renderReprojectionEdges_ = render;

        for (var id in this.tileCacheForProjection) {
          this.tileCacheForProjection[id].clear();
        }

        this.changed();
      }
      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
       * @api
       */

    }, {
      key: "setTileGridForProjection",
      value: function setTileGridForProjection(projection, tilegrid) {
        var proj = get$1(projection);

        if (proj) {
          var projKey = getUid(proj);

          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = tilegrid;
          }
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        _get(_getPrototypeOf(TileImage.prototype), "clear", this).call(this);

        for (var id in this.tileCacheForProjection) {
          this.tileCacheForProjection[id].clear();
        }
      }
    }]);

    return TileImage;
  }(UrlTile);
  /**
   * @param {ImageTile} imageTile Image tile.
   * @param {string} src Source.
   */


  function defaultTileLoadFunction(imageTile, src) {
    /** @type {HTMLImageElement|HTMLVideoElement} */
    imageTile.getImage().src = src;
  }

  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
   * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
   * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
   * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
   * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
   * Not used if `tileGrid` is provided.
   * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
   * This allows artifacts of rendering at tile edges to be ignored.
   * Supported images should be wider and taller than the tile size by a value of `2 x gutter`.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
   * tile URL given a tile coordinate and the projection.
   * Required if `url` or `urls` are not provided.
   * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
   * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
   * may be used instead of defining each one separately in the `urls` option.
   * @property {Array<string>} [urls] An array of URL templates.
   * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
   * @property {number} [transition=250] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
   * Choose whether to use tiles with a higher or lower zoom level when between integer
   * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
   */

  /**
   * @classdesc
   * Layer source for tile data with URLs in a set XYZ format that are
   * defined in a URL template. By default, this follows the widely-used
   * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
   * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
   * using the `{-y}` placeholder in the URL template, so long as the
   * source does not have a custom tile grid. In this case
   * a `tileUrlFunction` can be used, such as:
   * ```js
   *  tileUrlFunction: function(coordinate) {
   *    return 'http://mapserver.com/' + coordinate[0] + '/' +
   *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
   *  }
   * ```
   * @api
   */

  var XYZ = /*#__PURE__*/function (_TileImage) {
    _inherits(XYZ, _TileImage);

    var _super = _createSuper(XYZ);

    /**
     * @param {Options} [options] XYZ options.
     */
    function XYZ(options) {
      var _this;

      _classCallCheck(this, XYZ);

      options = options || {};
      var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
      var tileGrid = options.tileGrid !== undefined ? options.tileGrid : createXYZ({
        extent: extentFromProjection(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
      _this = _super.call(this, {
        attributions: options.attributions,
        cacheSize: options.cacheSize,
        crossOrigin: options.crossOrigin,
        interpolate: options.interpolate,
        opaque: options.opaque,
        projection: projection,
        reprojectionErrorThreshold: options.reprojectionErrorThreshold,
        tileGrid: tileGrid,
        tileLoadFunction: options.tileLoadFunction,
        tilePixelRatio: options.tilePixelRatio,
        tileUrlFunction: options.tileUrlFunction,
        url: options.url,
        urls: options.urls,
        wrapX: options.wrapX !== undefined ? options.wrapX : true,
        transition: options.transition,
        attributionsCollapsible: options.attributionsCollapsible,
        zDirection: options.zDirection
      });
      /**
       * @private
       * @type {number}
       */

      _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
      return _this;
    }
    /**
     * @return {number} Gutter.
     */


    _createClass(XYZ, [{
      key: "getGutter",
      value: function getGutter() {
        return this.gutter_;
      }
    }]);

    return XYZ;
  }(TileImage);

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var rbush_min = {exports: {}};

  (function (module, exports) {
    !function (t, i) {
      module.exports = i() ;
    }(commonjsGlobal, function () {

      function t(t, r, e, a, h) {
        !function t(n, r, e, a, h) {
          for (; a > e;) {
            if (a - e > 600) {
              var o = a - e + 1,
                  s = r - e + 1,
                  l = Math.log(o),
                  f = .5 * Math.exp(2 * l / 3),
                  u = .5 * Math.sqrt(l * f * (o - f) / o) * (s - o / 2 < 0 ? -1 : 1),
                  m = Math.max(e, Math.floor(r - s * f / o + u)),
                  c = Math.min(a, Math.floor(r + (o - s) * f / o + u));
              t(n, r, m, c, h);
            }

            var p = n[r],
                d = e,
                x = a;

            for (i(n, e, r), h(n[a], p) > 0 && i(n, e, a); d < x;) {
              for (i(n, d, x), d++, x--; h(n[d], p) < 0;) {
                d++;
              }

              for (; h(n[x], p) > 0;) {
                x--;
              }
            }

            0 === h(n[e], p) ? i(n, e, x) : i(n, ++x, a), x <= r && (e = x + 1), r <= x && (a = x - 1);
          }
        }(t, r, e || 0, a || t.length - 1, h || n);
      }

      function i(t, i, n) {
        var r = t[i];
        t[i] = t[n], t[n] = r;
      }

      function n(t, i) {
        return t < i ? -1 : t > i ? 1 : 0;
      }

      var r = function r(t) {
        void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear();
      };

      function e(t, i, n) {
        if (!n) return i.indexOf(t);

        for (var r = 0; r < i.length; r++) {
          if (n(t, i[r])) return r;
        }

        return -1;
      }

      function a(t, i) {
        h(t, 0, t.children.length, i, t);
      }

      function h(t, i, n, r, e) {
        e || (e = p(null)), e.minX = 1 / 0, e.minY = 1 / 0, e.maxX = -1 / 0, e.maxY = -1 / 0;

        for (var a = i; a < n; a++) {
          var h = t.children[a];
          o(e, t.leaf ? r(h) : h);
        }

        return e;
      }

      function o(t, i) {
        return t.minX = Math.min(t.minX, i.minX), t.minY = Math.min(t.minY, i.minY), t.maxX = Math.max(t.maxX, i.maxX), t.maxY = Math.max(t.maxY, i.maxY), t;
      }

      function s(t, i) {
        return t.minX - i.minX;
      }

      function l(t, i) {
        return t.minY - i.minY;
      }

      function f(t) {
        return (t.maxX - t.minX) * (t.maxY - t.minY);
      }

      function u(t) {
        return t.maxX - t.minX + (t.maxY - t.minY);
      }

      function m(t, i) {
        return t.minX <= i.minX && t.minY <= i.minY && i.maxX <= t.maxX && i.maxY <= t.maxY;
      }

      function c(t, i) {
        return i.minX <= t.maxX && i.minY <= t.maxY && i.maxX >= t.minX && i.maxY >= t.minY;
      }

      function p(t) {
        return {
          children: t,
          height: 1,
          leaf: !0,
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0
        };
      }

      function d(i, n, r, e, a) {
        for (var h = [n, r]; h.length;) {
          if (!((r = h.pop()) - (n = h.pop()) <= e)) {
            var o = n + Math.ceil((r - n) / e / 2) * e;
            t(i, o, n, r, a), h.push(n, o, o, r);
          }
        }
      }

      return r.prototype.all = function () {
        return this._all(this.data, []);
      }, r.prototype.search = function (t) {
        var i = this.data,
            n = [];
        if (!c(t, i)) return n;

        for (var r = this.toBBox, e = []; i;) {
          for (var a = 0; a < i.children.length; a++) {
            var h = i.children[a],
                o = i.leaf ? r(h) : h;
            c(t, o) && (i.leaf ? n.push(h) : m(t, o) ? this._all(h, n) : e.push(h));
          }

          i = e.pop();
        }

        return n;
      }, r.prototype.collides = function (t) {
        var i = this.data;
        if (!c(t, i)) return !1;

        for (var n = []; i;) {
          for (var r = 0; r < i.children.length; r++) {
            var e = i.children[r],
                a = i.leaf ? this.toBBox(e) : e;

            if (c(t, a)) {
              if (i.leaf || m(t, a)) return !0;
              n.push(e);
            }
          }

          i = n.pop();
        }

        return !1;
      }, r.prototype.load = function (t) {
        if (!t || !t.length) return this;

        if (t.length < this._minEntries) {
          for (var i = 0; i < t.length; i++) {
            this.insert(t[i]);
          }

          return this;
        }

        var n = this._build(t.slice(), 0, t.length - 1, 0);

        if (this.data.children.length) {
          if (this.data.height === n.height) this._splitRoot(this.data, n);else {
            if (this.data.height < n.height) {
              var r = this.data;
              this.data = n, n = r;
            }

            this._insert(n, this.data.height - n.height - 1, !0);
          }
        } else this.data = n;
        return this;
      }, r.prototype.insert = function (t) {
        return t && this._insert(t, this.data.height - 1), this;
      }, r.prototype.clear = function () {
        return this.data = p([]), this;
      }, r.prototype.remove = function (t, i) {
        if (!t) return this;

        for (var n, r, a, h = this.data, o = this.toBBox(t), s = [], l = []; h || s.length;) {
          if (h || (h = s.pop(), r = s[s.length - 1], n = l.pop(), a = !0), h.leaf) {
            var f = e(t, h.children, i);
            if (-1 !== f) return h.children.splice(f, 1), s.push(h), this._condense(s), this;
          }

          a || h.leaf || !m(h, o) ? r ? (n++, h = r.children[n], a = !1) : h = null : (s.push(h), l.push(n), n = 0, r = h, h = h.children[0]);
        }

        return this;
      }, r.prototype.toBBox = function (t) {
        return t;
      }, r.prototype.compareMinX = function (t, i) {
        return t.minX - i.minX;
      }, r.prototype.compareMinY = function (t, i) {
        return t.minY - i.minY;
      }, r.prototype.toJSON = function () {
        return this.data;
      }, r.prototype.fromJSON = function (t) {
        return this.data = t, this;
      }, r.prototype._all = function (t, i) {
        for (var n = []; t;) {
          t.leaf ? i.push.apply(i, t.children) : n.push.apply(n, t.children), t = n.pop();
        }

        return i;
      }, r.prototype._build = function (t, i, n, r) {
        var e,
            h = n - i + 1,
            o = this._maxEntries;
        if (h <= o) return a(e = p(t.slice(i, n + 1)), this.toBBox), e;
        r || (r = Math.ceil(Math.log(h) / Math.log(o)), o = Math.ceil(h / Math.pow(o, r - 1))), (e = p([])).leaf = !1, e.height = r;
        var s = Math.ceil(h / o),
            l = s * Math.ceil(Math.sqrt(o));
        d(t, i, n, l, this.compareMinX);

        for (var f = i; f <= n; f += l) {
          var u = Math.min(f + l - 1, n);
          d(t, f, u, s, this.compareMinY);

          for (var m = f; m <= u; m += s) {
            var c = Math.min(m + s - 1, u);
            e.children.push(this._build(t, m, c, r - 1));
          }
        }

        return a(e, this.toBBox), e;
      }, r.prototype._chooseSubtree = function (t, i, n, r) {
        for (; r.push(i), !i.leaf && r.length - 1 !== n;) {
          for (var e = 1 / 0, a = 1 / 0, h = void 0, o = 0; o < i.children.length; o++) {
            var s = i.children[o],
                l = f(s),
                u = (m = t, c = s, (Math.max(c.maxX, m.maxX) - Math.min(c.minX, m.minX)) * (Math.max(c.maxY, m.maxY) - Math.min(c.minY, m.minY)) - l);
            u < a ? (a = u, e = l < e ? l : e, h = s) : u === a && l < e && (e = l, h = s);
          }

          i = h || i.children[0];
        }

        var m, c;
        return i;
      }, r.prototype._insert = function (t, i, n) {
        var r = n ? t : this.toBBox(t),
            e = [],
            a = this._chooseSubtree(r, this.data, i, e);

        for (a.children.push(t), o(a, r); i >= 0 && e[i].children.length > this._maxEntries;) {
          this._split(e, i), i--;
        }

        this._adjustParentBBoxes(r, e, i);
      }, r.prototype._split = function (t, i) {
        var n = t[i],
            r = n.children.length,
            e = this._minEntries;

        this._chooseSplitAxis(n, e, r);

        var h = this._chooseSplitIndex(n, e, r),
            o = p(n.children.splice(h, n.children.length - h));

        o.height = n.height, o.leaf = n.leaf, a(n, this.toBBox), a(o, this.toBBox), i ? t[i - 1].children.push(o) : this._splitRoot(n, o);
      }, r.prototype._splitRoot = function (t, i) {
        this.data = p([t, i]), this.data.height = t.height + 1, this.data.leaf = !1, a(this.data, this.toBBox);
      }, r.prototype._chooseSplitIndex = function (t, i, n) {
        for (var r, e, a, o, s, l, u, m = 1 / 0, c = 1 / 0, p = i; p <= n - i; p++) {
          var d = h(t, 0, p, this.toBBox),
              x = h(t, p, n, this.toBBox),
              v = (e = d, a = x, o = void 0, s = void 0, l = void 0, u = void 0, o = Math.max(e.minX, a.minX), s = Math.max(e.minY, a.minY), l = Math.min(e.maxX, a.maxX), u = Math.min(e.maxY, a.maxY), Math.max(0, l - o) * Math.max(0, u - s)),
              M = f(d) + f(x);
          v < m ? (m = v, r = p, c = M < c ? M : c) : v === m && M < c && (c = M, r = p);
        }

        return r || n - i;
      }, r.prototype._chooseSplitAxis = function (t, i, n) {
        var r = t.leaf ? this.compareMinX : s,
            e = t.leaf ? this.compareMinY : l;
        this._allDistMargin(t, i, n, r) < this._allDistMargin(t, i, n, e) && t.children.sort(r);
      }, r.prototype._allDistMargin = function (t, i, n, r) {
        t.children.sort(r);

        for (var e = this.toBBox, a = h(t, 0, i, e), s = h(t, n - i, n, e), l = u(a) + u(s), f = i; f < n - i; f++) {
          var m = t.children[f];
          o(a, t.leaf ? e(m) : m), l += u(a);
        }

        for (var c = n - i - 1; c >= i; c--) {
          var p = t.children[c];
          o(s, t.leaf ? e(p) : p), l += u(s);
        }

        return l;
      }, r.prototype._adjustParentBBoxes = function (t, i, n) {
        for (var r = n; r >= 0; r--) {
          o(i[r], t);
        }
      }, r.prototype._condense = function (t) {
        for (var i = t.length - 1, n = void 0; i >= 0; i--) {
          0 === t[i].children.length ? i > 0 ? (n = t[i - 1].children).splice(n.indexOf(t[i]), 1) : this.clear() : a(t[i], this.toBBox);
        }
      }, r;
    });
  })(rbush_min);

  /**
   * Data that can be used with a DataTile.  For increased browser compatibility, use
   * Uint8Array instead of Uint8ClampedArray where possible.
   * @typedef {Uint8Array|Uint8ClampedArray|Float32Array|DataView} Data
   */

  /**
   * @typedef {Object} Options
   * @property {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @property {function(): Promise<Data>} loader Data loader.
   * @property {number} [transition=250] A duration for tile opacity
   * transitions in milliseconds. A duration of 0 disables the opacity transition.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   * @property {import('./size.js').Size} [size=[256, 256]] Tile size.
   * @api
   */

  var DataTile = /*#__PURE__*/function (_Tile) {
    _inherits(DataTile, _Tile);

    var _super = _createSuper(DataTile);

    /**
     * @param {Options} options Tile options.
     */
    function DataTile(options) {
      var _this;

      _classCallCheck(this, DataTile);

      var state = TileState.IDLE;
      _this = _super.call(this, options.tileCoord, state, {
        transition: options.transition,
        interpolate: options.interpolate
      });
      /**
       * @type {function(): Promise<Data>}
       * @private
       */

      _this.loader_ = options.loader;
      /**
       * @type {Data}
       * @private
       */

      _this.data_ = null;
      /**
       * @type {Error}
       * @private
       */

      _this.error_ = null;
      /**
       * @type {import('./size.js').Size}
       * @private
       */

      _this.size_ = options.size || [256, 256];
      return _this;
    }
    /**
     * Get the tile size.
     * @return {import('./size.js').Size} Tile size.
     */


    _createClass(DataTile, [{
      key: "getSize",
      value: function getSize() {
        return this.size_;
      }
      /**
       * Get the data for the tile.
       * @return {Data} Tile data.
       * @api
       */

    }, {
      key: "getData",
      value: function getData() {
        return this.data_;
      }
      /**
       * Get any loading error.
       * @return {Error} Loading error.
       * @api
       */

    }, {
      key: "getError",
      value: function getError() {
        return this.error_;
      }
      /**
       * Load not yet loaded URI.
       * @api
       */

    }, {
      key: "load",
      value: function load() {
        if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {
          return;
        }

        this.state = TileState.LOADING;
        this.changed();
        var self = this;
        this.loader_().then(function (data) {
          self.data_ = data;
          self.state = TileState.LOADED;
          self.changed();
        })["catch"](function (error) {
          self.error_ = error;
          self.state = TileState.ERROR;
          self.changed();
        });
      }
    }]);

    return DataTile;
  }(Tile);

  /**
   * Data tile loading function.  The function is called with z, x, and y tile coordinates and
   * returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
   * @typedef {function(number, number, number) : (import("../DataTile.js").Data|Promise<import("../DataTile.js").Data>)} Loader
   */

  /**
   * @typedef {Object} Options
   * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.
   * Returns {@link import("../DataTile.js").Data data} for a tile or a promise for the same.
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
   * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
   * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.
   * This may be different than the rendered pixel size if a `tileGrid` is provided.
   * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.
   * This allows artifacts of rendering at tile edges to be ignored.
   * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.
   * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
   * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Tile projection.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("./Source.js").State} [state] The source state.
   * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.
   * @property {number} [transition] Transition time when fading in new tiles (in miliseconds).
   * @property {number} [bandCount=4] Number of bands represented in the data.
   * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,
   * the nearest neighbor is used when resampling.
   */

  /**
   * @classdesc
   * A source for typed array data tiles.
   *
   * @fires import("./Tile.js").TileSourceEvent
   * @api
   */

  var DataTileSource = /*#__PURE__*/function (_TileSource) {
    _inherits(DataTileSource, _TileSource);

    var _super = _createSuper(DataTileSource);

    /**
     * @param {Options} options Image tile options.
     */
    function DataTileSource(options) {
      var _this;

      _classCallCheck(this, DataTileSource);

      var projection = options.projection === undefined ? 'EPSG:3857' : options.projection;
      var tileGrid = options.tileGrid;

      if (tileGrid === undefined && projection) {
        tileGrid = createXYZ({
          extent: extentFromProjection(projection),
          maxResolution: options.maxResolution,
          maxZoom: options.maxZoom,
          minZoom: options.minZoom,
          tileSize: options.tileSize
        });
      }

      _this = _super.call(this, {
        cacheSize: 0.1,
        // don't cache on the source
        attributions: options.attributions,
        attributionsCollapsible: options.attributionsCollapsible,
        projection: projection,
        tileGrid: tileGrid,
        opaque: options.opaque,
        state: options.state,
        wrapX: options.wrapX,
        transition: options.transition,
        interpolate: options.interpolate
      });
      /**
       * @private
       * @type {number}
       */

      _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
      /**
       * @private
       * @type {import('../size.js').Size|null}
       */

      _this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;
      /**
       * @private
       * @type {Array<import('../size.js').Size>|null}
       */

      _this.tileSizes_ = null;
      /**
       * @private
       * @type {!Object<string, boolean>}
       */

      _this.tileLoadingKeys_ = {};
      /**
       * @private
       */

      _this.loader_ = options.loader;
      _this.handleTileChange_ = _this.handleTileChange_.bind(_assertThisInitialized(_this));
      /**
       * @type {number}
       */

      _this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined

      return _this;
    }
    /**
     * Set the source tile sizes.  The length of the array is expected to match the number of
     * levels in the tile grid.
     * @protected
     * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.
     */


    _createClass(DataTileSource, [{
      key: "setTileSizes",
      value: function setTileSizes(tileSizes) {
        this.tileSizes_ = tileSizes;
      }
      /**
       * Get the source tile size at the given zoom level.  This may be different than the rendered tile
       * size.
       * @protected
       * @param {number} z Tile zoom level.
       * @return {import('../size.js').Size} The source tile size.
       */

    }, {
      key: "getTileSize",
      value: function getTileSize(z) {
        if (this.tileSizes_) {
          return this.tileSizes_[z];
        }

        if (this.tileSize_) {
          return this.tileSize_;
        }

        var tileGrid = this.getTileGrid();
        return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];
      }
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */

    }, {
      key: "getGutterForProjection",
      value: function getGutterForProjection(projection) {
        return this.gutter_;
      }
      /**
       * @param {Loader} loader The data loader.
       * @protected
       */

    }, {
      key: "setLoader",
      value: function setLoader(loader) {
        this.loader_ = loader;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!DataTile} Tile.
       */

    }, {
      key: "getTile",
      value: function getTile(z, x, y, pixelRatio, projection) {
        var size = this.getTileSize(z);
        var tileCoordKey = getKeyZXY(z, x, y);

        if (this.tileCache.containsKey(tileCoordKey)) {
          return this.tileCache.get(tileCoordKey);
        }

        var sourceLoader = this.loader_;

        function loader() {
          return toPromise(function () {
            return sourceLoader(z, x, y);
          });
        }

        var options = Object.assign({
          tileCoord: [z, x, y],
          loader: loader,
          size: size
        }, this.tileOptions);
        var tile = new DataTile(options);
        tile.key = this.getKey();
        tile.addEventListener(EventType.CHANGE, this.handleTileChange_);
        this.tileCache.set(tileCoordKey, tile);
        return tile;
      }
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       */

    }, {
      key: "handleTileChange_",
      value: function handleTileChange_(event) {
        var tile =
        /** @type {import("../Tile.js").default} */
        event.target;
        var uid = getUid(tile);
        var tileState = tile.getState();
        var type;

        if (tileState == TileState.LOADING) {
          this.tileLoadingKeys_[uid] = true;
          type = TileEventType.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
          delete this.tileLoadingKeys_[uid];
          type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;
        }

        if (type) {
          this.dispatchEvent(new TileSourceEvent(type, tile));
        }
      }
    }]);

    return DataTileSource;
  }(TileSource);

  var geotiff = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      t(exports) ;
    }(commonjsGlobal, function (e) {

      function t(e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }) : e[t] = r, e;
      }

      function r(e) {
        if (Array.isArray(e)) return e;
      }

      function n(e, t) {
        (null == t || t > e.length) && (t = e.length);

        for (var r = 0, n = new Array(t); r < t; r++) {
          n[r] = e[r];
        }

        return n;
      }

      function i(e, t) {
        if (e) {
          if ("string" == typeof e) return n(e, t);
          var r = Object.prototype.toString.call(e).slice(8, -1);
          return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0;
        }
      }

      function a() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function o(e, t) {
        return r(e) || function (e, t) {
          var r = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

          if (null != r) {
            var n,
                i,
                a = [],
                o = !0,
                s = !1;

            try {
              for (r = r.call(e); !(o = (n = r.next()).done) && (a.push(n.value), !t || a.length !== t); o = !0) {
                ;
              }
            } catch (e) {
              s = !0, i = e;
            } finally {
              try {
                o || null == r["return"] || r["return"]();
              } finally {
                if (s) throw i;
              }
            }

            return a;
          }
        }(e, t) || i(e, t) || a();
      }

      function s(e, t, r, n, i, a, o) {
        try {
          var s = e[a](o),
              u = s.value;
        } catch (e) {
          return void r(e);
        }

        s.done ? t(u) : Promise.resolve(u).then(n, i);
      }

      function u(e) {
        return function () {
          var t = this,
              r = arguments;
          return new Promise(function (n, i) {
            var a = e.apply(t, r);

            function o(e) {
              s(a, n, i, o, u, "next", e);
            }

            function u(e) {
              s(a, n, i, o, u, "throw", e);
            }

            o(void 0);
          });
        };
      }

      function f(e, t) {
        for (var r = 0; r < t.length; r++) {
          var n = t[r];
          n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
      }

      function l(e, t, r) {
        return t && f(e.prototype, t), r && f(e, r), e;
      }

      function c(e, t) {
        return c = Object.setPrototypeOf || function (e, t) {
          return e.__proto__ = t, e;
        }, c(e, t);
      }

      function h(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
          constructor: {
            value: e,
            writable: !0,
            configurable: !0
          }
        }), t && c(e, t);
      }

      function d(e) {
        return d = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
          return _typeof(e);
        } : function (e) {
          return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
        }, d(e);
      }

      function p(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }

      function v(e, t) {
        if (t && ("object" === d(t) || "function" == typeof t)) return t;
        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
        return p(e);
      }

      function m(e) {
        return m = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        }, m(e);
      }

      function g() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
        if (Reflect.construct.sham) return !1;
        if ("function" == typeof Proxy) return !0;

        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
        } catch (e) {
          return !1;
        }
      }

      function y(e, t, r) {
        return y = g() ? Reflect.construct : function (e, t, r) {
          var n = [null];
          n.push.apply(n, t);
          var i = new (Function.bind.apply(e, n))();
          return r && c(i, r.prototype), i;
        }, y.apply(null, arguments);
      }

      function w(e) {
        var t = "function" == typeof Map ? new Map() : void 0;
        return w = function w(e) {
          if (null === e || (r = e, -1 === Function.toString.call(r).indexOf("[native code]"))) return e;
          var r;
          if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");

          if (void 0 !== t) {
            if (t.has(e)) return t.get(e);
            t.set(e, n);
          }

          function n() {
            return y(e, arguments, m(this).constructor);
          }

          return n.prototype = Object.create(e.prototype, {
            constructor: {
              value: n,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }), c(n, e);
        }, w(e);
      }

      function b(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
      }

      var k = {
        exports: {}
      };
      !function (e) {
        var t = function (e) {
          var t,
              r = Object.prototype,
              n = r.hasOwnProperty,
              i = "function" == typeof Symbol ? Symbol : {},
              a = i.iterator || "@@iterator",
              o = i.asyncIterator || "@@asyncIterator",
              s = i.toStringTag || "@@toStringTag";

          function u(e, t, r) {
            return Object.defineProperty(e, t, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }), e[t];
          }

          try {
            u({}, "");
          } catch (e) {
            u = function u(e, t, r) {
              return e[t] = r;
            };
          }

          function f(e, t, r, n) {
            var i = t && t.prototype instanceof g ? t : g,
                a = Object.create(i.prototype),
                o = new U(n || []);
            return a._invoke = function (e, t, r) {
              var n = c;
              return function (i, a) {
                if (n === p) throw new Error("Generator is already running");

                if (n === v) {
                  if ("throw" === i) throw a;
                  return D();
                }

                for (r.method = i, r.arg = a;;) {
                  var o = r.delegate;

                  if (o) {
                    var s = I(o, r);

                    if (s) {
                      if (s === m) continue;
                      return s;
                    }
                  }

                  if ("next" === r.method) r.sent = r._sent = r.arg;else if ("throw" === r.method) {
                    if (n === c) throw n = v, r.arg;
                    r.dispatchException(r.arg);
                  } else "return" === r.method && r.abrupt("return", r.arg);
                  n = p;
                  var u = l(e, t, r);

                  if ("normal" === u.type) {
                    if (n = r.done ? v : h, u.arg === m) continue;
                    return {
                      value: u.arg,
                      done: r.done
                    };
                  }

                  "throw" === u.type && (n = v, r.method = "throw", r.arg = u.arg);
                }
              };
            }(e, r, o), a;
          }

          function l(e, t, r) {
            try {
              return {
                type: "normal",
                arg: e.call(t, r)
              };
            } catch (e) {
              return {
                type: "throw",
                arg: e
              };
            }
          }

          e.wrap = f;
          var c = "suspendedStart",
              h = "suspendedYield",
              p = "executing",
              v = "completed",
              m = {};

          function g() {}

          function y() {}

          function w() {}

          var b = {};
          u(b, a, function () {
            return this;
          });
          var k = Object.getPrototypeOf,
              x = k && k(k(O([])));
          x && x !== r && n.call(x, a) && (b = x);
          var A = w.prototype = g.prototype = Object.create(b);

          function P(e) {
            ["next", "throw", "return"].forEach(function (t) {
              u(e, t, function (e) {
                return this._invoke(t, e);
              });
            });
          }

          function _(e, t) {
            function r(i, a, o, s) {
              var u = l(e[i], e, a);

              if ("throw" !== u.type) {
                var f = u.arg,
                    c = f.value;
                return c && "object" === d(c) && n.call(c, "__await") ? t.resolve(c.__await).then(function (e) {
                  r("next", e, o, s);
                }, function (e) {
                  r("throw", e, o, s);
                }) : t.resolve(c).then(function (e) {
                  f.value = e, o(f);
                }, function (e) {
                  return r("throw", e, o, s);
                });
              }

              s(u.arg);
            }

            var i;

            this._invoke = function (e, n) {
              function a() {
                return new t(function (t, i) {
                  r(e, n, t, i);
                });
              }

              return i = i ? i.then(a, a) : a();
            };
          }

          function I(e, r) {
            var n = e.iterator[r.method];

            if (n === t) {
              if (r.delegate = null, "throw" === r.method) {
                if (e.iterator["return"] && (r.method = "return", r.arg = t, I(e, r), "throw" === r.method)) return m;
                r.method = "throw", r.arg = new TypeError("The iterator does not provide a 'throw' method");
              }

              return m;
            }

            var i = l(n, e.iterator, r.arg);
            if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, m;
            var a = i.arg;
            return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, m) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, m);
          }

          function S(e) {
            var t = {
              tryLoc: e[0]
            };
            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
          }

          function T(e) {
            var t = e.completion || {};
            t.type = "normal", delete t.arg, e.completion = t;
          }

          function U(e) {
            this.tryEntries = [{
              tryLoc: "root"
            }], e.forEach(S, this), this.reset(!0);
          }

          function O(e) {
            if (e) {
              var r = e[a];
              if (r) return r.call(e);
              if ("function" == typeof e.next) return e;

              if (!isNaN(e.length)) {
                var i = -1,
                    o = function r() {
                  for (; ++i < e.length;) {
                    if (n.call(e, i)) return r.value = e[i], r.done = !1, r;
                  }

                  return r.value = t, r.done = !0, r;
                };

                return o.next = o;
              }
            }

            return {
              next: D
            };
          }

          function D() {
            return {
              value: t,
              done: !0
            };
          }

          return y.prototype = w, u(A, "constructor", w), u(w, "constructor", y), y.displayName = u(w, s, "GeneratorFunction"), e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name));
          }, e.mark = function (e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, w) : (e.__proto__ = w, u(e, s, "GeneratorFunction")), e.prototype = Object.create(A), e;
          }, e.awrap = function (e) {
            return {
              __await: e
            };
          }, P(_.prototype), u(_.prototype, o, function () {
            return this;
          }), e.AsyncIterator = _, e.async = function (t, r, n, i, a) {
            void 0 === a && (a = Promise);
            var o = new _(f(t, r, n, i), a);
            return e.isGeneratorFunction(r) ? o : o.next().then(function (e) {
              return e.done ? e.value : o.next();
            });
          }, P(A), u(A, s, "Generator"), u(A, a, function () {
            return this;
          }), u(A, "toString", function () {
            return "[object Generator]";
          }), e.keys = function (e) {
            var t = [];

            for (var r in e) {
              t.push(r);
            }

            return t.reverse(), function r() {
              for (; t.length;) {
                var n = t.pop();
                if (n in e) return r.value = n, r.done = !1, r;
              }

              return r.done = !0, r;
            };
          }, e.values = O, U.prototype = {
            constructor: U,
            reset: function reset(e) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(T), !e) for (var r in this) {
                "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
              }
            },
            stop: function stop() {
              this.done = !0;
              var e = this.tryEntries[0].completion;
              if ("throw" === e.type) throw e.arg;
              return this.rval;
            },
            dispatchException: function dispatchException(e) {
              if (this.done) throw e;
              var r = this;

              function i(n, i) {
                return s.type = "throw", s.arg = e, r.next = n, i && (r.method = "next", r.arg = t), !!i;
              }

              for (var a = this.tryEntries.length - 1; a >= 0; --a) {
                var o = this.tryEntries[a],
                    s = o.completion;
                if ("root" === o.tryLoc) return i("end");

                if (o.tryLoc <= this.prev) {
                  var u = n.call(o, "catchLoc"),
                      f = n.call(o, "finallyLoc");

                  if (u && f) {
                    if (this.prev < o.catchLoc) return i(o.catchLoc, !0);
                    if (this.prev < o.finallyLoc) return i(o.finallyLoc);
                  } else if (u) {
                    if (this.prev < o.catchLoc) return i(o.catchLoc, !0);
                  } else {
                    if (!f) throw new Error("try statement without catch or finally");
                    if (this.prev < o.finallyLoc) return i(o.finallyLoc);
                  }
                }
              }
            },
            abrupt: function abrupt(e, t) {
              for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                var i = this.tryEntries[r];

                if (i.tryLoc <= this.prev && n.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                  var a = i;
                  break;
                }
              }

              a && ("break" === e || "continue" === e) && a.tryLoc <= t && t <= a.finallyLoc && (a = null);
              var o = a ? a.completion : {};
              return o.type = e, o.arg = t, a ? (this.method = "next", this.next = a.finallyLoc, m) : this.complete(o);
            },
            complete: function complete(e, t) {
              if ("throw" === e.type) throw e.arg;
              return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), m;
            },
            finish: function finish(e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];
                if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), T(r), m;
              }
            },
            "catch": function _catch(e) {
              for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                var r = this.tryEntries[t];

                if (r.tryLoc === e) {
                  var n = r.completion;

                  if ("throw" === n.type) {
                    var i = n.arg;
                    T(r);
                  }

                  return i;
                }
              }

              throw new Error("illegal catch attempt");
            },
            delegateYield: function delegateYield(e, r, n) {
              return this.delegate = {
                iterator: O(e),
                resultName: r,
                nextLoc: n
              }, "next" === this.method && (this.arg = t), m;
            }
          }, e;
        }(e.exports);

        try {
          regeneratorRuntime = t;
        } catch (e) {
          "object" === ("undefined" == typeof globalThis ? "undefined" : d(globalThis)) ? globalThis.regeneratorRuntime = t : Function("r", "regeneratorRuntime = r")(t);
        }
      }(k);

      for (var x = k.exports, A = new ArrayBuffer(4), P = new Float32Array(A), _ = new Uint32Array(A), I = new Uint32Array(512), S = new Uint32Array(512), T = 0; T < 256; ++T) {
        var U = T - 127;
        U < -27 ? (I[T] = 0, I[256 | T] = 32768, S[T] = 24, S[256 | T] = 24) : U < -14 ? (I[T] = 1024 >> -U - 14, I[256 | T] = 1024 >> -U - 14 | 32768, S[T] = -U - 1, S[256 | T] = -U - 1) : U <= 15 ? (I[T] = U + 15 << 10, I[256 | T] = U + 15 << 10 | 32768, S[T] = 13, S[256 | T] = 13) : U < 128 ? (I[T] = 31744, I[256 | T] = 64512, S[T] = 24, S[256 | T] = 24) : (I[T] = 31744, I[256 | T] = 64512, S[T] = 13, S[256 | T] = 13);
      }

      var O = new Uint32Array(2048),
          D = new Uint32Array(64),
          E = new Uint32Array(64);
      O[0] = 0;

      for (var R = 1; R < 1024; ++R) {
        for (var M = R << 13, B = 0; 0 == (8388608 & M);) {
          B -= 8388608, M <<= 1;
        }

        M &= -8388609, B += 947912704, O[R] = M | B;
      }

      for (var C = 1024; C < 2048; ++C) {
        O[C] = 939524096 + (C - 1024 << 13);
      }

      D[0] = 0;

      for (var L = 1; L < 31; ++L) {
        D[L] = L << 23;
      }

      D[31] = 1199570944, D[32] = 2147483648;

      for (var F = 33; F < 63; ++F) {
        D[F] = 2147483648 + (F - 32 << 23);
      }

      D[63] = 3347054592, E[0] = 0;

      for (var V = 1; V < 64; ++V) {
        E[V] = 32 === V ? 0 : 1024;
      }

      function G(e) {
        var t = e >> 10;
        return _[0] = O[E[t] + (1023 & e)] + D[t], P[0];
      }

      var j = Reflect.getPrototypeOf(Uint8Array).prototype,
          N = Reflect.getOwnPropertyDescriptor(j, Symbol.toStringTag).get;
      var z = Object.prototype.toString;

      function K(e) {
        return !!ArrayBuffer.isView(e) && !function (e) {
          return void 0 !== N.call(e);
        }(e) && "[object DataView]" === z.call(e);
      }

      function Z(e, t) {
        if (!K(e)) throw new TypeError("First argument to getFloat16 function must be a DataView");

        for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) {
          n[i - 2] = arguments[i];
        }

        return G(e.getUint16.apply(e, [t].concat(n)));
      }

      var H = function H(e, t, r) {
        var n = r && r.debug || !1;
        n && console.log("getting " + t + " in " + e);
        var i = "object" === d(e) ? e.outer : e,
            a = "".concat(t, '\\="([^"]*)"');
        n && console.log("pattern:", a);
        var o = new RegExp(a).exec(i);
        if (n && console.log("match:", o), o) return o[1];
      };

      var Y = function Y(e, t, r) {
        var n = new RegExp(t).exec(e.slice(r));
        return n ? r + n.index : -1;
      };

      var q = function q(e, t, r) {
        var n = r && r.debug || !1,
            i = r && r.startIndex || 0;
        n && console.log("starting findTagByName with", t, " and ", r);
        var a = Y(e, "<".concat(t, "[ >]"), i);

        if (n && console.log("start:", a), -1 !== a) {
          var o = e.slice(a + t.length),
              s = Y(o, "[ /]" + t + ">", 0),
              u = -1 === s;
          u && (s = Y(o, "[ /]>", 0));
          var f = a + t.length + s + 1 + (u ? 0 : t.length) + 1;

          if (n && console.log("end:", f), -1 !== f) {
            var l = e.slice(a, f);
            return {
              inner: u ? null : l.slice(l.indexOf(">") + 1, l.lastIndexOf("<")),
              outer: l,
              start: a,
              end: f
            };
          }
        }
      };

      var X = function X(e, t, r) {
        for (var n, i = [], a = r && r.debug || !1, o = r && r.startIndex || 0; n = q(e, t, {
          debug: a,
          startIndex: o
        });) {
          o = n.end, i.push(n);
        }

        return a && console.log("findTagsByName found", i.length, "tags"), i;
      },
          W = {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        340: "SMinSampleValue",
        341: "SMaxSampleValue",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop",
        33550: "ModelPixelScale",
        33922: "ModelTiepoint",
        34264: "ModelTransformation",
        34735: "GeoKeyDirectory",
        34736: "GeoDoubleParams",
        34737: "GeoAsciiParams",
        50674: "LercParameters"
      },
          J = {};

      for (var Q in W) {
        W.hasOwnProperty(Q) && (J[W[Q]] = parseInt(Q, 10));
      }

      var $ = {
        256: "SHORT",
        257: "SHORT",
        258: "SHORT",
        259: "SHORT",
        262: "SHORT",
        273: "LONG",
        274: "SHORT",
        277: "SHORT",
        278: "LONG",
        279: "LONG",
        282: "RATIONAL",
        283: "RATIONAL",
        284: "SHORT",
        286: "SHORT",
        287: "RATIONAL",
        296: "SHORT",
        297: "SHORT",
        305: "ASCII",
        306: "ASCII",
        338: "SHORT",
        339: "SHORT",
        513: "LONG",
        514: "LONG",
        1024: "SHORT",
        1025: "SHORT",
        2048: "SHORT",
        2049: "ASCII",
        3072: "SHORT",
        3073: "ASCII",
        33550: "DOUBLE",
        33922: "DOUBLE",
        34665: "LONG",
        34735: "SHORT",
        34737: "ASCII",
        42113: "ASCII"
      },
          ee = [J.BitsPerSample, J.ExtraSamples, J.SampleFormat, J.StripByteCounts, J.StripOffsets, J.StripRowCounts, J.TileByteCounts, J.TileOffsets, J.SubIFDs],
          te = {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE",
        13: "IFD",
        16: "LONG8",
        17: "SLONG8",
        18: "IFD8"
      },
          re = {};

      for (var ne in te) {
        te.hasOwnProperty(ne) && (re[te[ne]] = parseInt(ne, 10));
      }

      var ie = {
        WhiteIsZero: 0,
        BlackIsZero: 1,
        RGB: 2,
        Palette: 3,
        TransparencyMask: 4,
        CMYK: 5,
        YCbCr: 6,
        CIELab: 8,
        ICCLab: 9
      },
          ae = {
        Unspecified: 0,
        Assocalpha: 1,
        Unassalpha: 2
      },
          oe = {
        Version: 0,
        AddCompression: 1
      },
          se = {
        None: 0,
        Deflate: 1
      },
          ue = {
        1024: "GTModelTypeGeoKey",
        1025: "GTRasterTypeGeoKey",
        1026: "GTCitationGeoKey",
        2048: "GeographicTypeGeoKey",
        2049: "GeogCitationGeoKey",
        2050: "GeogGeodeticDatumGeoKey",
        2051: "GeogPrimeMeridianGeoKey",
        2052: "GeogLinearUnitsGeoKey",
        2053: "GeogLinearUnitSizeGeoKey",
        2054: "GeogAngularUnitsGeoKey",
        2055: "GeogAngularUnitSizeGeoKey",
        2056: "GeogEllipsoidGeoKey",
        2057: "GeogSemiMajorAxisGeoKey",
        2058: "GeogSemiMinorAxisGeoKey",
        2059: "GeogInvFlatteningGeoKey",
        2060: "GeogAzimuthUnitsGeoKey",
        2061: "GeogPrimeMeridianLongGeoKey",
        2062: "GeogTOWGS84GeoKey",
        3072: "ProjectedCSTypeGeoKey",
        3073: "PCSCitationGeoKey",
        3074: "ProjectionGeoKey",
        3075: "ProjCoordTransGeoKey",
        3076: "ProjLinearUnitsGeoKey",
        3077: "ProjLinearUnitSizeGeoKey",
        3078: "ProjStdParallel1GeoKey",
        3079: "ProjStdParallel2GeoKey",
        3080: "ProjNatOriginLongGeoKey",
        3081: "ProjNatOriginLatGeoKey",
        3082: "ProjFalseEastingGeoKey",
        3083: "ProjFalseNorthingGeoKey",
        3084: "ProjFalseOriginLongGeoKey",
        3085: "ProjFalseOriginLatGeoKey",
        3086: "ProjFalseOriginEastingGeoKey",
        3087: "ProjFalseOriginNorthingGeoKey",
        3088: "ProjCenterLongGeoKey",
        3089: "ProjCenterLatGeoKey",
        3090: "ProjCenterEastingGeoKey",
        3091: "ProjCenterNorthingGeoKey",
        3092: "ProjScaleAtNatOriginGeoKey",
        3093: "ProjScaleAtCenterGeoKey",
        3094: "ProjAzimuthAngleGeoKey",
        3095: "ProjStraightVertPoleLongGeoKey",
        3096: "ProjRectifiedGridAngleGeoKey",
        4096: "VerticalCSTypeGeoKey",
        4097: "VerticalCitationGeoKey",
        4098: "VerticalDatumGeoKey",
        4099: "VerticalUnitsGeoKey"
      },
          fe = {};

      for (var le in ue) {
        ue.hasOwnProperty(le) && (fe[ue[le]] = parseInt(le, 10));
      }

      var ce = Object.freeze({
        __proto__: null,
        fieldTagNames: W,
        fieldTags: J,
        fieldTagTypes: $,
        arrayFields: ee,
        fieldTypeNames: te,
        fieldTypes: re,
        photometricInterpretations: ie,
        ExtraSamplesValues: ae,
        LercParameters: oe,
        LercAddCompression: se,
        geoKeyNames: ue,
        geoKeys: fe
      });

      function he(e, t) {
        for (var r, n = e.width, i = e.height, a = new Uint8Array(n * i * 3), o = 0, s = 0; o < e.length; ++o, s += 3) {
          r = 256 - e[o] / t * 256, a[s] = r, a[s + 1] = r, a[s + 2] = r;
        }

        return a;
      }

      function de(e, t) {
        for (var r, n = e.width, i = e.height, a = new Uint8Array(n * i * 3), o = 0, s = 0; o < e.length; ++o, s += 3) {
          r = e[o] / t * 256, a[s] = r, a[s + 1] = r, a[s + 2] = r;
        }

        return a;
      }

      function pe(e, t) {
        for (var r = e.width, n = e.height, i = new Uint8Array(r * n * 3), a = t.length / 3, o = t.length / 3 * 2, s = 0, u = 0; s < e.length; ++s, u += 3) {
          var f = e[s];
          i[u] = t[f] / 65536 * 256, i[u + 1] = t[f + a] / 65536 * 256, i[u + 2] = t[f + o] / 65536 * 256;
        }

        return i;
      }

      function ve(e) {
        for (var t = e.width, r = e.height, n = new Uint8Array(t * r * 3), i = 0, a = 0; i < e.length; i += 4, a += 3) {
          var o = e[i],
              s = e[i + 1],
              u = e[i + 2],
              f = e[i + 3];
          n[a] = (255 - o) / 256 * 255 * ((255 - f) / 256), n[a + 1] = (255 - s) / 256 * 255 * ((255 - f) / 256), n[a + 2] = (255 - u) / 256 * 255 * ((255 - f) / 256);
        }

        return n;
      }

      function me(e) {
        for (var t = e.width, r = e.height, n = new Uint8ClampedArray(t * r * 3), i = 0, a = 0; i < e.length; i += 3, a += 3) {
          var o = e[i],
              s = e[i + 1],
              u = e[i + 2];
          n[a] = o + 1.402 * (u - 128), n[a + 1] = o - .34414 * (s - 128) - .71414 * (u - 128), n[a + 2] = o + 1.772 * (s - 128);
        }

        return n;
      }

      function ge(e) {
        for (var t = e.width, r = e.height, n = new Uint8Array(t * r * 3), i = 0, a = 0; i < e.length; i += 3, a += 3) {
          var o = (e[i + 0] + 16) / 116,
              s = (e[i + 1] << 24 >> 24) / 500 + o,
              u = o - (e[i + 2] << 24 >> 24) / 200,
              f = void 0,
              l = void 0,
              c = void 0;
          l = -.9689 * (s = .95047 * (s * s * s > .008856 ? s * s * s : (s - 16 / 116) / 7.787)) + 1.8758 * (o = 1 * (o * o * o > .008856 ? o * o * o : (o - 16 / 116) / 7.787)) + .0415 * (u = 1.08883 * (u * u * u > .008856 ? u * u * u : (u - 16 / 116) / 7.787)), c = .0557 * s + -.204 * o + 1.057 * u, f = (f = 3.2406 * s + -1.5372 * o + -.4986 * u) > .0031308 ? 1.055 * Math.pow(f, 1 / 2.4) - .055 : 12.92 * f, l = l > .0031308 ? 1.055 * Math.pow(l, 1 / 2.4) - .055 : 12.92 * l, c = c > .0031308 ? 1.055 * Math.pow(c, 1 / 2.4) - .055 : 12.92 * c, n[a] = 255 * Math.max(0, Math.min(1, f)), n[a + 1] = 255 * Math.max(0, Math.min(1, l)), n[a + 2] = 255 * Math.max(0, Math.min(1, c));
        }

        return n;
      }

      var ye = Object.freeze({
        __proto__: null,
        fromWhiteIsZero: he,
        fromBlackIsZero: de,
        fromPalette: pe,
        fromCMYK: ve,
        fromYCbCr: me,
        fromCIELab: ge
      }),
          we = new Map();

      function be(e, t) {
        Array.isArray(e) || (e = [e]), e.forEach(function (e) {
          return we.set(e, t);
        });
      }

      function ke(e) {
        return xe.apply(this, arguments);
      }

      function xe() {
        return (xe = u(x.mark(function e(t) {
          var r, n;
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  if (r = we.get(t.Compression)) {
                    e.next = 3;
                    break;
                  }

                  throw new Error("Unknown compression method identifier: ".concat(t.Compression));

                case 3:
                  return e.next = 5, r();

                case 5:
                  return n = e.sent, e.abrupt("return", new n(t));

                case 7:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))).apply(this, arguments);
      }

      function Ae(e, t, r) {
        var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
        return new (Object.getPrototypeOf(e).constructor)(t * r * n);
      }

      function Pe(e, t, r, n, i) {
        var a = t / n,
            o = r / i;
        return e.map(function (e) {
          for (var s = Ae(e, n, i), u = 0; u < i; ++u) {
            for (var f = Math.min(Math.round(o * u), r - 1), l = 0; l < n; ++l) {
              var c = Math.min(Math.round(a * l), t - 1),
                  h = e[f * t + c];
              s[u * n + l] = h;
            }
          }

          return s;
        });
      }

      function _e(e, t, r) {
        return (1 - r) * e + r * t;
      }

      function Ie(e, t, r, n, i) {
        var a = t / n,
            o = r / i;
        return e.map(function (e) {
          for (var s = Ae(e, n, i), u = 0; u < i; ++u) {
            for (var f = o * u, l = Math.floor(f), c = Math.min(Math.ceil(f), r - 1), h = 0; h < n; ++h) {
              var d = a * h,
                  p = d % 1,
                  v = Math.floor(d),
                  m = Math.min(Math.ceil(d), t - 1),
                  g = e[l * t + v],
                  y = e[l * t + m],
                  w = e[c * t + v],
                  b = e[c * t + m],
                  k = _e(_e(g, y, p), _e(w, b, p), f % 1);

              s[u * n + h] = k;
            }
          }

          return s;
        });
      }

      function Se(e, t, r, n, i) {
        var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "nearest";

        switch (a.toLowerCase()) {
          case "nearest":
            return Pe(e, t, r, n, i);

          case "bilinear":
          case "linear":
            return Ie(e, t, r, n, i);

          default:
            throw new Error("Unsupported resampling method: '".concat(a, "'"));
        }
      }

      function Te(e, t, r, n, i, a) {
        for (var o = t / n, s = r / i, u = Ae(e, n, i, a), f = 0; f < i; ++f) {
          for (var l = Math.min(Math.round(s * f), r - 1), c = 0; c < n; ++c) {
            for (var h = Math.min(Math.round(o * c), t - 1), d = 0; d < a; ++d) {
              var p = e[l * t * a + h * a + d];
              u[f * n * a + c * a + d] = p;
            }
          }
        }

        return u;
      }

      function Ue(e, t, r, n, i, a) {
        for (var o = t / n, s = r / i, u = Ae(e, n, i, a), f = 0; f < i; ++f) {
          for (var l = s * f, c = Math.floor(l), h = Math.min(Math.ceil(l), r - 1), d = 0; d < n; ++d) {
            for (var p = o * d, v = p % 1, m = Math.floor(p), g = Math.min(Math.ceil(p), t - 1), y = 0; y < a; ++y) {
              var w = e[c * t * a + m * a + y],
                  b = e[c * t * a + g * a + y],
                  k = e[h * t * a + m * a + y],
                  x = e[h * t * a + g * a + y],
                  A = _e(_e(w, b, v), _e(k, x, v), l % 1);

              u[f * n * a + d * a + y] = A;
            }
          }
        }

        return u;
      }

      function Oe(e, t, r, n, i, a) {
        var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : "nearest";

        switch (o.toLowerCase()) {
          case "nearest":
            return Te(e, t, r, n, i, a);

          case "bilinear":
          case "linear":
            return Ue(e, t, r, n, i, a);

          default:
            throw new Error("Unsupported resampling method: '".concat(o, "'"));
        }
      }

      function De(e, t, r) {
        for (var n = 0, i = t; i < r; ++i) {
          n += e[i];
        }

        return n;
      }

      function Ee(e, t, r) {
        switch (e) {
          case 1:
            if (t <= 8) return new Uint8Array(r);
            if (t <= 16) return new Uint16Array(r);
            if (t <= 32) return new Uint32Array(r);
            break;

          case 2:
            if (8 === t) return new Int8Array(r);
            if (16 === t) return new Int16Array(r);
            if (32 === t) return new Int32Array(r);
            break;

          case 3:
            switch (t) {
              case 16:
              case 32:
                return new Float32Array(r);

              case 64:
                return new Float64Array(r);
            }

        }

        throw Error("Unsupported data format/bitsPerSample");
      }

      function Re(e, t) {
        return (1 !== e && 2 !== e || !(t <= 32) || t % 8 != 0) && (3 !== e || 16 !== t && 32 !== t && 64 !== t);
      }

      function Me(e, t, r, n, i, a, o) {
        var s = new DataView(e),
            u = 2 === r ? 1 : n,
            f = Ee(t, i, 2 === r ? o * a : o * a * n),
            l = parseInt("1".repeat(i), 2);

        if (1 === t) {
          var c = a * (1 === r ? n * i : i);
          0 != (7 & c) && (c = c + 7 & -8);

          for (var h = 0; h < o; ++h) {
            for (var d = h * c, p = 0; p < a; ++p) {
              for (var v = d + p * u * i, m = 0; m < u; ++m) {
                var g = v + m * i,
                    y = (h * a + p) * u + m,
                    w = Math.floor(g / 8),
                    b = g % 8;
                if (b + i <= 8) f[y] = s.getUint8(w) >> 8 - i - b & l;else if (b + i <= 16) f[y] = s.getUint16(w) >> 16 - i - b & l;else if (b + i <= 24) {
                  var k = s.getUint16(w) << 8 | s.getUint8(w + 2);
                  f[y] = k >> 24 - i - b & l;
                } else f[y] = s.getUint32(w) >> 32 - i - b & l;
              }
            }
          }
        }

        return f.buffer;
      }

      be([void 0, 1], function () {
        return Promise.resolve().then(function () {
          return an;
        }).then(function (e) {
          return e["default"];
        });
      }), be(5, function () {
        return Promise.resolve().then(function () {
          return ln;
        }).then(function (e) {
          return e["default"];
        });
      }), be(6, function () {
        throw new Error("old style JPEG compression is not supported.");
      }), be(7, function () {
        return Promise.resolve().then(function () {
          return In;
        }).then(function (e) {
          return e["default"];
        });
      }), be([8, 32946], function () {
        return Promise.resolve().then(function () {
          return Ci;
        }).then(function (e) {
          return e["default"];
        });
      }), be(32773, function () {
        return Promise.resolve().then(function () {
          return Vi;
        }).then(function (e) {
          return e["default"];
        });
      }), be(34887, function () {
        return Promise.resolve().then(function () {
          return Ki;
        }).then(function (e) {
          return e["default"];
        });
      }), be(50001, function () {
        return Promise.resolve().then(function () {
          return Yi;
        }).then(function (e) {
          return e["default"];
        });
      });

      var Be = function () {
        function e(t, r, n, i, a, o) {
          b(this, e), this.fileDirectory = t, this.geoKeys = r, this.dataView = n, this.littleEndian = i, this.tiles = a ? {} : null, this.isTiled = !t.StripOffsets;
          var s = t.PlanarConfiguration;
          if (this.planarConfiguration = void 0 === s ? 1 : s, 1 !== this.planarConfiguration && 2 !== this.planarConfiguration) throw new Error("Invalid planar configuration.");
          this.source = o;
        }

        var t, r, n, i;
        return l(e, [{
          key: "getFileDirectory",
          value: function value() {
            return this.fileDirectory;
          }
        }, {
          key: "getGeoKeys",
          value: function value() {
            return this.geoKeys;
          }
        }, {
          key: "getWidth",
          value: function value() {
            return this.fileDirectory.ImageWidth;
          }
        }, {
          key: "getHeight",
          value: function value() {
            return this.fileDirectory.ImageLength;
          }
        }, {
          key: "getSamplesPerPixel",
          value: function value() {
            return void 0 !== this.fileDirectory.SamplesPerPixel ? this.fileDirectory.SamplesPerPixel : 1;
          }
        }, {
          key: "getTileWidth",
          value: function value() {
            return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
          }
        }, {
          key: "getTileHeight",
          value: function value() {
            return this.isTiled ? this.fileDirectory.TileLength : void 0 !== this.fileDirectory.RowsPerStrip ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight();
          }
        }, {
          key: "getBlockWidth",
          value: function value() {
            return this.getTileWidth();
          }
        }, {
          key: "getBlockHeight",
          value: function value(e) {
            return this.isTiled || (e + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - e * this.getTileHeight();
          }
        }, {
          key: "getBytesPerPixel",
          value: function value() {
            for (var e = 0, t = 0; t < this.fileDirectory.BitsPerSample.length; ++t) {
              e += this.getSampleByteSize(t);
            }

            return e;
          }
        }, {
          key: "getSampleByteSize",
          value: function value(e) {
            if (e >= this.fileDirectory.BitsPerSample.length) throw new RangeError("Sample index ".concat(e, " is out of range."));
            return Math.ceil(this.fileDirectory.BitsPerSample[e] / 8);
          }
        }, {
          key: "getReaderForSample",
          value: function value(e) {
            var t = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e] : 1,
                r = this.fileDirectory.BitsPerSample[e];

            switch (t) {
              case 1:
                if (r <= 8) return DataView.prototype.getUint8;
                if (r <= 16) return DataView.prototype.getUint16;
                if (r <= 32) return DataView.prototype.getUint32;
                break;

              case 2:
                if (r <= 8) return DataView.prototype.getInt8;
                if (r <= 16) return DataView.prototype.getInt16;
                if (r <= 32) return DataView.prototype.getInt32;
                break;

              case 3:
                switch (r) {
                  case 16:
                    return function (e, t) {
                      return Z(this, e, t);
                    };

                  case 32:
                    return DataView.prototype.getFloat32;

                  case 64:
                    return DataView.prototype.getFloat64;
                }

            }

            throw Error("Unsupported data format/bitsPerSample");
          }
        }, {
          key: "getSampleFormat",
          value: function value() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[e] : 1;
          }
        }, {
          key: "getBitsPerSample",
          value: function value() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            return this.fileDirectory.BitsPerSample[e];
          }
        }, {
          key: "getArrayForSample",
          value: function value(e, t) {
            return Ee(this.getSampleFormat(e), this.getBitsPerSample(e), t);
          }
        }, {
          key: "getTileOrStrip",
          value: (i = u(x.mark(function e(t, r, n, i, a) {
            var o,
                s,
                f,
                l,
                c,
                h,
                d,
                p,
                v = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return o = Math.ceil(this.getWidth() / this.getTileWidth()), s = Math.ceil(this.getHeight() / this.getTileHeight()), l = this.tiles, 1 === this.planarConfiguration ? f = r * o + t : 2 === this.planarConfiguration && (f = n * o * s + r * o + t), this.isTiled ? (c = this.fileDirectory.TileOffsets[f], h = this.fileDirectory.TileByteCounts[f]) : (c = this.fileDirectory.StripOffsets[f], h = this.fileDirectory.StripByteCounts[f]), e.next = 7, this.source.fetch([{
                      offset: c,
                      length: h
                    }], a);

                  case 7:
                    return d = e.sent[0], null !== l && l[f] ? p = l[f] : (p = u(x.mark(function e() {
                      var t, n, a;
                      return x.wrap(function (e) {
                        for (;;) {
                          switch (e.prev = e.next) {
                            case 0:
                              return e.next = 2, i.decode(v.fileDirectory, d);

                            case 2:
                              return t = e.sent, n = v.getSampleFormat(), a = v.getBitsPerSample(), Re(n, a) && (t = Me(t, n, v.planarConfiguration, v.getSamplesPerPixel(), a, v.getTileWidth(), v.getBlockHeight(r))), e.abrupt("return", t);

                            case 7:
                            case "end":
                              return e.stop();
                          }
                        }
                      }, e);
                    }))(), null !== l && (l[f] = p)), e.t0 = t, e.t1 = r, e.t2 = n, e.next = 14, p;

                  case 14:
                    return e.t3 = e.sent, e.abrupt("return", {
                      x: e.t0,
                      y: e.t1,
                      sample: e.t2,
                      data: e.t3
                    });

                  case 16:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, t, r, n, a) {
            return i.apply(this, arguments);
          })
        }, {
          key: "_readRaster",
          value: (n = u(x.mark(function e(t, r, n, i, a, o, s, u, f) {
            var l,
                c,
                h,
                d,
                p,
                v,
                m,
                g,
                y,
                w,
                b,
                k,
                A,
                P,
                _,
                I,
                S,
                T,
                U,
                O,
                D = this;

            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    for (l = this.getTileWidth(), c = this.getTileHeight(), h = this.getWidth(), d = this.getHeight(), p = Math.max(Math.floor(t[0] / l), 0), v = Math.min(Math.ceil(t[2] / l), Math.ceil(h / l)), m = Math.max(Math.floor(t[1] / c), 0), g = Math.min(Math.ceil(t[3] / c), Math.ceil(d / c)), y = t[2] - t[0], w = this.getBytesPerPixel(), b = [], k = [], A = 0; A < r.length; ++A) {
                      1 === this.planarConfiguration ? b.push(De(this.fileDirectory.BitsPerSample, 0, r[A]) / 8) : b.push(0), k.push(this.getReaderForSample(r[A]));
                    }

                    for (P = [], _ = this.littleEndian, I = m; I < g; ++I) {
                      for (S = p; S < v; ++S) {
                        for (T = function T(e) {
                          var o = e,
                              s = r[e];
                          2 === D.planarConfiguration && (w = D.getSampleByteSize(e));
                          var u = D.getTileOrStrip(S, I, s, a, f);
                          P.push(u), u.then(function (e) {
                            for (var a = e.data, s = new DataView(a), u = D.getBlockHeight(e.y), f = e.y * c, p = e.x * l, v = f + u, m = (e.x + 1) * l, g = k[o], x = Math.min(u, u - (v - t[3]), d - f), A = Math.min(l, l - (m - t[2]), h - p), P = Math.max(0, t[1] - f); P < x; ++P) {
                              for (var I = Math.max(0, t[0] - p); I < A; ++I) {
                                var S = (P * l + I) * w,
                                    T = g.call(s, S + b[o], _),
                                    U = void 0;
                                i ? (U = (P + f - t[1]) * y * r.length + (I + p - t[0]) * r.length + o, n[U] = T) : (U = (P + f - t[1]) * y + I + p - t[0], n[o][U] = T);
                              }
                            }
                          });
                        }, U = 0; U < r.length; ++U) {
                          T(U);
                        }
                      }
                    }

                    return e.next = 18, Promise.all(P);

                  case 18:
                    if (!(o && t[2] - t[0] !== o || s && t[3] - t[1] !== s)) {
                      e.next = 23;
                      break;
                    }

                    return (O = i ? Oe(n, t[2] - t[0], t[3] - t[1], o, s, r.length, u) : Se(n, t[2] - t[0], t[3] - t[1], o, s, u)).width = o, O.height = s, e.abrupt("return", O);

                  case 23:
                    return n.width = o || t[2] - t[0], n.height = s || t[3] - t[1], e.abrupt("return", n);

                  case 26:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, t, r, i, a, o, s, u, f) {
            return n.apply(this, arguments);
          })
        }, {
          key: "readRasters",
          value: (r = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                o,
                s,
                u,
                f,
                l,
                c,
                h,
                d,
                p,
                v,
                m,
                g,
                y,
                w,
                b,
                k,
                A,
                P,
                _,
                I,
                S,
                T = arguments;

            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (t = T.length > 0 && void 0 !== T[0] ? T[0] : {}, r = t.window, n = t.samples, i = void 0 === n ? [] : n, a = t.interleave, o = t.pool, s = void 0 === o ? null : o, u = t.width, f = t.height, l = t.resampleMethod, c = t.fillValue, h = t.signal, !((d = r || [0, 0, this.getWidth(), this.getHeight()])[0] > d[2] || d[1] > d[3])) {
                      e.next = 4;
                      break;
                    }

                    throw new Error("Invalid subsets");

                  case 4:
                    if (p = d[2] - d[0], v = d[3] - d[1], m = p * v, g = this.getSamplesPerPixel(), i && i.length) {
                      e.next = 12;
                      break;
                    }

                    for (y = 0; y < g; ++y) {
                      i.push(y);
                    }

                    e.next = 19;
                    break;

                  case 12:
                    w = 0;

                  case 13:
                    if (!(w < i.length)) {
                      e.next = 19;
                      break;
                    }

                    if (!(i[w] >= g)) {
                      e.next = 16;
                      break;
                    }

                    return e.abrupt("return", Promise.reject(new RangeError("Invalid sample index '".concat(i[w], "'."))));

                  case 16:
                    ++w, e.next = 13;
                    break;

                  case 19:
                    if (a) k = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1, A = Math.max.apply(null, this.fileDirectory.BitsPerSample), b = Ee(k, A, m * i.length), c && b.fill(c);else for (b = [], P = 0; P < i.length; ++P) {
                      _ = this.getArrayForSample(i[P], m), Array.isArray(c) && P < c.length ? _.fill(c[P]) : c && !Array.isArray(c) && _.fill(c), b.push(_);
                    }

                    if (e.t0 = s, e.t0) {
                      e.next = 25;
                      break;
                    }

                    return e.next = 24, ke(this.fileDirectory);

                  case 24:
                    e.t0 = e.sent;

                  case 25:
                    return I = e.t0, e.next = 28, this._readRaster(d, i, b, a, I, u, f, l, h);

                  case 28:
                    return S = e.sent, e.abrupt("return", S);

                  case 30:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return r.apply(this, arguments);
          })
        }, {
          key: "readRGB",
          value: (t = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                o,
                s,
                u,
                f,
                l,
                c,
                h,
                d,
                p,
                v,
                m,
                g,
                y,
                w,
                b,
                k,
                A,
                P,
                _,
                I,
                S,
                T,
                U = arguments;

            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (t = U.length > 0 && void 0 !== U[0] ? U[0] : {}, r = t.window, n = t.interleave, i = void 0 === n || n, a = t.pool, o = void 0 === a ? null : a, s = t.width, u = t.height, f = t.resampleMethod, l = t.enableAlpha, c = void 0 !== l && l, h = t.signal, !((d = r || [0, 0, this.getWidth(), this.getHeight()])[0] > d[2] || d[1] > d[3])) {
                      e.next = 4;
                      break;
                    }

                    throw new Error("Invalid subsets");

                  case 4:
                    if ((p = this.fileDirectory.PhotometricInterpretation) !== ie.RGB) {
                      e.next = 9;
                      break;
                    }

                    if (v = [0, 1, 2], this.fileDirectory.ExtraSamples !== ae.Unspecified && c) for (v = [], m = 0; m < this.fileDirectory.BitsPerSample.length; m += 1) {
                      v.push(m);
                    }
                    return e.abrupt("return", this.readRasters({
                      window: r,
                      interleave: i,
                      samples: v,
                      pool: o,
                      width: s,
                      height: u,
                      resampleMethod: f,
                      signal: h
                    }));

                  case 9:
                    e.t0 = p, e.next = e.t0 === ie.WhiteIsZero || e.t0 === ie.BlackIsZero || e.t0 === ie.Palette ? 12 : e.t0 === ie.CMYK ? 14 : e.t0 === ie.YCbCr || e.t0 === ie.CIELab ? 16 : 18;
                    break;

                  case 12:
                    return g = [0], e.abrupt("break", 19);

                  case 14:
                    return g = [0, 1, 2, 3], e.abrupt("break", 19);

                  case 16:
                    return g = [0, 1, 2], e.abrupt("break", 19);

                  case 18:
                    throw new Error("Invalid or unsupported photometric interpretation.");

                  case 19:
                    return y = {
                      window: d,
                      interleave: !0,
                      samples: g,
                      pool: o,
                      width: s,
                      height: u,
                      resampleMethod: f,
                      signal: h
                    }, w = this.fileDirectory, e.next = 23, this.readRasters(y);

                  case 23:
                    b = e.sent, k = Math.pow(2, this.fileDirectory.BitsPerSample[0]), e.t1 = p, e.next = e.t1 === ie.WhiteIsZero ? 28 : e.t1 === ie.BlackIsZero ? 30 : e.t1 === ie.Palette ? 32 : e.t1 === ie.CMYK ? 34 : e.t1 === ie.YCbCr ? 36 : e.t1 === ie.CIELab ? 38 : 40;
                    break;

                  case 28:
                    return A = he(b, k), e.abrupt("break", 41);

                  case 30:
                    return A = de(b, k), e.abrupt("break", 41);

                  case 32:
                    return A = pe(b, w.ColorMap), e.abrupt("break", 41);

                  case 34:
                    return A = ve(b), e.abrupt("break", 41);

                  case 36:
                    return A = me(b), e.abrupt("break", 41);

                  case 38:
                    return A = ge(b), e.abrupt("break", 41);

                  case 40:
                    throw new Error("Unsupported photometric interpretation.");

                  case 41:
                    if (!i) {
                      for (P = new Uint8Array(A.length / 3), _ = new Uint8Array(A.length / 3), I = new Uint8Array(A.length / 3), S = 0, T = 0; S < A.length; S += 3, ++T) {
                        P[T] = A[S], _[T] = A[S + 1], I[T] = A[S + 2];
                      }

                      A = [P, _, I];
                    }

                    return A.width = b.width, A.height = b.height, e.abrupt("return", A);

                  case 45:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }, {
          key: "getTiePoints",
          value: function value() {
            if (!this.fileDirectory.ModelTiepoint) return [];

            for (var e = [], t = 0; t < this.fileDirectory.ModelTiepoint.length; t += 6) {
              e.push({
                i: this.fileDirectory.ModelTiepoint[t],
                j: this.fileDirectory.ModelTiepoint[t + 1],
                k: this.fileDirectory.ModelTiepoint[t + 2],
                x: this.fileDirectory.ModelTiepoint[t + 3],
                y: this.fileDirectory.ModelTiepoint[t + 4],
                z: this.fileDirectory.ModelTiepoint[t + 5]
              });
            }

            return e;
          }
        }, {
          key: "getGDALMetadata",
          value: function value() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                t = {};
            if (!this.fileDirectory.GDAL_METADATA) return null;
            var r = this.fileDirectory.GDAL_METADATA,
                n = X(r, "Item");
            n = null === e ? n.filter(function (e) {
              return void 0 === H(e, "sample");
            }) : n.filter(function (t) {
              return Number(H(t, "sample")) === e;
            });

            for (var i = 0; i < n.length; ++i) {
              var a = n[i];
              t[H(a, "name")] = a.inner;
            }

            return t;
          }
        }, {
          key: "getGDALNoData",
          value: function value() {
            if (!this.fileDirectory.GDAL_NODATA) return null;
            var e = this.fileDirectory.GDAL_NODATA;
            return Number(e.substring(0, e.length - 1));
          }
        }, {
          key: "getOrigin",
          value: function value() {
            var e = this.fileDirectory.ModelTiepoint,
                t = this.fileDirectory.ModelTransformation;
            if (e && 6 === e.length) return [e[3], e[4], e[5]];
            if (t) return [t[3], t[7], t[11]];
            throw new Error("The image does not have an affine transformation.");
          }
        }, {
          key: "getResolution",
          value: function value() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                t = this.fileDirectory.ModelPixelScale,
                r = this.fileDirectory.ModelTransformation;
            if (t) return [t[0], -t[1], t[2]];
            if (r) return [r[0], r[5], r[10]];

            if (e) {
              var n = e.getResolution(),
                  i = o(n, 3),
                  a = i[0],
                  s = i[1],
                  u = i[2];
              return [a * e.getWidth() / this.getWidth(), s * e.getHeight() / this.getHeight(), u * e.getWidth() / this.getWidth()];
            }

            throw new Error("The image does not have an affine transformation.");
          }
        }, {
          key: "pixelIsArea",
          value: function value() {
            return 1 === this.geoKeys.GTRasterTypeGeoKey;
          }
        }, {
          key: "getBoundingBox",
          value: function value() {
            var e = this.getOrigin(),
                t = this.getResolution(),
                r = e[0],
                n = e[1],
                i = r + t[0] * this.getWidth(),
                a = n + t[1] * this.getHeight();
            return [Math.min(r, i), Math.min(n, a), Math.max(r, i), Math.max(n, a)];
          }
        }]), e;
      }(),
          Ce = Be,
          Le = function () {
        function e(t) {
          b(this, e), this._dataView = new DataView(t);
        }

        return l(e, [{
          key: "buffer",
          get: function get() {
            return this._dataView.buffer;
          }
        }, {
          key: "getUint64",
          value: function value(e, t) {
            var r,
                n = this.getUint32(e, t),
                i = this.getUint32(e + 4, t);

            if (t) {
              if (r = n + Math.pow(2, 32) * i, !Number.isSafeInteger(r)) throw new Error("".concat(r, " exceeds MAX_SAFE_INTEGER. ") + "Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues");
              return r;
            }

            if (r = Math.pow(2, 32) * n + i, !Number.isSafeInteger(r)) throw new Error("".concat(r, " exceeds MAX_SAFE_INTEGER. ") + "Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues");
            return r;
          }
        }, {
          key: "getInt64",
          value: function value(e, t) {
            for (var r = 0, n = (128 & this._dataView.getUint8(e + (t ? 7 : 0))) > 0, i = !0, a = 0; a < 8; a++) {
              var o = this._dataView.getUint8(e + (t ? a : 7 - a));

              n && (i ? 0 !== o && (o = 255 & ~(o - 1), i = !1) : o = 255 & ~o), r += o * Math.pow(256, a);
            }

            return n && (r = -r), r;
          }
        }, {
          key: "getUint8",
          value: function value(e, t) {
            return this._dataView.getUint8(e, t);
          }
        }, {
          key: "getInt8",
          value: function value(e, t) {
            return this._dataView.getInt8(e, t);
          }
        }, {
          key: "getUint16",
          value: function value(e, t) {
            return this._dataView.getUint16(e, t);
          }
        }, {
          key: "getInt16",
          value: function value(e, t) {
            return this._dataView.getInt16(e, t);
          }
        }, {
          key: "getUint32",
          value: function value(e, t) {
            return this._dataView.getUint32(e, t);
          }
        }, {
          key: "getInt32",
          value: function value(e, t) {
            return this._dataView.getInt32(e, t);
          }
        }, {
          key: "getFloat16",
          value: function value(e, t) {
            return Z(this._dataView, e, t);
          }
        }, {
          key: "getFloat32",
          value: function value(e, t) {
            return this._dataView.getFloat32(e, t);
          }
        }, {
          key: "getFloat64",
          value: function value(e, t) {
            return this._dataView.getFloat64(e, t);
          }
        }]), e;
      }(),
          Fe = function () {
        function e(t, r, n, i) {
          b(this, e), this._dataView = new DataView(t), this._sliceOffset = r, this._littleEndian = n, this._bigTiff = i;
        }

        return l(e, [{
          key: "sliceOffset",
          get: function get() {
            return this._sliceOffset;
          }
        }, {
          key: "sliceTop",
          get: function get() {
            return this._sliceOffset + this.buffer.byteLength;
          }
        }, {
          key: "littleEndian",
          get: function get() {
            return this._littleEndian;
          }
        }, {
          key: "bigTiff",
          get: function get() {
            return this._bigTiff;
          }
        }, {
          key: "buffer",
          get: function get() {
            return this._dataView.buffer;
          }
        }, {
          key: "covers",
          value: function value(e, t) {
            return this.sliceOffset <= e && this.sliceTop >= e + t;
          }
        }, {
          key: "readUint8",
          value: function value(e) {
            return this._dataView.getUint8(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readInt8",
          value: function value(e) {
            return this._dataView.getInt8(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readUint16",
          value: function value(e) {
            return this._dataView.getUint16(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readInt16",
          value: function value(e) {
            return this._dataView.getInt16(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readUint32",
          value: function value(e) {
            return this._dataView.getUint32(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readInt32",
          value: function value(e) {
            return this._dataView.getInt32(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readFloat32",
          value: function value(e) {
            return this._dataView.getFloat32(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readFloat64",
          value: function value(e) {
            return this._dataView.getFloat64(e - this._sliceOffset, this._littleEndian);
          }
        }, {
          key: "readUint64",
          value: function value(e) {
            var t,
                r = this.readUint32(e),
                n = this.readUint32(e + 4);

            if (this._littleEndian) {
              if (t = r + Math.pow(2, 32) * n, !Number.isSafeInteger(t)) throw new Error("".concat(t, " exceeds MAX_SAFE_INTEGER. ") + "Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues");
              return t;
            }

            if (t = Math.pow(2, 32) * r + n, !Number.isSafeInteger(t)) throw new Error("".concat(t, " exceeds MAX_SAFE_INTEGER. ") + "Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues");
            return t;
          }
        }, {
          key: "readInt64",
          value: function value(e) {
            for (var t = 0, r = (128 & this._dataView.getUint8(e + (this._littleEndian ? 7 : 0))) > 0, n = !0, i = 0; i < 8; i++) {
              var a = this._dataView.getUint8(e + (this._littleEndian ? i : 7 - i));

              r && (n ? 0 !== a && (a = 255 & ~(a - 1), n = !1) : a = 255 & ~a), t += a * Math.pow(256, i);
            }

            return r && (t = -t), t;
          }
        }, {
          key: "readOffset",
          value: function value(e) {
            return this._bigTiff ? this.readUint64(e) : this.readUint32(e);
          }
        }]), e;
      }(),
          Ve = "undefined" != typeof navigator && navigator.hardwareConcurrency || 2,
          Ge = function () {
        function e() {
          var t = this,
              r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ve,
              n = arguments.length > 1 ? arguments[1] : void 0;
          b(this, e), this.workers = null, this._awaitingDecoder = null, this.size = r, this.messageId = 0, r && (this._awaitingDecoder = n ? Promise.resolve(n) : new Promise(function (e) {
            Promise.resolve().then(function () {
              return Xi;
            }).then(function (t) {
              e(t.create);
            });
          }), this._awaitingDecoder.then(function (e) {
            t._awaitingDecoder = null, t.workers = [];

            for (var n = 0; n < r; n++) {
              t.workers.push({
                worker: e(),
                idle: !0
              });
            }
          }));
        }

        var t;
        return l(e, [{
          key: "decode",
          value: (t = u(x.mark(function e(t, r) {
            var n = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (!this._awaitingDecoder) {
                      e.next = 3;
                      break;
                    }

                    return e.next = 3, this._awaitingDecoder;

                  case 3:
                    return e.abrupt("return", 0 === this.size ? ke(t).then(function (e) {
                      return e.decode(t, r);
                    }) : new Promise(function (e) {
                      var i = n.workers.find(function (e) {
                        return e.idle;
                      }) || n.workers[Math.floor(Math.random() * n.size)];
                      i.idle = !1;
                      var a = n.messageId++;
                      i.worker.addEventListener("message", function t(r) {
                        r.data.id === a && (i.idle = !0, e(r.data.decoded), i.worker.removeEventListener("message", t));
                      }), i.worker.postMessage({
                        fileDirectory: t,
                        buffer: r,
                        id: a
                      }, [r]);
                    }));

                  case 4:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }, {
          key: "destroy",
          value: function value() {
            this.workers && (this.workers.forEach(function (e) {
              e.worker.terminate();
            }), this.workers = null);
          }
        }]), e;
      }(),
          je = Ge;

      function Ne(e, t) {
        if (null == e) return {};

        var r,
            n,
            i = function (e, t) {
          if (null == e) return {};
          var r,
              n,
              i = {},
              a = Object.keys(e);

          for (n = 0; n < a.length; n++) {
            r = a[n], t.indexOf(r) >= 0 || (i[r] = e[r]);
          }

          return i;
        }(e, t);

        if (Object.getOwnPropertySymbols) {
          var a = Object.getOwnPropertySymbols(e);

          for (n = 0; n < a.length; n++) {
            r = a[n], t.indexOf(r) >= 0 || Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]);
          }
        }

        return i;
      }

      function ze(e) {
        return r(e) || function (e) {
          if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
        }(e) || i(e) || a();
      }

      function Ke(e, t) {
        var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

        if (!r) {
          if (Array.isArray(e) || (r = function (e, t) {
            if (!e) return;
            if ("string" == typeof e) return Ze(e, t);
            var r = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === r && e.constructor && (r = e.constructor.name);
            if ("Map" === r || "Set" === r) return Array.from(e);
            if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Ze(e, t);
          }(e)) || t && e && "number" == typeof e.length) {
            r && (e = r);

            var _n2 = 0,
                i = function i() {};

            return {
              s: i,
              n: function n() {
                return _n2 >= e.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: e[_n2++]
                };
              },
              e: function e(_e2) {
                throw _e2;
              },
              f: i
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        var a,
            o = !0,
            s = !1;
        return {
          s: function s() {
            r = r.call(e);
          },
          n: function n() {
            var e = r.next();
            return o = e.done, e;
          },
          e: function e(_e3) {
            s = !0, a = _e3;
          },
          f: function f() {
            try {
              o || null == r["return"] || r["return"]();
            } finally {
              if (s) throw a;
            }
          }
        };
      }

      function Ze(e, t) {
        (null == t || t > e.length) && (t = e.length);

        for (var r = 0, n = new Array(t); r < t; r++) {
          n[r] = e[r];
        }

        return n;
      }

      var He = "\r\n\r\n";

      function Ye(e) {
        if (void 0 !== Object.fromEntries) return Object.fromEntries(e);
        var t,
            r = {},
            n = Ke(e);

        try {
          for (n.s(); !(t = n.n()).done;) {
            var i = o(t.value, 2),
                a = i[0],
                s = i[1];
            r[a.toLowerCase()] = s;
          }
        } catch (e) {
          n.e(e);
        } finally {
          n.f();
        }

        return r;
      }

      function qe(e) {
        return Ye(e.split("\r\n").map(function (e) {
          var t = e.split(":").map(function (e) {
            return e.trim();
          });
          return t[0] = t[0].toLowerCase(), t;
        }));
      }

      function Xe(e) {
        var t, r, n;

        if (e) {
          var i = o(e.match(/bytes (\d+)-(\d+)\/(\d+)/), 4);
          t = i[1], r = i[2], n = i[3], t = parseInt(t, 10), r = parseInt(r, 10), n = parseInt(n, 10);
        }

        return {
          start: t,
          end: r,
          total: n
        };
      }

      function We(e, t) {
        for (var r = null, n = new TextDecoder("ascii"), i = [], a = "--".concat(t), o = "".concat(a, "--"), s = 0; s < 10; ++s) {
          n.decode(new Uint8Array(e, s, a.length)) === a && (r = s);
        }

        if (null === r) throw new Error("Could not find initial boundary");

        for (; r < e.byteLength;) {
          var u = n.decode(new Uint8Array(e, r, Math.min(a.length + 1024, e.byteLength - r)));
          if (0 === u.length || u.startsWith(o)) break;
          if (!u.startsWith(a)) throw new Error("Part does not start with boundary");
          var f = u.substr(a.length + 2);
          if (0 === f.length) break;
          var l = f.indexOf(He),
              c = qe(f.substr(0, l)),
              h = Xe(c["content-range"]),
              d = h.start,
              p = h.end,
              v = h.total,
              m = r + a.length + l + He.length,
              g = parseInt(p, 10) + 1 - parseInt(d, 10);
          i.push({
            headers: c,
            data: e.slice(m, m + g),
            offset: d,
            length: g,
            fileSize: v
          }), r = m + g + 4;
        }

        return i;
      }

      var Je = function () {
        function e() {
          b(this, e);
        }

        var t, r, n;
        return l(e, [{
          key: "fetch",
          value: (n = u(x.mark(function e(t) {
            var r,
                n = this,
                i = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return r = i.length > 1 && void 0 !== i[1] ? i[1] : void 0, e.abrupt("return", Promise.all(t.map(function (e) {
                      return n.fetchSlice(e, r);
                    })));

                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function (e) {
            return n.apply(this, arguments);
          })
        }, {
          key: "fetchSlice",
          value: (r = u(x.mark(function e(t) {
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    throw new Error("fetching of slice ".concat(t, " not possible, not implemented"));

                  case 1:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function (e) {
            return r.apply(this, arguments);
          })
        }, {
          key: "fileSize",
          get: function get() {
            return null;
          }
        }, {
          key: "close",
          value: (t = u(x.mark(function e() {
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), e;
      }(),
          Qe = $e;

      function $e(e) {
        var t = this;
        if (t instanceof $e || (t = new $e()), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach(function (e) {
          t.push(e);
        });else if (arguments.length > 0) for (var r = 0, n = arguments.length; r < n; r++) {
          t.push(arguments[r]);
        }
        return t;
      }

      function et(e, t, r) {
        var n = t === e.head ? new nt(r, null, t, e) : new nt(r, t, t.next, e);
        return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n;
      }

      function tt(e, t) {
        e.tail = new nt(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
      }

      function rt(e, t) {
        e.head = new nt(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
      }

      function nt(e, t, r, n) {
        if (!(this instanceof nt)) return new nt(e, t, r, n);
        this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
      }

      $e.Node = nt, $e.create = $e, $e.prototype.removeNode = function (e) {
        if (e.list !== this) throw new Error("removing node which does not belong to this list");
        var t = e.next,
            r = e.prev;
        return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
      }, $e.prototype.unshiftNode = function (e) {
        if (e !== this.head) {
          e.list && e.list.removeNode(e);
          var t = this.head;
          e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
        }
      }, $e.prototype.pushNode = function (e) {
        if (e !== this.tail) {
          e.list && e.list.removeNode(e);
          var t = this.tail;
          e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
        }
      }, $e.prototype.push = function () {
        for (var e = 0, t = arguments.length; e < t; e++) {
          tt(this, arguments[e]);
        }

        return this.length;
      }, $e.prototype.unshift = function () {
        for (var e = 0, t = arguments.length; e < t; e++) {
          rt(this, arguments[e]);
        }

        return this.length;
      }, $e.prototype.pop = function () {
        if (this.tail) {
          var e = this.tail.value;
          return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
        }
      }, $e.prototype.shift = function () {
        if (this.head) {
          var e = this.head.value;
          return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
        }
      }, $e.prototype.forEach = function (e, t) {
        t = t || this;

        for (var r = this.head, n = 0; null !== r; n++) {
          e.call(t, r.value, n, this), r = r.next;
        }
      }, $e.prototype.forEachReverse = function (e, t) {
        t = t || this;

        for (var r = this.tail, n = this.length - 1; null !== r; n--) {
          e.call(t, r.value, n, this), r = r.prev;
        }
      }, $e.prototype.get = function (e) {
        for (var t = 0, r = this.head; null !== r && t < e; t++) {
          r = r.next;
        }

        if (t === e && null !== r) return r.value;
      }, $e.prototype.getReverse = function (e) {
        for (var t = 0, r = this.tail; null !== r && t < e; t++) {
          r = r.prev;
        }

        if (t === e && null !== r) return r.value;
      }, $e.prototype.map = function (e, t) {
        t = t || this;

        for (var r = new $e(), n = this.head; null !== n;) {
          r.push(e.call(t, n.value, this)), n = n.next;
        }

        return r;
      }, $e.prototype.mapReverse = function (e, t) {
        t = t || this;

        for (var r = new $e(), n = this.tail; null !== n;) {
          r.push(e.call(t, n.value, this)), n = n.prev;
        }

        return r;
      }, $e.prototype.reduce = function (e, t) {
        var r,
            n = this.head;
        if (arguments.length > 1) r = t;else {
          if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
          n = this.head.next, r = this.head.value;
        }

        for (var i = 0; null !== n; i++) {
          r = e(r, n.value, i), n = n.next;
        }

        return r;
      }, $e.prototype.reduceReverse = function (e, t) {
        var r,
            n = this.tail;
        if (arguments.length > 1) r = t;else {
          if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
          n = this.tail.prev, r = this.tail.value;
        }

        for (var i = this.length - 1; null !== n; i--) {
          r = e(r, n.value, i), n = n.prev;
        }

        return r;
      }, $e.prototype.toArray = function () {
        for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) {
          e[t] = r.value, r = r.next;
        }

        return e;
      }, $e.prototype.toArrayReverse = function () {
        for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) {
          e[t] = r.value, r = r.prev;
        }

        return e;
      }, $e.prototype.slice = function (e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new $e();
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);

        for (var n = 0, i = this.head; null !== i && n < e; n++) {
          i = i.next;
        }

        for (; null !== i && n < t; n++, i = i.next) {
          r.push(i.value);
        }

        return r;
      }, $e.prototype.sliceReverse = function (e, t) {
        (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
        var r = new $e();
        if (t < e || t < 0) return r;
        e < 0 && (e = 0), t > this.length && (t = this.length);

        for (var n = this.length, i = this.tail; null !== i && n > t; n--) {
          i = i.prev;
        }

        for (; null !== i && n > e; n--, i = i.prev) {
          r.push(i.value);
        }

        return r;
      }, $e.prototype.splice = function (e, t) {
        e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);

        for (var r = 0, n = this.head; null !== n && r < e; r++) {
          n = n.next;
        }

        var i = [];

        for (r = 0; n && r < t; r++) {
          i.push(n.value), n = this.removeNode(n);
        }

        null === n && (n = this.tail), n !== this.head && n !== this.tail && (n = n.prev);

        for (r = 0; r < (arguments.length <= 2 ? 0 : arguments.length - 2); r++) {
          n = et(this, n, r + 2 < 2 || arguments.length <= r + 2 ? void 0 : arguments[r + 2]);
        }

        return i;
      }, $e.prototype.reverse = function () {
        for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
          var n = r.prev;
          r.prev = r.next, r.next = n;
        }

        return this.head = t, this.tail = e, this;
      };

      try {
        require("./iterator.js")($e);
      } catch (e) {}

      var it = Qe,
          at = Symbol("max"),
          ot = Symbol("length"),
          st = Symbol("lengthCalculator"),
          ut = Symbol("allowStale"),
          ft = Symbol("maxAge"),
          lt = Symbol("dispose"),
          ct = Symbol("noDisposeOnSet"),
          ht = Symbol("lruList"),
          dt = Symbol("cache"),
          pt = Symbol("updateAgeOnGet"),
          vt = function vt() {
        return 1;
      },
          mt = function () {
        function e(t) {
          if (b(this, e), "number" == typeof t && (t = {
            max: t
          }), t || (t = {}), t.max && ("number" != typeof t.max || t.max < 0)) throw new TypeError("max must be a non-negative number");
          this[at] = t.max || 1 / 0;
          var r = t.length || vt;
          if (this[st] = "function" != typeof r ? vt : r, this[ut] = t.stale || !1, t.maxAge && "number" != typeof t.maxAge) throw new TypeError("maxAge must be a number");
          this[ft] = t.maxAge || 0, this[lt] = t.dispose, this[ct] = t.noDisposeOnSet || !1, this[pt] = t.updateAgeOnGet || !1, this.reset();
        }

        return l(e, [{
          key: "max",
          get: function get() {
            return this[at];
          },
          set: function set(e) {
            if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
            this[at] = e || 1 / 0, wt(this);
          }
        }, {
          key: "allowStale",
          get: function get() {
            return this[ut];
          },
          set: function set(e) {
            this[ut] = !!e;
          }
        }, {
          key: "maxAge",
          get: function get() {
            return this[ft];
          },
          set: function set(e) {
            if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
            this[ft] = e, wt(this);
          }
        }, {
          key: "lengthCalculator",
          get: function get() {
            return this[st];
          },
          set: function set(e) {
            var t = this;
            "function" != typeof e && (e = vt), e !== this[st] && (this[st] = e, this[ot] = 0, this[ht].forEach(function (e) {
              e.length = t[st](e.value, e.key), t[ot] += e.length;
            })), wt(this);
          }
        }, {
          key: "length",
          get: function get() {
            return this[ot];
          }
        }, {
          key: "itemCount",
          get: function get() {
            return this[ht].length;
          }
        }, {
          key: "rforEach",
          value: function value(e, t) {
            t = t || this;

            for (var r = this[ht].tail; null !== r;) {
              var n = r.prev;
              xt(this, e, r, t), r = n;
            }
          }
        }, {
          key: "forEach",
          value: function value(e, t) {
            t = t || this;

            for (var r = this[ht].head; null !== r;) {
              var n = r.next;
              xt(this, e, r, t), r = n;
            }
          }
        }, {
          key: "keys",
          value: function value() {
            return this[ht].toArray().map(function (e) {
              return e.key;
            });
          }
        }, {
          key: "values",
          value: function value() {
            return this[ht].toArray().map(function (e) {
              return e.value;
            });
          }
        }, {
          key: "reset",
          value: function value() {
            var e = this;
            this[lt] && this[ht] && this[ht].length && this[ht].forEach(function (t) {
              return e[lt](t.key, t.value);
            }), this[dt] = new Map(), this[ht] = new it(), this[ot] = 0;
          }
        }, {
          key: "dump",
          value: function value() {
            var e = this;
            return this[ht].map(function (t) {
              return !yt(e, t) && {
                k: t.key,
                v: t.value,
                e: t.now + (t.maxAge || 0)
              };
            }).toArray().filter(function (e) {
              return e;
            });
          }
        }, {
          key: "dumpLru",
          value: function value() {
            return this[ht];
          }
        }, {
          key: "set",
          value: function value(e, t, r) {
            if ((r = r || this[ft]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
            var n = r ? Date.now() : 0,
                i = this[st](t, e);

            if (this[dt].has(e)) {
              if (i > this[at]) return bt(this, this[dt].get(e)), !1;
              var a = this[dt].get(e).value;
              return this[lt] && (this[ct] || this[lt](e, a.value)), a.now = n, a.maxAge = r, a.value = t, this[ot] += i - a.length, a.length = i, this.get(e), wt(this), !0;
            }

            var o = new kt(e, t, i, n, r);
            return o.length > this[at] ? (this[lt] && this[lt](e, t), !1) : (this[ot] += o.length, this[ht].unshift(o), this[dt].set(e, this[ht].head), wt(this), !0);
          }
        }, {
          key: "has",
          value: function value(e) {
            if (!this[dt].has(e)) return !1;
            var t = this[dt].get(e).value;
            return !yt(this, t);
          }
        }, {
          key: "get",
          value: function value(e) {
            return gt(this, e, !0);
          }
        }, {
          key: "peek",
          value: function value(e) {
            return gt(this, e, !1);
          }
        }, {
          key: "pop",
          value: function value() {
            var e = this[ht].tail;
            return e ? (bt(this, e), e.value) : null;
          }
        }, {
          key: "del",
          value: function value(e) {
            bt(this, this[dt].get(e));
          }
        }, {
          key: "load",
          value: function value(e) {
            this.reset();

            for (var t = Date.now(), r = e.length - 1; r >= 0; r--) {
              var n = e[r],
                  i = n.e || 0;
              if (0 === i) this.set(n.k, n.v);else {
                var a = i - t;
                a > 0 && this.set(n.k, n.v, a);
              }
            }
          }
        }, {
          key: "prune",
          value: function value() {
            var e = this;
            this[dt].forEach(function (t, r) {
              return gt(e, r, !1);
            });
          }
        }]), e;
      }(),
          gt = function gt(e, t, r) {
        var n = e[dt].get(t);

        if (n) {
          var i = n.value;

          if (yt(e, i)) {
            if (bt(e, n), !e[ut]) return;
          } else r && (e[pt] && (n.value.now = Date.now()), e[ht].unshiftNode(n));

          return i.value;
        }
      },
          yt = function yt(e, t) {
        if (!t || !t.maxAge && !e[ft]) return !1;
        var r = Date.now() - t.now;
        return t.maxAge ? r > t.maxAge : e[ft] && r > e[ft];
      },
          wt = function wt(e) {
        if (e[ot] > e[at]) for (var t = e[ht].tail; e[ot] > e[at] && null !== t;) {
          var r = t.prev;
          bt(e, t), t = r;
        }
      },
          bt = function bt(e, t) {
        if (t) {
          var r = t.value;
          e[lt] && e[lt](r.key, r.value), e[ot] -= r.length, e[dt]["delete"](r.key), e[ht].removeNode(t);
        }
      },
          kt = function e(t, r, n, i, a) {
        b(this, e), this.key = t, this.value = r, this.length = n, this.now = i, this.maxAge = a || 0;
      },
          xt = function xt(e, t, r, n) {
        var i = r.value;
        yt(e, i) && (bt(e, r), e[ut] || (i = void 0)), i && t.call(n, i.value, i.key, e);
      },
          At = mt;

      function Pt(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      function _t(e, t) {
        for (var r in t) {
          t.hasOwnProperty(r) && (e[r] = t[r]);
        }
      }

      function It(e, t) {
        return !(e.length < t.length) && e.substr(e.length - t.length) === t;
      }

      function St(e) {
        var t = {};

        for (var r in e) {
          if (e.hasOwnProperty(r)) t[e[r]] = r;
        }

        return t;
      }

      function Tt(e, t) {
        for (var r = [], n = 0; n < e; n++) {
          r.push(t(n));
        }

        return r;
      }

      function Ut(e) {
        return Ot.apply(this, arguments);
      }

      function Ot() {
        return (Ot = u(x.mark(function e(t) {
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return e.abrupt("return", new Promise(function (e) {
                    return setTimeout(e, t);
                  }));

                case 1:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))).apply(this, arguments);
      }

      function Dt(e, t) {
        var r = Array.isArray(e) ? e : Array.from(e),
            n = Array.isArray(t) ? t : Array.from(t);
        return r.map(function (e, t) {
          return [e, n[t]];
        });
      }

      var Et = function (e) {
        h(r, e);
        var t = Pt(r);

        function r(e) {
          var n;
          return b(this, r), n = t.call(this, e), Error.captureStackTrace && Error.captureStackTrace(p(n), r), n.name = "AbortError", n;
        }

        return r;
      }(w(Error)),
          Rt = function (e) {
        h(r, e);
        var t = Pt(r);

        function r(e, n) {
          var i;
          return b(this, r), (i = t.call(this, n)).errors = e, i.message = n, i.name = "AggregateError", i;
        }

        return r;
      }(w(Error));

      function Mt(e, t) {
        var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

        if (!r) {
          if (Array.isArray(e) || (r = function (e, t) {
            if (!e) return;
            if ("string" == typeof e) return Bt(e, t);
            var r = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === r && e.constructor && (r = e.constructor.name);
            if ("Map" === r || "Set" === r) return Array.from(e);
            if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Bt(e, t);
          }(e)) || t && e && "number" == typeof e.length) {
            r && (e = r);

            var _n3 = 0,
                i = function i() {};

            return {
              s: i,
              n: function n() {
                return _n3 >= e.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: e[_n3++]
                };
              },
              e: function e(_e4) {
                throw _e4;
              },
              f: i
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        var a,
            o = !0,
            s = !1;
        return {
          s: function s() {
            r = r.call(e);
          },
          n: function n() {
            var e = r.next();
            return o = e.done, e;
          },
          e: function e(_e5) {
            s = !0, a = _e5;
          },
          f: function f() {
            try {
              o || null == r["return"] || r["return"]();
            } finally {
              if (s) throw a;
            }
          }
        };
      }

      function Bt(e, t) {
        (null == t || t > e.length) && (t = e.length);

        for (var r = 0, n = new Array(t); r < t; r++) {
          n[r] = e[r];
        }

        return n;
      }

      function Ct(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Lt = function () {
        function e(t, r) {
          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
          b(this, e), this.offset = t, this.length = r, this.data = n;
        }

        return l(e, [{
          key: "top",
          get: function get() {
            return this.offset + this.length;
          }
        }]), e;
      }(),
          Ft = function e(t, r, n) {
        b(this, e), this.offset = t, this.length = r, this.blockIds = n;
      },
          Vt = function (e) {
        h(n, e);
        var t,
            r = Ct(n);

        function n(e) {
          var t,
              i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
              a = i.blockSize,
              o = void 0 === a ? 65536 : a,
              s = i.cacheSize,
              u = void 0 === s ? 100 : s;
          return b(this, n), (t = r.call(this)).source = e, t.blockSize = o, t.blockCache = new At({
            max: u
          }), t.blockRequests = new Map(), t.blockIdsToFetch = new Set(), t;
        }

        return l(n, [{
          key: "fileSize",
          get: function get() {
            return this.source.fileSize;
          }
        }, {
          key: "fetch",
          value: (t = u(x.mark(function e(t, r) {
            var n, i, a, s, u, f, l, c, h, d, p, v, m, g, y, w, b, k, A, P, _, I, S, T, U, O, D, E, R, M, B, C, L, F, V, G, j, N;

            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    n = new Map(), i = new Map(), a = new Set(), s = Mt(t);

                    try {
                      for (s.s(); !(u = s.n()).done;) {
                        for (f = u.value, l = f.offset, c = f.length, h = l + c, null !== (d = this.fileSize) && (h = Math.min(h, d)), p = Math.floor(l / this.blockSize) * this.blockSize, v = p; v < h; v += this.blockSize) {
                          m = Math.floor(v / this.blockSize), this.blockCache.has(m) ? n.set(m, this.blockCache.get(m)) : this.blockRequests.has(m) ? i.set(m, this.blockRequests.get(m)) : (this.blockIdsToFetch.has(m) || this.blockIdsToFetch.add(m), a.add(m));
                        }
                      }
                    } catch (e) {
                      s.e(e);
                    } finally {
                      s.f();
                    }

                    return e.next = 7, Ut();

                  case 7:
                    this.fetchBlocks(r), g = Mt(a), e.prev = 9, g.s();

                  case 11:
                    if ((y = g.n()).done) {
                      e.next = 26;
                      break;
                    }

                    if (w = y.value, b = this.blockRequests.get(w), k = this.blockCache.get(w), !b) {
                      e.next = 19;
                      break;
                    }

                    i.set(w, b), e.next = 24;
                    break;

                  case 19:
                    if (!k) {
                      e.next = 23;
                      break;
                    }

                    n.set(w, k), e.next = 24;
                    break;

                  case 23:
                    throw new Error("Block ".concat(w, " is not in the block requests"));

                  case 24:
                    e.next = 11;
                    break;

                  case 26:
                    e.next = 31;
                    break;

                  case 28:
                    e.prev = 28, e.t0 = e["catch"](9), g.e(e.t0);

                  case 31:
                    return e.prev = 31, g.f(), e.finish(31);

                  case 34:
                    return e.next = 36, Promise.allSettled(Array.from(i.values()));

                  case 36:
                    if (!(A = e.sent).some(function (e) {
                      return "rejected" === e.status;
                    })) {
                      e.next = 65;
                      break;
                    }

                    P = new Set(), _ = Mt(Dt(i.keys(), A));

                    try {
                      for (_.s(); !(I = _.n()).done;) {
                        S = o(I.value, 2), T = S[0], U = S[1], O = U.rejected, D = U.reason, O && "AbortError" === D.name && D.signal !== r && (this.blockIdsToFetch.add(T), P.add(T));
                      }
                    } catch (e) {
                      _.e(e);
                    } finally {
                      _.f();
                    }

                    if (!(this.blockIdsToFetch.length > 0)) {
                      e.next = 65;
                      break;
                    }

                    this.fetchBlocks(r), E = Mt(P), e.prev = 44, E.s();

                  case 46:
                    if ((R = E.n()).done) {
                      e.next = 54;
                      break;
                    }

                    if (M = R.value, B = this.blockRequests.get(M)) {
                      e.next = 51;
                      break;
                    }

                    throw new Error("Block ".concat(M, " is not in the block requests"));

                  case 51:
                    i.set(M, B);

                  case 52:
                    e.next = 46;
                    break;

                  case 54:
                    e.next = 59;
                    break;

                  case 56:
                    e.prev = 56, e.t1 = e["catch"](44), E.e(e.t1);

                  case 59:
                    return e.prev = 59, E.f(), e.finish(59);

                  case 62:
                    return e.next = 64, Promise.allSettled(Array.from(i.values()));

                  case 64:
                    A = e.sent;

                  case 65:
                    if (!A.some(function (e) {
                      return "rejected" === e.status;
                    })) {
                      e.next = 69;
                      break;
                    }

                    if (!r || !r.aborted) {
                      e.next = 68;
                      break;
                    }

                    throw new Et("Request was aborted");

                  case 68:
                    throw new Rt(A.filter(function (e) {
                      return "rejected" === e.status;
                    }).map(function (e) {
                      return e.reason;
                    }), "Request failed");

                  case 69:
                    C = A.map(function (e) {
                      return e.value;
                    }), L = new Map(Dt(Array.from(i.keys()), C)), F = Mt(n);

                    try {
                      for (F.s(); !(V = F.n()).done;) {
                        G = o(V.value, 2), j = G[0], N = G[1], L.set(j, N);
                      }
                    } catch (e) {
                      F.e(e);
                    } finally {
                      F.f();
                    }

                    return e.abrupt("return", this.readSliceData(t, L));

                  case 74:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this, [[9, 28, 31, 34], [44, 56, 59, 62]]);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }, {
          key: "fetchBlocks",
          value: function value(e) {
            var t = this;
            this.blockIdsToFetch.size > 0 && function () {
              for (var r = t.groupBlocks(t.blockIdsToFetch), n = t.source.fetch(r, e), i = function i(_i2) {
                var a,
                    o = Mt(r[_i2].blockIds);

                try {
                  var s = function s() {
                    var r = a.value,
                        o = u(x.mark(function a() {
                      var o, s, u, f, l, c;
                      return x.wrap(function (a) {
                        for (;;) {
                          switch (a.prev = a.next) {
                            case 0:
                              return a.prev = 0, a.next = 3, n;

                            case 3:
                              return a.t0 = _i2, o = a.sent[a.t0], s = r * t.blockSize, u = s - o.offset, f = Math.min(u + t.blockSize, o.data.byteLength), l = o.data.slice(u, f), c = new Lt(s, l.byteLength, l), t.blockCache.set(r, c), a.abrupt("return", c);

                            case 14:
                              throw a.prev = 14, a.t1 = a["catch"](0), "AbortError" === a.t1.name && (a.t1.signal = e), a.t1;

                            case 18:
                              return a.prev = 18, t.blockRequests["delete"](r), a.finish(18);

                            case 21:
                            case "end":
                              return a.stop();
                          }
                        }
                      }, a, null, [[0, 14, 18, 21]]);
                    }))();
                    t.blockRequests.set(r, o);
                  };

                  for (o.s(); !(a = o.n()).done;) {
                    s();
                  }
                } catch (e) {
                  o.e(e);
                } finally {
                  o.f();
                }
              }, a = 0; a < r.length; ++a) {
                i(a);
              }

              t.blockIdsToFetch.clear();
            }();
          }
        }, {
          key: "groupBlocks",
          value: function value(e) {
            var t = Array.from(e).sort(function (e, t) {
              return e - t;
            });
            if (0 === t.length) return [];
            var r,
                n = [],
                i = null,
                a = [],
                o = Mt(t);

            try {
              for (o.s(); !(r = o.n()).done;) {
                var s = r.value;
                null === i || i + 1 === s ? (n.push(s), i = s) : (a.push(new Ft(n[0] * this.blockSize, n.length * this.blockSize, n)), n = [s], i = s);
              }
            } catch (e) {
              o.e(e);
            } finally {
              o.f();
            }

            return a.push(new Ft(n[0] * this.blockSize, n.length * this.blockSize, n)), a;
          }
        }, {
          key: "readSliceData",
          value: function value(e, t) {
            var r = this;
            return e.map(function (e) {
              for (var n = e.offset + e.length, i = Math.floor(e.offset / r.blockSize), a = Math.floor((e.offset + e.length) / r.blockSize), o = new ArrayBuffer(e.length), s = new Uint8Array(o), u = i; u <= a; ++u) {
                var f = t.get(u),
                    l = f.offset - e.offset,
                    c = 0,
                    h = 0,
                    d = void 0;
                l < 0 ? c = -l : l > 0 && (h = l), d = f.top - n < 0 ? f.length - c : n - f.offset - c;
                var p = new Uint8Array(f.data, c, d);
                s.set(p, h);
              }

              return o;
            });
          }
        }]), n;
      }(Je),
          Gt = function () {
        function e() {
          b(this, e);
        }

        var t;
        return l(e, [{
          key: "ok",
          get: function get() {
            return this.status >= 200 && this.status <= 299;
          }
        }, {
          key: "status",
          get: function get() {
            throw new Error("not implemented");
          }
        }, {
          key: "getHeader",
          value: function value(e) {
            throw new Error("not implemented");
          }
        }, {
          key: "getData",
          value: (t = u(x.mark(function e() {
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    throw new Error("not implemented");

                  case 1:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), e;
      }(),
          jt = function () {
        function e(t) {
          b(this, e), this.url = t;
        }

        var t;
        return l(e, [{
          key: "request",
          value: (t = u(x.mark(function e() {
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    throw new Error("request is not implemented");

                  case 2:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), e;
      }();

      function Nt(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var zt = function (e) {
        h(n, e);
        var t,
            r = Nt(n);

        function n(e) {
          var t;
          return b(this, n), (t = r.call(this)).response = e, t;
        }

        return l(n, [{
          key: "status",
          get: function get() {
            return this.response.status;
          }
        }, {
          key: "getHeader",
          value: function value(e) {
            return this.response.headers.get(e);
          }
        }, {
          key: "getData",
          value: (t = u(x.mark(function e() {
            var t;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (!this.response.arrayBuffer) {
                      e.next = 6;
                      break;
                    }

                    return e.next = 3, this.response.arrayBuffer();

                  case 3:
                    e.t0 = e.sent, e.next = 9;
                    break;

                  case 6:
                    return e.next = 8, this.response.buffer();

                  case 8:
                    e.t0 = e.sent.buffer;

                  case 9:
                    return t = e.t0, e.abrupt("return", t);

                  case 11:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(Gt),
          Kt = function (e) {
        h(n, e);
        var t,
            r = Nt(n);

        function n(e, t) {
          var i;
          return b(this, n), (i = r.call(this, e)).credentials = t, i;
        }

        return l(n, [{
          key: "request",
          value: (t = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                o = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = o.length > 0 && void 0 !== o[0] ? o[0] : {}, r = t.headers, n = t.credentials, i = t.signal, e.next = 3, fetch(this.url, {
                      headers: r,
                      credentials: n,
                      signal: i
                    });

                  case 3:
                    return a = e.sent, e.abrupt("return", new zt(a));

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(jt);

      function Zt(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Ht = function (e) {
        h(n, e);
        var t,
            r = Zt(n);

        function n(e, t) {
          var i;
          return b(this, n), (i = r.call(this)).xhr = e, i.data = t, i;
        }

        return l(n, [{
          key: "status",
          get: function get() {
            return this.xhr.status;
          }
        }, {
          key: "getHeader",
          value: function value(e) {
            return this.xhr.getResponseHeader(e);
          }
        }, {
          key: "getData",
          value: (t = u(x.mark(function e() {
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.abrupt("return", this.data);

                  case 1:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(Gt),
          Yt = function (e) {
        h(n, e);
        var t,
            r = Zt(n);

        function n() {
          return b(this, n), r.apply(this, arguments);
        }

        return l(n, [{
          key: "constructRequest",
          value: function value(e, t) {
            var r = this;
            return new Promise(function (n, i) {
              var a = new XMLHttpRequest();
              a.open("GET", r.url), a.responseType = "arraybuffer";

              for (var s = 0, u = Object.entries(e); s < u.length; s++) {
                var f = o(u[s], 2),
                    l = f[0],
                    c = f[1];
                a.setRequestHeader(l, c);
              }

              a.onload = function () {
                var e = a.response;
                n(new Ht(a, e));
              }, a.onerror = i, a.onabort = function () {
                return i(new Et("Request aborted"));
              }, a.send(), t && (t.aborted && a.abort(), t.addEventListener("abort", function () {
                return a.abort();
              }));
            });
          }
        }, {
          key: "request",
          value: (t = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = a.length > 0 && void 0 !== a[0] ? a[0] : {}, r = t.headers, n = t.signal, e.next = 3, this.constructRequest(r, n);

                  case 3:
                    return i = e.sent, e.abrupt("return", i);

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(jt),
          qt = {};

      function Xt(e, t) {
        var r = Object.keys(e);

        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          t && (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })), r.push.apply(r, n);
        }

        return r;
      }

      function Wt(e) {
        for (var r = 1; r < arguments.length; r++) {
          var n = null != arguments[r] ? arguments[r] : {};
          r % 2 ? Xt(Object(n), !0).forEach(function (r) {
            t(e, r, n[r]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xt(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
          });
        }

        return e;
      }

      function Jt(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Qt = function (e) {
        h(n, e);
        var t,
            r = Jt(n);

        function n(e, t) {
          var i;
          return b(this, n), (i = r.call(this)).response = e, i.dataPromise = t, i;
        }

        return l(n, [{
          key: "status",
          get: function get() {
            return this.response.statusCode;
          }
        }, {
          key: "getHeader",
          value: function value(e) {
            return this.response.headers[e];
          }
        }, {
          key: "getData",
          value: (t = u(x.mark(function e() {
            var t;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, this.dataPromise;

                  case 2:
                    return t = e.sent, e.abrupt("return", t);

                  case 4:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(Gt),
          $t = function (e) {
        h(n, e);
        var t,
            r = Jt(n);

        function n(e) {
          var t;
          return b(this, n), (t = r.call(this, e)).parsedUrl = qt.parse(t.url), t.httpApi = (t.parsedUrl.protocol, qt), t;
        }

        return l(n, [{
          key: "constructRequest",
          value: function value(e, t) {
            var r = this;
            return new Promise(function (n, i) {
              var a = r.httpApi.get(Wt(Wt({}, r.parsedUrl), {}, {
                headers: e
              }), function (e) {
                var t = new Promise(function (t) {
                  var r = [];
                  e.on("data", function (e) {
                    r.push(e);
                  }), e.on("end", function () {
                    var e = Buffer.concat(r).buffer;
                    t(e);
                  }), e.on("error", i);
                });
                n(new Qt(e, t));
              });
              a.on("error", i), t && (t.aborted && a.destroy(new Et("Request aborted")), t.addEventListener("abort", function () {
                return a.destroy(new Et("Request aborted"));
              }));
            });
          }
        }, {
          key: "request",
          value: (t = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = a.length > 0 && void 0 !== a[0] ? a[0] : {}, r = t.headers, n = t.signal, e.next = 3, this.constructRequest(r, n);

                  case 3:
                    return i = e.sent, e.abrupt("return", i);

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), n;
      }(jt),
          er = ["headers", "credentials", "maxRanges", "allowFullFile"],
          tr = ["headers", "maxRanges", "allowFullFile"],
          rr = ["headers", "maxRanges", "allowFullFile"],
          nr = ["forceXHR"];

      function ir(e, t) {
        var r = Object.keys(e);

        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          t && (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })), r.push.apply(r, n);
        }

        return r;
      }

      function ar(e) {
        for (var r = 1; r < arguments.length; r++) {
          var n = null != arguments[r] ? arguments[r] : {};
          r % 2 ? ir(Object(n), !0).forEach(function (r) {
            t(e, r, n[r]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ir(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
          });
        }

        return e;
      }

      function or(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var sr = function (e) {
        h(a, e);
        var t,
            r,
            n,
            i = or(a);

        function a(e, t, r, n) {
          var o;
          return b(this, a), (o = i.call(this)).client = e, o.headers = t, o.maxRanges = r, o.allowFullFile = n, o._fileSize = null, o;
        }

        return l(a, [{
          key: "fetch",
          value: (n = u(x.mark(function e(t, r) {
            var n = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (!(this.maxRanges >= t.length)) {
                      e.next = 4;
                      break;
                    }

                    return e.abrupt("return", this.fetchSlices(t, r));

                  case 4:
                    this.maxRanges > 0 && t.length;

                  case 5:
                    return e.abrupt("return", Promise.all(t.map(function (e) {
                      return n.fetchSlice(e, r);
                    })));

                  case 6:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, t) {
            return n.apply(this, arguments);
          })
        }, {
          key: "fetchSlices",
          value: (r = u(x.mark(function e(t, r) {
            var n,
                i,
                a,
                o,
                s,
                u,
                f,
                l,
                c,
                h,
                d,
                p,
                v = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, this.client.request({
                      headers: ar(ar({}, this.headers), {}, {
                        Range: "bytes=".concat(t.map(function (e) {
                          var t = e.offset,
                              r = e.length;
                          return "".concat(t, "-").concat(t + r);
                        }).join(","))
                      }),
                      signal: r
                    });

                  case 2:
                    if ((n = e.sent).ok) {
                      e.next = 7;
                      break;
                    }

                    throw new Error("Error fetching data.");

                  case 7:
                    if (206 !== n.status) {
                      e.next = 32;
                      break;
                    }

                    if (m = n.getHeader("content-type"), g = void 0, g = ze(m.split(";").map(function (e) {
                      return e.trim();
                    })), i = {
                      type: g[0],
                      params: Ye(g.slice(1).map(function (e) {
                        return e.split("=");
                      }))
                    }, a = i.params, "multipart/byteranges" !== i.type) {
                      e.next = 18;
                      break;
                    }

                    return e.t0 = We, e.next = 13, n.getData();

                  case 13:
                    return e.t1 = e.sent, e.t2 = a.boundary, o = (0, e.t0)(e.t1, e.t2), this._fileSize = o[0].fileSize || null, e.abrupt("return", o);

                  case 18:
                    return e.next = 20, n.getData();

                  case 20:
                    if (s = e.sent, u = Xe(n.getHeader("content-range")), f = u.start, l = u.end, c = u.total, this._fileSize = c || null, h = [{
                      data: s,
                      offset: f,
                      length: l - f
                    }], !(t.length > 1)) {
                      e.next = 29;
                      break;
                    }

                    return e.next = 27, Promise.all(t.slice(1).map(function (e) {
                      return v.fetchSlice(e, r);
                    }));

                  case 27:
                    return d = e.sent, e.abrupt("return", h.concat(d));

                  case 29:
                    return e.abrupt("return", h);

                  case 32:
                    if (this.allowFullFile) {
                      e.next = 34;
                      break;
                    }

                    throw new Error("Server responded with full file");

                  case 34:
                    return e.next = 36, n.getData();

                  case 36:
                    return p = e.sent, this._fileSize = p.byteLength, e.abrupt("return", [{
                      data: p,
                      offset: 0,
                      length: p.byteLength
                    }]);

                  case 39:
                  case "end":
                    return e.stop();
                }
              }

              var m, g;
            }, e, this);
          })), function (e, t) {
            return r.apply(this, arguments);
          })
        }, {
          key: "fetchSlice",
          value: (t = u(x.mark(function e(t, r) {
            var n, i, a, o, s, u, f;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return n = t.offset, i = t.length, e.next = 3, this.client.request({
                      headers: ar(ar({}, this.headers), {}, {
                        Range: "bytes=".concat(n, "-").concat(n + i)
                      }),
                      signal: r
                    });

                  case 3:
                    if ((a = e.sent).ok) {
                      e.next = 8;
                      break;
                    }

                    throw new Error("Error fetching data.");

                  case 8:
                    if (206 !== a.status) {
                      e.next = 17;
                      break;
                    }

                    return e.next = 11, a.getData();

                  case 11:
                    return o = e.sent, s = Xe(a.getHeader("content-range")), u = s.total, this._fileSize = u || null, e.abrupt("return", {
                      data: o,
                      offset: n,
                      length: i
                    });

                  case 17:
                    if (this.allowFullFile) {
                      e.next = 19;
                      break;
                    }

                    throw new Error("Server responded with full file");

                  case 19:
                    return e.next = 21, a.getData();

                  case 21:
                    return f = e.sent, this._fileSize = f.byteLength, e.abrupt("return", {
                      data: f,
                      offset: 0,
                      length: f.byteLength
                    });

                  case 24:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }, {
          key: "fileSize",
          get: function get() {
            return this._fileSize;
          }
        }]), a;
      }(Je);

      function ur(e, t) {
        var r = t.blockSize,
            n = t.cacheSize;
        return null === r ? e : new Vt(e, r, n);
      }

      function fr(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            r = t.headers,
            n = void 0 === r ? {} : r,
            i = t.credentials,
            a = t.maxRanges,
            o = void 0 === a ? 0 : a,
            s = t.allowFullFile,
            u = void 0 !== s && s,
            f = Ne(t, er),
            l = new Kt(e, i),
            c = new sr(l, n, o, u);
        return ur(c, f);
      }

      function lr(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            r = t.headers,
            n = void 0 === r ? {} : r,
            i = t.maxRanges,
            a = void 0 === i ? 0 : i,
            o = t.allowFullFile,
            s = void 0 !== o && o,
            u = Ne(t, tr),
            f = new Yt(e),
            l = new sr(f, n, a, s);
        return ur(l, u);
      }

      function cr(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            r = t.headers,
            n = void 0 === r ? {} : r,
            i = t.maxRanges,
            a = void 0 === i ? 0 : i,
            o = t.allowFullFile,
            s = void 0 !== o && o,
            u = Ne(t, rr),
            f = new $t(e),
            l = new sr(f, n, a, s);
        return ur(l, u);
      }

      function hr(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
            r = t.forceXHR,
            n = void 0 !== r && r,
            i = Ne(t, nr);
        return "function" != typeof fetch || n ? "undefined" != typeof XMLHttpRequest ? lr(e, i) : cr(e, i) : fr(e, i);
      }

      function dr(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var pr = function (e) {
        h(r, e);
        var t = dr(r);

        function r(e) {
          var n;
          return b(this, r), (n = t.call(this)).arrayBuffer = e, n;
        }

        return l(r, [{
          key: "fetchSlice",
          value: function value(e, t) {
            if (t && t.aborted) throw new Et("Request aborted");
            return this.arrayBuffer.slice(e.offset, e.offset + e.length);
          }
        }]), r;
      }(Je);

      function vr(e) {
        return new pr(e);
      }

      function mr(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var gr = function (e) {
        h(n, e);
        var t,
            r = mr(n);

        function n(e) {
          var t;
          return b(this, n), (t = r.call(this)).file = e, t;
        }

        return l(n, [{
          key: "fetchSlice",
          value: (t = u(x.mark(function e(t, r) {
            var n = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.abrupt("return", new Promise(function (e, i) {
                      var a = n.file.slice(t.offset, t.offset + t.length),
                          o = new FileReader();
                      o.onload = function (t) {
                        return e(t.target.result);
                      }, o.onerror = i, o.onabort = i, o.readAsArrayBuffer(a), r && r.addEventListener("abort", function () {
                        return o.abort();
                      });
                    }));

                  case 1:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }]), n;
      }(Je);

      function yr(e) {
        return new gr(e);
      }

      function wr(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      function br(e) {
        return new Promise(function (t, r) {
          qt.close(e, function (e) {
            e ? r(e) : t();
          });
        });
      }

      function kr() {
        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) {
          t[r] = arguments[r];
        }

        return new Promise(function (e, r) {
          qt.read.apply(qt, t.concat([function (t, n, i) {
            t ? r(t) : e({
              bytesRead: n,
              buffer: i
            });
          }]));
        });
      }

      var xr = function (e) {
        h(i, e);
        var t,
            r,
            n = wr(i);

        function i(e) {
          var t;
          return b(this, i), (t = n.call(this)).path = e, t.openRequest = function (e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
            return new Promise(function (n, i) {
              qt.open(e, t, r, function (e, t) {
                e ? i(e) : n(t);
              });
            });
          }(e, "r"), t;
        }

        return l(i, [{
          key: "fetchSlice",
          value: (r = u(x.mark(function e(t) {
            var r, n, i;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, this.openRequest;

                  case 2:
                    return r = e.sent, e.next = 5, kr(r, Buffer.alloc(t.length), 0, t.length, t.offset);

                  case 5:
                    return n = e.sent, i = n.buffer, e.abrupt("return", i.buffer);

                  case 8:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e) {
            return r.apply(this, arguments);
          })
        }, {
          key: "close",
          value: (t = u(x.mark(function e() {
            var t;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, this.openRequest;

                  case 2:
                    return t = e.sent, e.next = 5, br(t);

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), i;
      }(Je);

      function Ar(e) {
        return new xr(e);
      }

      function Pr(e, t) {
        var r = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];

        if (!r) {
          if (Array.isArray(e) || (r = function (e, t) {
            if (!e) return;
            if ("string" == typeof e) return _r(e, t);
            var r = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === r && e.constructor && (r = e.constructor.name);
            if ("Map" === r || "Set" === r) return Array.from(e);
            if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return _r(e, t);
          }(e)) || t && e && "number" == typeof e.length) {
            r && (e = r);

            var _n4 = 0,
                i = function i() {};

            return {
              s: i,
              n: function n() {
                return _n4 >= e.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: e[_n4++]
                };
              },
              e: function e(_e6) {
                throw _e6;
              },
              f: i
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        var a,
            o = !0,
            s = !1;
        return {
          s: function s() {
            r = r.call(e);
          },
          n: function n() {
            var e = r.next();
            return o = e.done, e;
          },
          e: function e(_e7) {
            s = !0, a = _e7;
          },
          f: function f() {
            try {
              o || null == r["return"] || r["return"]();
            } finally {
              if (s) throw a;
            }
          }
        };
      }

      function _r(e, t) {
        (null == t || t > e.length) && (t = e.length);

        for (var r = 0, n = new Array(t); r < t; r++) {
          n[r] = e[r];
        }

        return n;
      }

      var Ir = St(W),
          Sr = St(ue),
          Tr = {};
      _t(Tr, Ir), _t(Tr, Sr);
      var Ur = St(te),
          Or = 1e3,
          Dr = {
        nextZero: function nextZero(e, t) {
          for (var r = t; 0 !== e[r];) {
            r++;
          }

          return r;
        },
        readUshort: function readUshort(e, t) {
          return e[t] << 8 | e[t + 1];
        },
        readShort: function readShort(e, t) {
          var r = Dr.ui8;
          return r[0] = e[t + 1], r[1] = e[t + 0], Dr.i16[0];
        },
        readInt: function readInt(e, t) {
          var r = Dr.ui8;
          return r[0] = e[t + 3], r[1] = e[t + 2], r[2] = e[t + 1], r[3] = e[t + 0], Dr.i32[0];
        },
        readUint: function readUint(e, t) {
          var r = Dr.ui8;
          return r[0] = e[t + 3], r[1] = e[t + 2], r[2] = e[t + 1], r[3] = e[t + 0], Dr.ui32[0];
        },
        readASCII: function readASCII(e, t, r) {
          return r.map(function (r) {
            return String.fromCharCode(e[t + r]);
          }).join("");
        },
        readFloat: function readFloat(e, t) {
          var r = Dr.ui8;
          return Tt(4, function (n) {
            r[n] = e[t + 3 - n];
          }), Dr.fl32[0];
        },
        readDouble: function readDouble(e, t) {
          var r = Dr.ui8;
          return Tt(8, function (n) {
            r[n] = e[t + 7 - n];
          }), Dr.fl64[0];
        },
        writeUshort: function writeUshort(e, t, r) {
          e[t] = r >> 8 & 255, e[t + 1] = 255 & r;
        },
        writeUint: function writeUint(e, t, r) {
          e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = r >> 0 & 255;
        },
        writeASCII: function writeASCII(e, t, r) {
          Tt(r.length, function (n) {
            e[t + n] = r.charCodeAt(n);
          });
        },
        ui8: new Uint8Array(8)
      };
      Dr.fl64 = new Float64Array(Dr.ui8.buffer), Dr.writeDouble = function (e, t, r) {
        Dr.fl64[0] = r, Tt(8, function (r) {
          e[t + r] = Dr.ui8[7 - r];
        });
      };

      var Er = function Er(e) {
        var t = new Uint8Array(Or),
            r = 4,
            n = Dr;
        t[0] = 77, t[1] = 77, t[3] = 42;
        var i = 8;
        if (n.writeUint(t, r, i), r += 4, e.forEach(function (r, a) {
          var o = function (e, t, r, n) {
            var i = r,
                a = Object.keys(n).filter(function (e) {
              return null != e && "undefined" !== e;
            });
            e.writeUshort(t, i, a.length);
            var o,
                s = (i += 2) + 12 * a.length + 4,
                u = Pr(a);

            try {
              var f = function f() {
                var r = o.value,
                    a = null;
                "number" == typeof r ? a = r : "string" == typeof r && (a = parseInt(r, 10));
                var u = $[a],
                    f = Ur[u];
                if (null == u || void 0 === u || void 0 === u) throw new Error("unknown type of tag: ".concat(a));
                var l = n[r];
                if (void 0 === l) throw new Error("failed to get value for key ".concat(r));
                "ASCII" === u && "string" == typeof l && !1 === It(l, "\0") && (l += "\0");
                var c = l.length;
                e.writeUshort(t, i, a), i += 2, e.writeUshort(t, i, f), i += 2, e.writeUint(t, i, c);
                var h = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][f] * c,
                    d = i += 4;
                h > 4 && (e.writeUint(t, i, s), d = s), "ASCII" === u ? e.writeASCII(t, d, l) : "SHORT" === u ? Tt(c, function (r) {
                  e.writeUshort(t, d + 2 * r, l[r]);
                }) : "LONG" === u ? Tt(c, function (r) {
                  e.writeUint(t, d + 4 * r, l[r]);
                }) : "RATIONAL" === u ? Tt(c, function (r) {
                  e.writeUint(t, d + 8 * r, Math.round(1e4 * l[r])), e.writeUint(t, d + 8 * r + 4, 1e4);
                }) : "DOUBLE" === u && Tt(c, function (r) {
                  e.writeDouble(t, d + 8 * r, l[r]);
                }), h > 4 && (s += h += 1 & h), i += 4;
              };

              for (u.s(); !(o = u.n()).done;) {
                f();
              }
            } catch (e) {
              u.e(e);
            } finally {
              u.f();
            }

            return [i, s];
          }(n, t, i, r);

          i = o[1], a < e.length - 1 && n.writeUint(t, o[0], i);
        }), t.slice) return t.slice(0, i).buffer;

        for (var a = new Uint8Array(i), o = 0; o < i; o++) {
          a[o] = t[o];
        }

        return a.buffer;
      },
          Rr = [["Compression", 1], ["PlanarConfiguration", 1], ["ExtraSamples", 0]];

      function Mr(e, t) {
        var r, n, i, a;
        "number" == typeof e[0] ? (r = t.height || t.ImageLength, i = t.width || t.ImageWidth, n = e.length / (r * i), a = e) : (n = e.length, r = e[0].length, i = e[0][0].length, a = [], Tt(r, function (t) {
          Tt(i, function (r) {
            Tt(n, function (n) {
              a.push(e[n][t][r]);
            });
          });
        })), t.ImageLength = r, delete t.height, t.ImageWidth = i, delete t.width, t.BitsPerSample || (t.BitsPerSample = Tt(n, function () {
          return 8;
        })), Rr.forEach(function (e) {
          var r = e[0];

          if (!t[r]) {
            var n = e[1];
            t[r] = n;
          }
        }), t.PhotometricInterpretation || (t.PhotometricInterpretation = 3 === t.BitsPerSample.length ? 2 : 1), t.SamplesPerPixel || (t.SamplesPerPixel = [n]), t.StripByteCounts || (t.StripByteCounts = [n * r * i]), t.ModelPixelScale || (t.ModelPixelScale = [360 / i, 180 / r, 0]), t.SampleFormat || (t.SampleFormat = Tt(n, function () {
          return 1;
        })), t.hasOwnProperty("GeographicTypeGeoKey") || t.hasOwnProperty("ProjectedCSTypeGeoKey") || (t.GeographicTypeGeoKey = 4326, t.ModelTiepoint = [0, 0, 0, -180, 90, 0], t.GeogCitationGeoKey = "WGS 84", t.GTModelTypeGeoKey = 2);
        var o = Object.keys(t).filter(function (e) {
          return It(e, "GeoKey");
        }).sort(function (e, t) {
          return Tr[e] - Tr[t];
        });

        if (!t.GeoAsciiParams) {
          var s = "";
          o.forEach(function (e) {
            var r = Number(Tr[e]);
            "ASCII" === $[r] && (s += "".concat(t[e].toString(), "\0"));
          }), s.length > 0 && (t.GeoAsciiParams = s);
        }

        if (!t.GeoKeyDirectory) {
          var u = [1, 1, 0, o.length];
          o.forEach(function (e) {
            var r,
                n,
                i,
                a = Number(Tr[e]);
            u.push(a), "SHORT" === $[a] ? (r = 1, n = 0, i = t[e]) : "GeogCitationGeoKey" === e ? (r = t.GeoAsciiParams.length, n = Number(Tr.GeoAsciiParams), i = 0) : console.log("[geotiff.js] couldn't get TIFFTagLocation for ".concat(e)), u.push(n), u.push(r), u.push(i);
          }), t.GeoKeyDirectory = u;
        }

        for (var f in o) {
          o.hasOwnProperty(f) && delete t[f];
        }

        ["Compression", "ExtraSamples", "GeographicTypeGeoKey", "GTModelTypeGeoKey", "GTRasterTypeGeoKey", "ImageLength", "ImageWidth", "Orientation", "PhotometricInterpretation", "ProjectedCSTypeGeoKey", "PlanarConfiguration", "ResolutionUnit", "SamplesPerPixel", "XPosition", "YPosition"].forEach(function (e) {
          var r;
          t[e] && (t[e] = (r = t[e], Array.isArray(r) ? r : [r]));
        });

        var l = function (e) {
          var t = {};

          for (var r in e) {
            "StripOffsets" !== r && (Tr[r] || console.error(r, "not in name2code:", Object.keys(Tr)), t[Tr[r]] = e[r]);
          }

          return t;
        }(t),
            c = function (e, t, r, n) {
          if (null == r) throw new Error("you passed into encodeImage a width of type ".concat(r));
          if (null == t) throw new Error("you passed into encodeImage a width of type ".concat(t));
          var i = {
            256: [t],
            257: [r],
            273: [Or],
            278: [r],
            305: "geotiff.js"
          };
          if (n) for (var a in n) {
            n.hasOwnProperty(a) && (i[a] = n[a]);
          }
          var o = new Uint8Array(Er([i])),
              s = new Uint8Array(e),
              u = i[277],
              f = new Uint8Array(Or + t * r * u);
          return Tt(o.length, function (e) {
            f[e] = o[e];
          }), function (e, t) {
            for (var r = e.length, n = 0; n < r; n++) {
              t(e[n], n);
            }
          }(s, function (e, t) {
            f[Or + t] = e;
          }), f.buffer;
        }(a, i, r, l);

        return c;
      }

      var Br = function () {
        function e() {
          b(this, e);
        }

        return l(e, [{
          key: "log",
          value: function value() {}
        }, {
          key: "debug",
          value: function value() {}
        }, {
          key: "info",
          value: function value() {}
        }, {
          key: "warn",
          value: function value() {}
        }, {
          key: "error",
          value: function value() {}
        }, {
          key: "time",
          value: function value() {}
        }, {
          key: "timeEnd",
          value: function value() {}
        }]), e;
      }();

      function Cr(e, t) {
        var r = Object.keys(e);

        if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(e);
          t && (n = n.filter(function (t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable;
          })), r.push.apply(r, n);
        }

        return r;
      }

      function Lr(e) {
        for (var r = 1; r < arguments.length; r++) {
          var n = null != arguments[r] ? arguments[r] : {};
          r % 2 ? Cr(Object(n), !0).forEach(function (r) {
            t(e, r, n[r]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Cr(Object(n)).forEach(function (t) {
            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));
          });
        }

        return e;
      }

      function Fr(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      function Vr(e) {
        switch (e) {
          case re.BYTE:
          case re.ASCII:
          case re.SBYTE:
          case re.UNDEFINED:
            return 1;

          case re.SHORT:
          case re.SSHORT:
            return 2;

          case re.LONG:
          case re.SLONG:
          case re.FLOAT:
          case re.IFD:
            return 4;

          case re.RATIONAL:
          case re.SRATIONAL:
          case re.DOUBLE:
          case re.LONG8:
          case re.SLONG8:
          case re.IFD8:
            return 8;

          default:
            throw new RangeError("Invalid field type: ".concat(e));
        }
      }

      function Gr(e) {
        var t = e.GeoKeyDirectory;
        if (!t) return null;

        for (var r = {}, n = 4; n <= 4 * t[3]; n += 4) {
          var i = ue[t[n]],
              a = t[n + 1] ? W[t[n + 1]] : null,
              o = t[n + 2],
              s = t[n + 3],
              u = null;

          if (a) {
            if (null == (u = e[a])) throw new Error("Could not get value of geoKey '".concat(i, "'."));
            "string" == typeof u ? u = u.substring(s, s + o - 1) : u.subarray && (u = u.subarray(s, s + o), 1 === o && (u = u[0]));
          } else u = s;

          r[i] = u;
        }

        return r;
      }

      function jr(e, t, r, n) {
        var i = null,
            a = null,
            o = Vr(t);

        switch (t) {
          case re.BYTE:
          case re.ASCII:
          case re.UNDEFINED:
            i = new Uint8Array(r), a = e.readUint8;
            break;

          case re.SBYTE:
            i = new Int8Array(r), a = e.readInt8;
            break;

          case re.SHORT:
            i = new Uint16Array(r), a = e.readUint16;
            break;

          case re.SSHORT:
            i = new Int16Array(r), a = e.readInt16;
            break;

          case re.LONG:
          case re.IFD:
            i = new Uint32Array(r), a = e.readUint32;
            break;

          case re.SLONG:
            i = new Int32Array(r), a = e.readInt32;
            break;

          case re.LONG8:
          case re.IFD8:
            i = new Array(r), a = e.readUint64;
            break;

          case re.SLONG8:
            i = new Array(r), a = e.readInt64;
            break;

          case re.RATIONAL:
            i = new Uint32Array(2 * r), a = e.readUint32;
            break;

          case re.SRATIONAL:
            i = new Int32Array(2 * r), a = e.readInt32;
            break;

          case re.FLOAT:
            i = new Float32Array(r), a = e.readFloat32;
            break;

          case re.DOUBLE:
            i = new Float64Array(r), a = e.readFloat64;
            break;

          default:
            throw new RangeError("Invalid field type: ".concat(t));
        }

        if (t !== re.RATIONAL && t !== re.SRATIONAL) for (var s = 0; s < r; ++s) {
          i[s] = a.call(e, n + s * o);
        } else for (var u = 0; u < r; u += 2) {
          i[u] = a.call(e, n + u * o), i[u + 1] = a.call(e, n + (u * o + 4));
        }
        return t === re.ASCII ? new TextDecoder("utf-8").decode(i) : i;
      }

      new Br();

      var Nr = function e(t, r, n) {
        b(this, e), this.fileDirectory = t, this.geoKeyDirectory = r, this.nextIFDByteOffset = n;
      },
          zr = function (e) {
        h(r, e);
        var t = Fr(r);

        function r(e) {
          var n;
          return b(this, r), (n = t.call(this, "No image at index ".concat(e))).index = e, n;
        }

        return r;
      }(w(Error)),
          Kr = function () {
        function e() {
          b(this, e);
        }

        var t;
        return l(e, [{
          key: "readRasters",
          value: (t = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                s,
                u,
                f,
                l,
                c,
                h,
                d,
                p,
                v,
                m,
                g,
                y,
                w,
                b,
                k,
                A,
                P,
                _,
                I,
                S,
                T,
                U,
                O,
                D,
                E,
                R,
                M,
                B,
                C,
                L,
                F,
                V,
                G,
                j,
                N = arguments;

            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = N.length > 0 && void 0 !== N[0] ? N[0] : {}, r = t.window, n = t.width, i = t.height, a = t.resX, s = t.resY, u = t.bbox, e.next = 5, this.getImage();

                  case 5:
                    return f = e.sent, l = f, e.next = 9, this.getImageCount();

                  case 9:
                    if (c = e.sent, h = f.getBoundingBox(), !r || !u) {
                      e.next = 13;
                      break;
                    }

                    throw new Error('Both "bbox" and "window" passed.');

                  case 13:
                    if (!n && !i) {
                      e.next = 24;
                      break;
                    }

                    if (r && (d = f.getOrigin(), p = o(d, 2), v = p[0], m = p[1], g = f.getResolution(), y = o(g, 2), w = y[0], b = y[1], u = [v + r[0] * w, m + r[1] * b, v + r[2] * w, m + r[3] * b]), k = u || h, !n) {
                      e.next = 20;
                      break;
                    }

                    if (!a) {
                      e.next = 19;
                      break;
                    }

                    throw new Error("Both width and resX passed");

                  case 19:
                    a = (k[2] - k[0]) / n;

                  case 20:
                    if (!i) {
                      e.next = 24;
                      break;
                    }

                    if (!s) {
                      e.next = 23;
                      break;
                    }

                    throw new Error("Both width and resY passed");

                  case 23:
                    s = (k[3] - k[1]) / i;

                  case 24:
                    if (!a && !s) {
                      e.next = 48;
                      break;
                    }

                    A = [], P = 0;

                  case 27:
                    if (!(P < c)) {
                      e.next = 36;
                      break;
                    }

                    return e.next = 30, this.getImage(P);

                  case 30:
                    _ = e.sent, I = _.fileDirectory, S = I.SubfileType, T = I.NewSubfileType, (0 === P || 2 === S || 1 & T) && A.push(_);

                  case 33:
                    ++P, e.next = 27;
                    break;

                  case 36:
                    A.sort(function (e, t) {
                      return e.getWidth() - t.getWidth();
                    }), U = 0;

                  case 38:
                    if (!(U < A.length)) {
                      e.next = 48;
                      break;
                    }

                    if (O = A[U], D = (h[2] - h[0]) / O.getWidth(), E = (h[3] - h[1]) / O.getHeight(), l = O, !(a && a > D || s && s > E)) {
                      e.next = 45;
                      break;
                    }

                    return e.abrupt("break", 48);

                  case 45:
                    ++U, e.next = 38;
                    break;

                  case 48:
                    return R = r, u && (M = f.getOrigin(), B = o(M, 2), C = B[0], L = B[1], F = l.getResolution(f), V = o(F, 2), G = V[0], j = V[1], R = [Math.round((u[0] - C) / G), Math.round((u[1] - L) / j), Math.round((u[2] - C) / G), Math.round((u[3] - L) / j)], R = [Math.min(R[0], R[2]), Math.min(R[1], R[3]), Math.max(R[0], R[2]), Math.max(R[1], R[3])]), e.abrupt("return", l.readRasters(Lr(Lr({}, t), {}, {
                      window: R
                    })));

                  case 51:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), e;
      }(),
          Zr = function (e) {
        h(d, e);
        var t,
            r,
            n,
            i,
            a,
            s,
            f,
            c = Fr(d);

        function d(e, t, r, n) {
          var i,
              a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {};
          return b(this, d), (i = c.call(this)).source = e, i.littleEndian = t, i.bigTiff = r, i.firstIFDOffset = n, i.cache = a.cache || !1, i.ifdRequests = [], i.ghostValues = null, i;
        }

        return l(d, [{
          key: "getSlice",
          value: (f = u(x.mark(function e(t, r) {
            var n;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return n = this.bigTiff ? 4048 : 1024, e.t0 = Fe, e.next = 4, this.source.fetch([{
                      offset: t,
                      length: void 0 !== r ? r : n
                    }]);

                  case 4:
                    return e.t1 = e.sent[0], e.t2 = t, e.t3 = this.littleEndian, e.t4 = this.bigTiff, e.abrupt("return", new e.t0(e.t1, e.t2, e.t3, e.t4));

                  case 9:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, t) {
            return f.apply(this, arguments);
          })
        }, {
          key: "parseFileDirectoryAt",
          value: (s = u(x.mark(function e(t) {
            var r, n, i, a, o, s, u, f, l, c, h, d, p, v, m, g, y, w, b, k;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return r = this.bigTiff ? 20 : 12, n = this.bigTiff ? 8 : 2, e.next = 4, this.getSlice(t);

                  case 4:
                    if (i = e.sent, a = this.bigTiff ? i.readUint64(t) : i.readUint16(t), o = a * r + (this.bigTiff ? 16 : 6), i.covers(t, o)) {
                      e.next = 11;
                      break;
                    }

                    return e.next = 10, this.getSlice(t, o);

                  case 10:
                    i = e.sent;

                  case 11:
                    s = {}, u = t + (this.bigTiff ? 8 : 2), f = 0;

                  case 14:
                    if (!(f < a)) {
                      e.next = 41;
                      break;
                    }

                    if (l = i.readUint16(u), c = i.readUint16(u + 2), h = this.bigTiff ? i.readUint64(u + 4) : i.readUint32(u + 4), d = void 0, p = void 0, v = Vr(c), m = u + (this.bigTiff ? 12 : 8), !(v * h <= (this.bigTiff ? 8 : 4))) {
                      e.next = 26;
                      break;
                    }

                    d = jr(i, c, h, m), e.next = 36;
                    break;

                  case 26:
                    if (g = i.readOffset(m), y = Vr(c) * h, !i.covers(g, y)) {
                      e.next = 32;
                      break;
                    }

                    d = jr(i, c, h, g), e.next = 36;
                    break;

                  case 32:
                    return e.next = 34, this.getSlice(g, y);

                  case 34:
                    w = e.sent, d = jr(w, c, h, g);

                  case 36:
                    p = 1 === h && -1 === ee.indexOf(l) && c !== re.RATIONAL && c !== re.SRATIONAL ? d[0] : d, s[W[l]] = p;

                  case 38:
                    u += r, ++f, e.next = 14;
                    break;

                  case 41:
                    return b = Gr(s), k = i.readOffset(t + n + r * a), e.abrupt("return", new Nr(s, b, k));

                  case 44:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e) {
            return s.apply(this, arguments);
          })
        }, {
          key: "requestIFD",
          value: (a = u(x.mark(function e(t) {
            var r = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (!this.ifdRequests[t]) {
                      e.next = 4;
                      break;
                    }

                    return e.abrupt("return", this.ifdRequests[t]);

                  case 4:
                    if (0 !== t) {
                      e.next = 9;
                      break;
                    }

                    return this.ifdRequests[t] = this.parseFileDirectoryAt(this.firstIFDOffset), e.abrupt("return", this.ifdRequests[t]);

                  case 9:
                    if (this.ifdRequests[t - 1]) {
                      e.next = 19;
                      break;
                    }

                    e.prev = 10, this.ifdRequests[t - 1] = this.requestIFD(t - 1), e.next = 19;
                    break;

                  case 14:
                    if (e.prev = 14, e.t0 = e["catch"](10), !(e.t0 instanceof zr)) {
                      e.next = 18;
                      break;
                    }

                    throw new zr(t);

                  case 18:
                    throw e.t0;

                  case 19:
                    return this.ifdRequests[t] = u(x.mark(function e() {
                      var n;
                      return x.wrap(function (e) {
                        for (;;) {
                          switch (e.prev = e.next) {
                            case 0:
                              return e.next = 2, r.ifdRequests[t - 1];

                            case 2:
                              if (0 !== (n = e.sent).nextIFDByteOffset) {
                                e.next = 5;
                                break;
                              }

                              throw new zr(t);

                            case 5:
                              return e.abrupt("return", r.parseFileDirectoryAt(n.nextIFDByteOffset));

                            case 6:
                            case "end":
                              return e.stop();
                          }
                        }
                      }, e);
                    }))(), e.abrupt("return", this.ifdRequests[t]);

                  case 21:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this, [[10, 14]]);
          })), function (e) {
            return a.apply(this, arguments);
          })
        }, {
          key: "getImage",
          value: (i = u(x.mark(function e() {
            var t,
                r,
                n = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = n.length > 0 && void 0 !== n[0] ? n[0] : 0, e.next = 3, this.requestIFD(t);

                  case 3:
                    return r = e.sent, e.abrupt("return", new Ce(r.fileDirectory, r.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source));

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return i.apply(this, arguments);
          })
        }, {
          key: "getImageCount",
          value: (n = u(x.mark(function e() {
            var t, r;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    t = 0, r = !0;

                  case 2:
                    if (!r) {
                      e.next = 18;
                      break;
                    }

                    return e.prev = 3, e.next = 6, this.requestIFD(t);

                  case 6:
                    ++t, e.next = 16;
                    break;

                  case 9:
                    if (e.prev = 9, e.t0 = e["catch"](3), !(e.t0 instanceof zr)) {
                      e.next = 15;
                      break;
                    }

                    r = !1, e.next = 16;
                    break;

                  case 15:
                    throw e.t0;

                  case 16:
                    e.next = 2;
                    break;

                  case 18:
                    return e.abrupt("return", t);

                  case 19:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this, [[3, 9]]);
          })), function () {
            return n.apply(this, arguments);
          })
        }, {
          key: "getGhostValues",
          value: (r = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                s,
                u,
                f,
                l = this;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (t = this.bigTiff ? 16 : 8, !this.ghostValues) {
                      e.next = 3;
                      break;
                    }

                    return e.abrupt("return", this.ghostValues);

                  case 3:
                    return n = (r = "GDAL_STRUCTURAL_METADATA_SIZE=").length + 100, e.next = 7, this.getSlice(t, n);

                  case 7:
                    if (i = e.sent, r !== jr(i, re.ASCII, r.length, t)) {
                      e.next = 19;
                      break;
                    }

                    if (a = jr(i, re.ASCII, n, t), s = a.split("\n")[0], !((u = Number(s.split("=")[1].split(" ")[0]) + s.length) > n)) {
                      e.next = 16;
                      break;
                    }

                    return e.next = 15, this.getSlice(t, u);

                  case 15:
                    i = e.sent;

                  case 16:
                    f = jr(i, re.ASCII, u, t), this.ghostValues = {}, f.split("\n").filter(function (e) {
                      return e.length > 0;
                    }).map(function (e) {
                      return e.split("=");
                    }).forEach(function (e) {
                      var t = o(e, 2),
                          r = t[0],
                          n = t[1];
                      l.ghostValues[r] = n;
                    });

                  case 19:
                    return e.abrupt("return", this.ghostValues);

                  case 20:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return r.apply(this, arguments);
          })
        }, {
          key: "close",
          value: function value() {
            return "function" == typeof this.source.close && this.source.close();
          }
        }], [{
          key: "fromSource",
          value: (t = u(x.mark(function e(t, r, n) {
            var i, a, o, s, u, f, l;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, t.fetch([{
                      offset: 0,
                      length: 1024
                    }], n);

                  case 2:
                    if (i = e.sent[0], a = new Le(i), 18761 !== (o = a.getUint16(0, 0))) {
                      e.next = 9;
                      break;
                    }

                    s = !0, e.next = 14;
                    break;

                  case 9:
                    if (19789 !== o) {
                      e.next = 13;
                      break;
                    }

                    s = !1, e.next = 14;
                    break;

                  case 13:
                    throw new TypeError("Invalid byte order value.");

                  case 14:
                    if (42 !== (u = a.getUint16(2, s))) {
                      e.next = 19;
                      break;
                    }

                    f = !1, e.next = 27;
                    break;

                  case 19:
                    if (43 !== u) {
                      e.next = 26;
                      break;
                    }

                    if (f = !0, 8 === a.getUint16(4, s)) {
                      e.next = 24;
                      break;
                    }

                    throw new Error("Unsupported offset byte-size.");

                  case 24:
                    e.next = 27;
                    break;

                  case 26:
                    throw new TypeError("Invalid magic number.");

                  case 27:
                    return l = f ? a.getUint64(8, s) : a.getUint32(4, s), e.abrupt("return", new d(t, s, f, l, r));

                  case 29:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function (e, r, n) {
            return t.apply(this, arguments);
          })
        }]), d;
      }(Kr),
          Hr = function (e) {
        h(a, e);
        var t,
            r,
            n,
            i = Fr(a);

        function a(e, t) {
          var r;
          return b(this, a), (r = i.call(this)).mainFile = e, r.overviewFiles = t, r.imageFiles = [e].concat(t), r.fileDirectoriesPerFile = null, r.fileDirectoriesPerFileParsing = null, r.imageCount = null, r;
        }

        return l(a, [{
          key: "parseFileDirectoriesPerFile",
          value: (n = u(x.mark(function e() {
            var t;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(function (e) {
                      return e.parseFileDirectoryAt(e.firstIFDOffset);
                    })), e.next = 3, Promise.all(t);

                  case 3:
                    return this.fileDirectoriesPerFile = e.sent, e.abrupt("return", this.fileDirectoriesPerFile);

                  case 5:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return n.apply(this, arguments);
          })
        }, {
          key: "getImage",
          value: (r = u(x.mark(function e() {
            var t,
                r,
                n,
                i,
                a,
                o,
                s,
                u = arguments;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return t = u.length > 0 && void 0 !== u[0] ? u[0] : 0, e.next = 3, this.getImageCount();

                  case 3:
                    return e.next = 5, this.parseFileDirectoriesPerFile();

                  case 5:
                    r = 0, n = 0, i = 0;

                  case 8:
                    if (!(i < this.imageFiles.length)) {
                      e.next = 26;
                      break;
                    }

                    a = this.imageFiles[i], o = 0;

                  case 11:
                    if (!(o < this.imageCounts[i])) {
                      e.next = 22;
                      break;
                    }

                    if (t !== r) {
                      e.next = 17;
                      break;
                    }

                    return e.next = 15, a.requestIFD(n);

                  case 15:
                    return s = e.sent, e.abrupt("return", new Ce(s.fileDirectory, s.geoKeyDirectory, a.dataView, a.littleEndian, a.cache, a.source));

                  case 17:
                    r++, n++;

                  case 19:
                    o++, e.next = 11;
                    break;

                  case 22:
                    n = 0;

                  case 23:
                    i++, e.next = 8;
                    break;

                  case 26:
                    throw new RangeError("Invalid image index");

                  case 27:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return r.apply(this, arguments);
          })
        }, {
          key: "getImageCount",
          value: (t = u(x.mark(function e() {
            var t;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    if (null === this.imageCount) {
                      e.next = 2;
                      break;
                    }

                    return e.abrupt("return", this.imageCount);

                  case 2:
                    return t = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(function (e) {
                      return e.getImageCount();
                    })), e.next = 5, Promise.all(t);

                  case 5:
                    return this.imageCounts = e.sent, this.imageCount = this.imageCounts.reduce(function (e, t) {
                      return e + t;
                    }, 0), e.abrupt("return", this.imageCount);

                  case 8:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function () {
            return t.apply(this, arguments);
          })
        }]), a;
      }(Kr);

      function Yr() {
        return Yr = u(x.mark(function e(t) {
          var r,
              n,
              i = arguments;
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return r = i.length > 1 && void 0 !== i[1] ? i[1] : {}, n = i.length > 2 ? i[2] : void 0, e.abrupt("return", Zr.fromSource(hr(t, r), n));

                case 3:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        })), Yr.apply(this, arguments);
      }

      function qr() {
        return (qr = u(x.mark(function e(t, r) {
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return e.abrupt("return", Zr.fromSource(vr(t), r));

                case 1:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))).apply(this, arguments);
      }

      function Xr() {
        return (Xr = u(x.mark(function e(t, r) {
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return e.abrupt("return", Zr.fromSource(Ar(t), r));

                case 1:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))).apply(this, arguments);
      }

      function Wr() {
        return (Wr = u(x.mark(function e(t, r) {
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return e.abrupt("return", Zr.fromSource(yr(t), r));

                case 1:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        }))).apply(this, arguments);
      }

      function Jr() {
        return Jr = u(x.mark(function e(t) {
          var r,
              n,
              i,
              a,
              o,
              s = arguments;
          return x.wrap(function (e) {
            for (;;) {
              switch (e.prev = e.next) {
                case 0:
                  return r = s.length > 1 && void 0 !== s[1] ? s[1] : [], n = s.length > 2 && void 0 !== s[2] ? s[2] : {}, i = s.length > 3 ? s[3] : void 0, e.next = 5, Zr.fromSource(hr(t, n), i);

                case 5:
                  return a = e.sent, e.next = 8, Promise.all(r.map(function (e) {
                    return Zr.fromSource(hr(e, n));
                  }));

                case 8:
                  return o = e.sent, e.abrupt("return", new Hr(a, o));

                case 10:
                case "end":
                  return e.stop();
              }
            }
          }, e);
        })), Jr.apply(this, arguments);
      }

      function Qr(e, t) {
        var r = e.length - t,
            n = 0;

        do {
          for (var i = t; i > 0; i--) {
            e[n + t] += e[n], n++;
          }

          r -= t;
        } while (r > 0);
      }

      function $r(e, t, r) {
        for (var n = 0, i = e.length, a = i / r; i > t;) {
          for (var o = t; o > 0; --o) {
            e[n + t] += e[n], ++n;
          }

          i -= t;
        }

        for (var s = e.slice(), u = 0; u < a; ++u) {
          for (var f = 0; f < r; ++f) {
            e[r * u + f] = s[(r - f - 1) * a + u];
          }
        }
      }

      function en(e, t, r, n, i, a) {
        if (!t || 1 === t) return e;

        for (var o = 0; o < i.length; ++o) {
          if (i[o] % 8 != 0) throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");
          if (i[o] !== i[0]) throw new Error("When decoding with predictor, all samples must have the same size.");
        }

        for (var s = i[0] / 8, u = 2 === a ? 1 : i.length, f = 0; f < n && !(f * u * r * s >= e.byteLength); ++f) {
          var l = void 0;

          if (2 === t) {
            switch (i[0]) {
              case 8:
                l = new Uint8Array(e, f * u * r * s, u * r * s);
                break;

              case 16:
                l = new Uint16Array(e, f * u * r * s, u * r * s / 2);
                break;

              case 32:
                l = new Uint32Array(e, f * u * r * s, u * r * s / 4);
                break;

              default:
                throw new Error("Predictor 2 not allowed with ".concat(i[0], " bits per sample."));
            }

            Qr(l, u);
          } else 3 === t && $r(l = new Uint8Array(e, f * u * r * s, u * r * s), u, s);
        }

        return e;
      }

      var tn = function () {
        function e() {
          b(this, e);
        }

        var t;
        return l(e, [{
          key: "decode",
          value: (t = u(x.mark(function e(t, r) {
            var n, i, a, o, s;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return e.next = 2, this.decodeBlock(r);

                  case 2:
                    if (n = e.sent, 1 === (i = t.Predictor || 1)) {
                      e.next = 9;
                      break;
                    }

                    return a = !t.StripOffsets, o = a ? t.TileWidth : t.ImageWidth, s = a ? t.TileLength : t.RowsPerStrip || t.ImageLength, e.abrupt("return", en(n, i, o, s, t.BitsPerSample, t.PlanarConfiguration));

                  case 9:
                    return e.abrupt("return", n);

                  case 10:
                  case "end":
                    return e.stop();
                }
              }
            }, e, this);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }]), e;
      }();

      function rn(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var nn = function (e) {
        h(r, e);
        var t = rn(r);

        function r() {
          return b(this, r), t.apply(this, arguments);
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            return e;
          }
        }]), r;
      }(tn),
          an = Object.freeze({
        __proto__: null,
        "default": nn
      });

      function on(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      function sn(e, t) {
        for (var r = t.length - 1; r >= 0; r--) {
          e.push(t[r]);
        }

        return e;
      }

      function un(e) {
        for (var t = new Uint16Array(4093), r = new Uint8Array(4093), n = 0; n <= 257; n++) {
          t[n] = 4096, r[n] = n;
        }

        var i = 258,
            a = 9,
            o = 0;

        function s() {
          i = 258, a = 9;
        }

        function u(e) {
          var t = function (e, t, r) {
            var n = t % 8,
                i = Math.floor(t / 8),
                a = 8 - n,
                o = t + r - 8 * (i + 1),
                s = 8 * (i + 2) - (t + r),
                u = 8 * (i + 2) - t;
            if (s = Math.max(0, s), i >= e.length) return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"), 257;
            var f = e[i] & Math.pow(2, 8 - n) - 1,
                l = f <<= r - a;

            if (i + 1 < e.length) {
              var c = e[i + 1] >>> s;
              l += c <<= Math.max(0, r - u);
            }

            if (o > 8 && i + 2 < e.length) {
              var h = 8 * (i + 3) - (t + r);
              l += e[i + 2] >>> h;
            }

            return l;
          }(e, o, a);

          return o += a, t;
        }

        function f(e, n) {
          return r[i] = n, t[i] = e, ++i - 1;
        }

        function l(e) {
          for (var n = [], i = e; 4096 !== i; i = t[i]) {
            n.push(r[i]);
          }

          return n;
        }

        var c = [];
        s();

        for (var h, d = new Uint8Array(e), p = u(d); 257 !== p;) {
          if (256 === p) {
            for (s(), p = u(d); 256 === p;) {
              p = u(d);
            }

            if (257 === p) break;
            if (p > 256) throw new Error("corrupted code at scanline ".concat(p));
            sn(c, l(p)), h = p;
          } else if (p < i) {
            var v = l(p);
            sn(c, v), f(h, v[v.length - 1]), h = p;
          } else {
            var m = l(h);
            if (!m) throw new Error("Bogus entry. Not in dictionary, ".concat(h, " / ").concat(i, ", position: ").concat(o));
            sn(c, m), c.push(m[m.length - 1]), f(h, m[m.length - 1]), h = p;
          }

          i + 1 >= Math.pow(2, a) && (12 === a ? h = void 0 : a++), p = u(d);
        }

        return new Uint8Array(c);
      }

      var fn = function (e) {
        h(r, e);
        var t = on(r);

        function r() {
          return b(this, r), t.apply(this, arguments);
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            return un(e).buffer;
          }
        }]), r;
      }(tn),
          ln = Object.freeze({
        __proto__: null,
        "default": fn
      });

      function cn(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var hn = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]),
          dn = 4017,
          pn = 799,
          vn = 3406,
          mn = 2276,
          gn = 1567,
          yn = 3784,
          wn = 5793,
          bn = 2896;

      function kn(e, t) {
        for (var r = 0, n = [], i = 16; i > 0 && !e[i - 1];) {
          --i;
        }

        n.push({
          children: [],
          index: 0
        });

        for (var a, o = n[0], s = 0; s < i; s++) {
          for (var u = 0; u < e[s]; u++) {
            for ((o = n.pop()).children[o.index] = t[r]; o.index > 0;) {
              o = n.pop();
            }

            for (o.index++, n.push(o); n.length <= s;) {
              n.push(a = {
                children: [],
                index: 0
              }), o.children[o.index] = a.children, o = a;
            }

            r++;
          }

          s + 1 < i && (n.push(a = {
            children: [],
            index: 0
          }), o.children[o.index] = a.children, o = a);
        }

        return n[0].children;
      }

      function xn(e, t, r, n, i, a, o, s, u) {
        var f = r.mcusPerLine,
            l = r.progressive,
            c = t,
            h = t,
            p = 0,
            v = 0;

        function m() {
          if (v > 0) return v--, p >> v & 1;

          if (255 === (p = e[h++])) {
            var t = e[h++];
            if (t) throw new Error("unexpected marker: ".concat((p << 8 | t).toString(16)));
          }

          return v = 7, p >>> 7;
        }

        function g(e) {
          for (var t, r = e; null !== (t = m());) {
            if ("number" == typeof (r = r[t])) return r;
            if ("object" !== d(r)) throw new Error("invalid huffman sequence");
          }

          return null;
        }

        function y(e) {
          for (var t = e, r = 0; t > 0;) {
            var n = m();
            if (null === n) return;
            r = r << 1 | n, --t;
          }

          return r;
        }

        function w(e) {
          var t = y(e);
          return t >= 1 << e - 1 ? t : t + (-1 << e) + 1;
        }

        var b = 0;
        var k,
            x = 0;

        function A(e, t, r, n, i) {
          var a = r % f,
              o = (r / f | 0) * e.v + n,
              s = a * e.h + i;
          t(e, e.blocks[o][s]);
        }

        function P(e, t, r) {
          var n = r / e.blocksPerLine | 0,
              i = r % e.blocksPerLine;
          t(e, e.blocks[n][i]);
        }

        var _,
            I,
            S,
            T,
            U,
            O,
            D = n.length;

        O = l ? 0 === a ? 0 === s ? function (e, t) {
          var r = g(e.huffmanTableDC),
              n = 0 === r ? 0 : w(r) << u;
          e.pred += n, t[0] = e.pred;
        } : function (e, t) {
          t[0] |= m() << u;
        } : 0 === s ? function (e, t) {
          if (b > 0) b--;else for (var r = a, n = o; r <= n;) {
            var i = g(e.huffmanTableAC),
                s = 15 & i,
                f = i >> 4;

            if (0 === s) {
              if (f < 15) {
                b = y(f) + (1 << f) - 1;
                break;
              }

              r += 16;
            } else t[hn[r += f]] = w(s) * (1 << u), r++;
          }
        } : function (e, t) {
          for (var r = a, n = o, i = 0; r <= n;) {
            var s = hn[r],
                f = t[s] < 0 ? -1 : 1;

            switch (x) {
              case 0:
                var l = g(e.huffmanTableAC),
                    c = 15 & l;
                if (i = l >> 4, 0 === c) i < 15 ? (b = y(i) + (1 << i), x = 4) : (i = 16, x = 1);else {
                  if (1 !== c) throw new Error("invalid ACn encoding");
                  k = w(c), x = i ? 2 : 3;
                }
                continue;

              case 1:
              case 2:
                t[s] ? t[s] += (m() << u) * f : 0 == --i && (x = 2 === x ? 3 : 0);
                break;

              case 3:
                t[s] ? t[s] += (m() << u) * f : (t[s] = k << u, x = 0);
                break;

              case 4:
                t[s] && (t[s] += (m() << u) * f);
            }

            r++;
          }

          4 === x && 0 == --b && (x = 0);
        } : function (e, t) {
          var r = g(e.huffmanTableDC),
              n = 0 === r ? 0 : w(r);
          e.pred += n, t[0] = e.pred;

          for (var i = 1; i < 64;) {
            var a = g(e.huffmanTableAC),
                o = 15 & a,
                s = a >> 4;

            if (0 === o) {
              if (s < 15) break;
              i += 16;
            } else t[hn[i += s]] = w(o), i++;
          }
        };
        var E,
            R,
            M = 0;
        R = 1 === D ? n[0].blocksPerLine * n[0].blocksPerColumn : f * r.mcusPerColumn;

        for (var B = i || R; M < R;) {
          for (I = 0; I < D; I++) {
            n[I].pred = 0;
          }

          if (b = 0, 1 === D) for (_ = n[0], U = 0; U < B; U++) {
            P(_, O, M), M++;
          } else for (U = 0; U < B; U++) {
            for (I = 0; I < D; I++) {
              var C = _ = n[I],
                  L = C.h,
                  F = C.v;

              for (S = 0; S < F; S++) {
                for (T = 0; T < L; T++) {
                  A(_, O, M, S, T);
                }
              }
            }

            if (++M === R) break;
          }
          if (v = 0, (E = e[h] << 8 | e[h + 1]) < 65280) throw new Error("marker was not found");
          if (!(E >= 65488 && E <= 65495)) break;
          h += 2;
        }

        return h - c;
      }

      function An(e, t) {
        var r = [],
            n = t.blocksPerLine,
            i = t.blocksPerColumn,
            a = n << 3,
            o = new Int32Array(64),
            s = new Uint8Array(64);

        function u(e, r, n) {
          var i,
              a,
              o,
              s,
              u,
              f,
              l,
              c,
              h,
              d,
              p = t.quantizationTable,
              v = n;

          for (d = 0; d < 64; d++) {
            v[d] = e[d] * p[d];
          }

          for (d = 0; d < 8; ++d) {
            var m = 8 * d;
            0 !== v[1 + m] || 0 !== v[2 + m] || 0 !== v[3 + m] || 0 !== v[4 + m] || 0 !== v[5 + m] || 0 !== v[6 + m] || 0 !== v[7 + m] ? (i = wn * v[0 + m] + 128 >> 8, a = wn * v[4 + m] + 128 >> 8, o = v[2 + m], s = v[6 + m], u = bn * (v[1 + m] - v[7 + m]) + 128 >> 8, c = bn * (v[1 + m] + v[7 + m]) + 128 >> 8, f = v[3 + m] << 4, l = v[5 + m] << 4, h = i - a + 1 >> 1, i = i + a + 1 >> 1, a = h, h = o * yn + s * gn + 128 >> 8, o = o * gn - s * yn + 128 >> 8, s = h, h = u - l + 1 >> 1, u = u + l + 1 >> 1, l = h, h = c + f + 1 >> 1, f = c - f + 1 >> 1, c = h, h = i - s + 1 >> 1, i = i + s + 1 >> 1, s = h, h = a - o + 1 >> 1, a = a + o + 1 >> 1, o = h, h = u * mn + c * vn + 2048 >> 12, u = u * vn - c * mn + 2048 >> 12, c = h, h = f * pn + l * dn + 2048 >> 12, f = f * dn - l * pn + 2048 >> 12, l = h, v[0 + m] = i + c, v[7 + m] = i - c, v[1 + m] = a + l, v[6 + m] = a - l, v[2 + m] = o + f, v[5 + m] = o - f, v[3 + m] = s + u, v[4 + m] = s - u) : (h = wn * v[0 + m] + 512 >> 10, v[0 + m] = h, v[1 + m] = h, v[2 + m] = h, v[3 + m] = h, v[4 + m] = h, v[5 + m] = h, v[6 + m] = h, v[7 + m] = h);
          }

          for (d = 0; d < 8; ++d) {
            var g = d;
            0 !== v[8 + g] || 0 !== v[16 + g] || 0 !== v[24 + g] || 0 !== v[32 + g] || 0 !== v[40 + g] || 0 !== v[48 + g] || 0 !== v[56 + g] ? (i = wn * v[0 + g] + 2048 >> 12, a = wn * v[32 + g] + 2048 >> 12, o = v[16 + g], s = v[48 + g], u = bn * (v[8 + g] - v[56 + g]) + 2048 >> 12, c = bn * (v[8 + g] + v[56 + g]) + 2048 >> 12, f = v[24 + g], l = v[40 + g], h = i - a + 1 >> 1, i = i + a + 1 >> 1, a = h, h = o * yn + s * gn + 2048 >> 12, o = o * gn - s * yn + 2048 >> 12, s = h, h = u - l + 1 >> 1, u = u + l + 1 >> 1, l = h, h = c + f + 1 >> 1, f = c - f + 1 >> 1, c = h, h = i - s + 1 >> 1, i = i + s + 1 >> 1, s = h, h = a - o + 1 >> 1, a = a + o + 1 >> 1, o = h, h = u * mn + c * vn + 2048 >> 12, u = u * vn - c * mn + 2048 >> 12, c = h, h = f * pn + l * dn + 2048 >> 12, f = f * dn - l * pn + 2048 >> 12, l = h, v[0 + g] = i + c, v[56 + g] = i - c, v[8 + g] = a + l, v[48 + g] = a - l, v[16 + g] = o + f, v[40 + g] = o - f, v[24 + g] = s + u, v[32 + g] = s - u) : (h = wn * n[d + 0] + 8192 >> 14, v[0 + g] = h, v[8 + g] = h, v[16 + g] = h, v[24 + g] = h, v[32 + g] = h, v[40 + g] = h, v[48 + g] = h, v[56 + g] = h);
          }

          for (d = 0; d < 64; ++d) {
            var y = 128 + (v[d] + 8 >> 4);
            r[d] = y < 0 ? 0 : y > 255 ? 255 : y;
          }
        }

        for (var f = 0; f < i; f++) {
          for (var l = f << 3, c = 0; c < 8; c++) {
            r.push(new Uint8Array(a));
          }

          for (var h = 0; h < n; h++) {
            u(t.blocks[f][h], s, o);

            for (var d = 0, p = h << 3, v = 0; v < 8; v++) {
              for (var m = r[l + v], g = 0; g < 8; g++) {
                m[p + g] = s[d++];
              }
            }
          }
        }

        return r;
      }

      var Pn = function () {
        function e() {
          b(this, e), this.jfif = null, this.adobe = null, this.quantizationTables = [], this.huffmanTablesAC = [], this.huffmanTablesDC = [], this.resetFrames();
        }

        return l(e, [{
          key: "resetFrames",
          value: function value() {
            this.frames = [];
          }
        }, {
          key: "parse",
          value: function value(e) {
            var t = 0;

            function r() {
              var r = e[t] << 8 | e[t + 1];
              return t += 2, r;
            }

            function n(e) {
              var t,
                  r,
                  n = 0,
                  i = 0;

              for (r in e.components) {
                e.components.hasOwnProperty(r) && (n < (t = e.components[r]).h && (n = t.h), i < t.v && (i = t.v));
              }

              var a = Math.ceil(e.samplesPerLine / 8 / n),
                  o = Math.ceil(e.scanLines / 8 / i);

              for (r in e.components) {
                if (e.components.hasOwnProperty(r)) {
                  t = e.components[r];

                  for (var s = Math.ceil(Math.ceil(e.samplesPerLine / 8) * t.h / n), u = Math.ceil(Math.ceil(e.scanLines / 8) * t.v / i), f = a * t.h, l = o * t.v, c = [], h = 0; h < l; h++) {
                    for (var d = [], p = 0; p < f; p++) {
                      d.push(new Int32Array(64));
                    }

                    c.push(d);
                  }

                  t.blocksPerLine = s, t.blocksPerColumn = u, t.blocks = c;
                }
              }

              e.maxH = n, e.maxV = i, e.mcusPerLine = a, e.mcusPerColumn = o;
            }

            var i,
                a,
                o = r();
            if (65496 !== o) throw new Error("SOI not found");

            for (o = r(); 65497 !== o;) {
              switch (o) {
                case 65280:
                  break;

                case 65504:
                case 65505:
                case 65506:
                case 65507:
                case 65508:
                case 65509:
                case 65510:
                case 65511:
                case 65512:
                case 65513:
                case 65514:
                case 65515:
                case 65516:
                case 65517:
                case 65518:
                case 65519:
                case 65534:
                  var s = (i = void 0, a = void 0, i = r(), a = e.subarray(t, t + i - 2), t += a.length, a);
                  65504 === o && 74 === s[0] && 70 === s[1] && 73 === s[2] && 70 === s[3] && 0 === s[4] && (this.jfif = {
                    version: {
                      major: s[5],
                      minor: s[6]
                    },
                    densityUnits: s[7],
                    xDensity: s[8] << 8 | s[9],
                    yDensity: s[10] << 8 | s[11],
                    thumbWidth: s[12],
                    thumbHeight: s[13],
                    thumbData: s.subarray(14, 14 + 3 * s[12] * s[13])
                  }), 65518 === o && 65 === s[0] && 100 === s[1] && 111 === s[2] && 98 === s[3] && 101 === s[4] && 0 === s[5] && (this.adobe = {
                    version: s[6],
                    flags0: s[7] << 8 | s[8],
                    flags1: s[9] << 8 | s[10],
                    transformCode: s[11]
                  });
                  break;

                case 65499:
                  for (var u = r() + t - 2; t < u;) {
                    var f = e[t++],
                        l = new Int32Array(64);
                    if (f >> 4 == 0) for (var c = 0; c < 64; c++) {
                      l[hn[c]] = e[t++];
                    } else {
                      if (f >> 4 != 1) throw new Error("DQT: invalid table spec");

                      for (var h = 0; h < 64; h++) {
                        l[hn[h]] = r();
                      }
                    }
                    this.quantizationTables[15 & f] = l;
                  }

                  break;

                case 65472:
                case 65473:
                case 65474:
                  r();

                  for (var d = {
                    extended: 65473 === o,
                    progressive: 65474 === o,
                    precision: e[t++],
                    scanLines: r(),
                    samplesPerLine: r(),
                    components: {},
                    componentsOrder: []
                  }, p = e[t++], v = void 0, m = 0; m < p; m++) {
                    v = e[t];
                    var g = e[t + 1] >> 4,
                        y = 15 & e[t + 1],
                        w = e[t + 2];
                    d.componentsOrder.push(v), d.components[v] = {
                      h: g,
                      v: y,
                      quantizationIdx: w
                    }, t += 3;
                  }

                  n(d), this.frames.push(d);
                  break;

                case 65476:
                  for (var b = r(), k = 2; k < b;) {
                    for (var x = e[t++], A = new Uint8Array(16), P = 0, _ = 0; _ < 16; _++, t++) {
                      A[_] = e[t], P += A[_];
                    }

                    for (var I = new Uint8Array(P), S = 0; S < P; S++, t++) {
                      I[S] = e[t];
                    }

                    k += 17 + P, x >> 4 == 0 ? this.huffmanTablesDC[15 & x] = kn(A, I) : this.huffmanTablesAC[15 & x] = kn(A, I);
                  }

                  break;

                case 65501:
                  r(), this.resetInterval = r();
                  break;

                case 65498:
                  r();

                  for (var T = e[t++], U = [], O = this.frames[0], D = 0; D < T; D++) {
                    var E = O.components[e[t++]],
                        R = e[t++];
                    E.huffmanTableDC = this.huffmanTablesDC[R >> 4], E.huffmanTableAC = this.huffmanTablesAC[15 & R], U.push(E);
                  }

                  var M = e[t++],
                      B = e[t++],
                      C = e[t++],
                      L = xn(e, t, O, U, this.resetInterval, M, B, C >> 4, 15 & C);
                  t += L;
                  break;

                case 65535:
                  255 !== e[t] && t--;
                  break;

                default:
                  if (255 === e[t - 3] && e[t - 2] >= 192 && e[t - 2] <= 254) {
                    t -= 3;
                    break;
                  }

                  throw new Error("unknown JPEG marker ".concat(o.toString(16)));
              }

              o = r();
            }
          }
        }, {
          key: "getResult",
          value: function value() {
            var e = this.frames;
            if (0 === this.frames.length) throw new Error("no frames were decoded");
            this.frames.length > 1 && console.warn("more than one frame is not supported");

            for (var t = 0; t < this.frames.length; t++) {
              for (var r = this.frames[t].components, n = 0, i = Object.keys(r); n < i.length; n++) {
                var a = i[n];
                r[a].quantizationTable = this.quantizationTables[r[a].quantizationIdx], delete r[a].quantizationIdx;
              }
            }

            for (var o = e[0], s = o.components, u = o.componentsOrder, f = [], l = o.samplesPerLine, c = o.scanLines, h = 0; h < u.length; h++) {
              var d = s[u[h]];
              f.push({
                lines: An(0, d),
                scaleX: d.h / o.maxH,
                scaleY: d.v / o.maxV
              });
            }

            for (var p = new Uint8Array(l * c * f.length), v = 0, m = 0; m < c; ++m) {
              for (var g = 0; g < l; ++g) {
                for (var y = 0; y < f.length; ++y) {
                  var w = f[y];
                  p[v] = w.lines[0 | m * w.scaleY][0 | g * w.scaleX], ++v;
                }
              }
            }

            return p;
          }
        }]), e;
      }(),
          _n = function (e) {
        h(r, e);
        var t = cn(r);

        function r(e) {
          var n;
          return b(this, r), (n = t.call(this)).reader = new Pn(), e.JPEGTables && n.reader.parse(e.JPEGTables), n;
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            return this.reader.resetFrames(), this.reader.parse(new Uint8Array(e)), this.reader.getResult().buffer;
          }
        }]), r;
      }(tn),
          In = Object.freeze({
        __proto__: null,
        "default": _n
      });

      function Sn(e) {
        for (var t = e.length; --t >= 0;) {
          e[t] = 0;
        }
      }

      Sn(new Array(576)), Sn(new Array(60)), Sn(new Array(512)), Sn(new Array(256)), Sn(new Array(29)), Sn(new Array(30));

      var Tn = function Tn(e, t, r, n) {
        for (var i = 65535 & e | 0, a = e >>> 16 & 65535 | 0, o = 0; 0 !== r;) {
          r -= o = r > 2e3 ? 2e3 : r;

          do {
            a = a + (i = i + t[n++] | 0) | 0;
          } while (--o);

          i %= 65521, a %= 65521;
        }

        return i | a << 16 | 0;
      },
          Un = new Uint32Array(function () {
        for (var e, t = [], r = 0; r < 256; r++) {
          e = r;

          for (var n = 0; n < 8; n++) {
            e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
          }

          t[r] = e;
        }

        return t;
      }()),
          On = function On(e, t, r, n) {
        var i = Un,
            a = n + r;
        e ^= -1;

        for (var o = n; o < a; o++) {
          e = e >>> 8 ^ i[255 & (e ^ t[o])];
        }

        return -1 ^ e;
      },
          Dn = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      },
          En = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_MEM_ERROR: -4,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8
      },
          Rn = function Rn(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      },
          Mn = function Mn(e) {
        for (var t = Array.prototype.slice.call(arguments, 1); t.length;) {
          var r = t.shift();

          if (r) {
            if ("object" !== d(r)) throw new TypeError(r + "must be non-object");

            for (var n in r) {
              Rn(r, n) && (e[n] = r[n]);
            }
          }
        }

        return e;
      },
          Bn = function Bn(e) {
        for (var t = 0, r = 0, n = e.length; r < n; r++) {
          t += e[r].length;
        }

        for (var i = new Uint8Array(t), a = 0, o = 0, s = e.length; a < s; a++) {
          var u = e[a];
          i.set(u, o), o += u.length;
        }

        return i;
      },
          Cn = !0;

      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e) {
        Cn = !1;
      }

      for (var Ln = new Uint8Array(256), Fn = 0; Fn < 256; Fn++) {
        Ln[Fn] = Fn >= 252 ? 6 : Fn >= 248 ? 5 : Fn >= 240 ? 4 : Fn >= 224 ? 3 : Fn >= 192 ? 2 : 1;
      }

      Ln[254] = Ln[254] = 1;

      var Vn = function Vn(e) {
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return new TextEncoder().encode(e);
        var t,
            r,
            n,
            i,
            a,
            o = e.length,
            s = 0;

        for (i = 0; i < o; i++) {
          55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < o && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), s += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
        }

        for (t = new Uint8Array(s), a = 0, i = 0; a < s; i++) {
          55296 == (64512 & (r = e.charCodeAt(i))) && i + 1 < o && 56320 == (64512 & (n = e.charCodeAt(i + 1))) && (r = 65536 + (r - 55296 << 10) + (n - 56320), i++), r < 128 ? t[a++] = r : r < 2048 ? (t[a++] = 192 | r >>> 6, t[a++] = 128 | 63 & r) : r < 65536 ? (t[a++] = 224 | r >>> 12, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | 63 & r) : (t[a++] = 240 | r >>> 18, t[a++] = 128 | r >>> 12 & 63, t[a++] = 128 | r >>> 6 & 63, t[a++] = 128 | 63 & r);
        }

        return t;
      },
          Gn = function Gn(e, t) {
        var r,
            n,
            i = t || e.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return new TextDecoder().decode(e.subarray(0, t));
        var a = new Array(2 * i);

        for (n = 0, r = 0; r < i;) {
          var o = e[r++];
          if (o < 128) a[n++] = o;else {
            var s = Ln[o];
            if (s > 4) a[n++] = 65533, r += s - 1;else {
              for (o &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && r < i;) {
                o = o << 6 | 63 & e[r++], s--;
              }

              s > 1 ? a[n++] = 65533 : o < 65536 ? a[n++] = o : (o -= 65536, a[n++] = 55296 | o >> 10 & 1023, a[n++] = 56320 | 1023 & o);
            }
          }
        }

        return function (e, t) {
          if (t < 65534 && e.subarray && Cn) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));

          for (var r = "", n = 0; n < t; n++) {
            r += String.fromCharCode(e[n]);
          }

          return r;
        }(a, n);
      },
          jn = function jn(e, t) {
        (t = t || e.length) > e.length && (t = e.length);

        for (var r = t - 1; r >= 0 && 128 == (192 & e[r]);) {
          r--;
        }

        return r < 0 || 0 === r ? t : r + Ln[e[r]] > t ? r : t;
      };

      var Nn = function Nn() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      },
          zn = function zn(e, t) {
        var r,
            n,
            i,
            a,
            o,
            s,
            u,
            f,
            l,
            c,
            h,
            d,
            p,
            v,
            m,
            g,
            y,
            w,
            b,
            k,
            x,
            A,
            P,
            _,
            I = e.state;

        r = e.next_in, P = e.input, n = r + (e.avail_in - 5), i = e.next_out, _ = e.output, a = i - (t - e.avail_out), o = i + (e.avail_out - 257), s = I.dmax, u = I.wsize, f = I.whave, l = I.wnext, c = I.window, h = I.hold, d = I.bits, p = I.lencode, v = I.distcode, m = (1 << I.lenbits) - 1, g = (1 << I.distbits) - 1;

        e: do {
          d < 15 && (h += P[r++] << d, d += 8, h += P[r++] << d, d += 8), y = p[h & m];

          t: for (;;) {
            if (h >>>= w = y >>> 24, d -= w, 0 === (w = y >>> 16 & 255)) _[i++] = 65535 & y;else {
              if (!(16 & w)) {
                if (0 == (64 & w)) {
                  y = p[(65535 & y) + (h & (1 << w) - 1)];
                  continue t;
                }

                if (32 & w) {
                  I.mode = 12;
                  break e;
                }

                e.msg = "invalid literal/length code", I.mode = 30;
                break e;
              }

              b = 65535 & y, (w &= 15) && (d < w && (h += P[r++] << d, d += 8), b += h & (1 << w) - 1, h >>>= w, d -= w), d < 15 && (h += P[r++] << d, d += 8, h += P[r++] << d, d += 8), y = v[h & g];

              r: for (;;) {
                if (h >>>= w = y >>> 24, d -= w, !(16 & (w = y >>> 16 & 255))) {
                  if (0 == (64 & w)) {
                    y = v[(65535 & y) + (h & (1 << w) - 1)];
                    continue r;
                  }

                  e.msg = "invalid distance code", I.mode = 30;
                  break e;
                }

                if (k = 65535 & y, d < (w &= 15) && (h += P[r++] << d, (d += 8) < w && (h += P[r++] << d, d += 8)), (k += h & (1 << w) - 1) > s) {
                  e.msg = "invalid distance too far back", I.mode = 30;
                  break e;
                }

                if (h >>>= w, d -= w, k > (w = i - a)) {
                  if ((w = k - w) > f && I.sane) {
                    e.msg = "invalid distance too far back", I.mode = 30;
                    break e;
                  }

                  if (x = 0, A = c, 0 === l) {
                    if (x += u - w, w < b) {
                      b -= w;

                      do {
                        _[i++] = c[x++];
                      } while (--w);

                      x = i - k, A = _;
                    }
                  } else if (l < w) {
                    if (x += u + l - w, (w -= l) < b) {
                      b -= w;

                      do {
                        _[i++] = c[x++];
                      } while (--w);

                      if (x = 0, l < b) {
                        b -= w = l;

                        do {
                          _[i++] = c[x++];
                        } while (--w);

                        x = i - k, A = _;
                      }
                    }
                  } else if (x += l - w, w < b) {
                    b -= w;

                    do {
                      _[i++] = c[x++];
                    } while (--w);

                    x = i - k, A = _;
                  }

                  for (; b > 2;) {
                    _[i++] = A[x++], _[i++] = A[x++], _[i++] = A[x++], b -= 3;
                  }

                  b && (_[i++] = A[x++], b > 1 && (_[i++] = A[x++]));
                } else {
                  x = i - k;

                  do {
                    _[i++] = _[x++], _[i++] = _[x++], _[i++] = _[x++], b -= 3;
                  } while (b > 2);

                  b && (_[i++] = _[x++], b > 1 && (_[i++] = _[x++]));
                }

                break;
              }
            }
            break;
          }
        } while (r < n && i < o);

        r -= b = d >> 3, h &= (1 << (d -= b << 3)) - 1, e.next_in = r, e.next_out = i, e.avail_in = r < n ? n - r + 5 : 5 - (r - n), e.avail_out = i < o ? o - i + 257 : 257 - (i - o), I.hold = h, I.bits = d;
      },
          Kn = 15,
          Zn = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
          Hn = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
          Yn = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
          qn = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]),
          Xn = function Xn(e, t, r, n, i, a, o, s) {
        var u,
            f,
            l,
            c,
            h,
            d,
            p,
            v,
            m,
            g = s.bits,
            y = 0,
            w = 0,
            b = 0,
            k = 0,
            x = 0,
            A = 0,
            P = 0,
            _ = 0,
            I = 0,
            S = 0,
            T = null,
            U = 0,
            O = new Uint16Array(16),
            D = new Uint16Array(16),
            E = null,
            R = 0;

        for (y = 0; y <= Kn; y++) {
          O[y] = 0;
        }

        for (w = 0; w < n; w++) {
          O[t[r + w]]++;
        }

        for (x = g, k = Kn; k >= 1 && 0 === O[k]; k--) {
        }

        if (x > k && (x = k), 0 === k) return i[a++] = 20971520, i[a++] = 20971520, s.bits = 1, 0;

        for (b = 1; b < k && 0 === O[b]; b++) {
        }

        for (x < b && (x = b), _ = 1, y = 1; y <= Kn; y++) {
          if (_ <<= 1, (_ -= O[y]) < 0) return -1;
        }

        if (_ > 0 && (0 === e || 1 !== k)) return -1;

        for (D[1] = 0, y = 1; y < Kn; y++) {
          D[y + 1] = D[y] + O[y];
        }

        for (w = 0; w < n; w++) {
          0 !== t[r + w] && (o[D[t[r + w]]++] = w);
        }

        if (0 === e ? (T = E = o, d = 19) : 1 === e ? (T = Zn, U -= 257, E = Hn, R -= 257, d = 256) : (T = Yn, E = qn, d = -1), S = 0, w = 0, y = b, h = a, A = x, P = 0, l = -1, c = (I = 1 << x) - 1, 1 === e && I > 852 || 2 === e && I > 592) return 1;

        for (;;) {
          p = y - P, o[w] < d ? (v = 0, m = o[w]) : o[w] > d ? (v = E[R + o[w]], m = T[U + o[w]]) : (v = 96, m = 0), u = 1 << y - P, b = f = 1 << A;

          do {
            i[h + (S >> P) + (f -= u)] = p << 24 | v << 16 | m | 0;
          } while (0 !== f);

          for (u = 1 << y - 1; S & u;) {
            u >>= 1;
          }

          if (0 !== u ? (S &= u - 1, S += u) : S = 0, w++, 0 == --O[y]) {
            if (y === k) break;
            y = t[r + o[w]];
          }

          if (y > x && (S & c) !== l) {
            for (0 === P && (P = x), h += b, _ = 1 << (A = y - P); A + P < k && !((_ -= O[A + P]) <= 0);) {
              A++, _ <<= 1;
            }

            if (I += 1 << A, 1 === e && I > 852 || 2 === e && I > 592) return 1;
            i[l = S & c] = x << 24 | A << 16 | h - a | 0;
          }
        }

        return 0 !== S && (i[h + S] = y - P << 24 | 64 << 16 | 0), s.bits = x, 0;
      },
          Wn = En.Z_FINISH,
          Jn = En.Z_BLOCK,
          Qn = En.Z_TREES,
          $n = En.Z_OK,
          ei = En.Z_STREAM_END,
          ti = En.Z_NEED_DICT,
          ri = En.Z_STREAM_ERROR,
          ni = En.Z_DATA_ERROR,
          ii = En.Z_MEM_ERROR,
          ai = En.Z_BUF_ERROR,
          oi = En.Z_DEFLATED,
          si = 12,
          ui = 30,
          fi = function fi(e) {
        return (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
      };

      function li() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }

      var ci,
          hi,
          di = function di(e) {
        if (!e || !e.state) return ri;
        var t = e.state;
        return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, $n;
      },
          pi = function pi(e) {
        if (!e || !e.state) return ri;
        var t = e.state;
        return t.wsize = 0, t.whave = 0, t.wnext = 0, di(e);
      },
          vi = function vi(e, t) {
        var r;
        if (!e || !e.state) return ri;
        var n = e.state;
        return t < 0 ? (r = 0, t = -t) : (r = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? ri : (null !== n.window && n.wbits !== t && (n.window = null), n.wrap = r, n.wbits = t, pi(e));
      },
          mi = function mi(e, t) {
        if (!e) return ri;
        var r = new li();
        e.state = r, r.window = null;
        var n = vi(e, t);
        return n !== $n && (e.state = null), n;
      },
          gi = !0,
          yi = function yi(e) {
        if (gi) {
          ci = new Int32Array(512), hi = new Int32Array(32);

          for (var t = 0; t < 144;) {
            e.lens[t++] = 8;
          }

          for (; t < 256;) {
            e.lens[t++] = 9;
          }

          for (; t < 280;) {
            e.lens[t++] = 7;
          }

          for (; t < 288;) {
            e.lens[t++] = 8;
          }

          for (Xn(1, e.lens, 0, 288, ci, 0, e.work, {
            bits: 9
          }), t = 0; t < 32;) {
            e.lens[t++] = 5;
          }

          Xn(2, e.lens, 0, 32, hi, 0, e.work, {
            bits: 5
          }), gi = !1;
        }

        e.lencode = ci, e.lenbits = 9, e.distcode = hi, e.distbits = 5;
      },
          wi = function wi(e, t, r, n) {
        var i,
            a = e.state;
        return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), n >= a.wsize ? (a.window.set(t.subarray(r - a.wsize, r), 0), a.wnext = 0, a.whave = a.wsize) : ((i = a.wsize - a.wnext) > n && (i = n), a.window.set(t.subarray(r - n, r - n + i), a.wnext), (n -= i) ? (a.window.set(t.subarray(r - n, r), 0), a.wnext = n, a.whave = a.wsize) : (a.wnext += i, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += i))), 0;
      },
          bi = {
        inflateReset: pi,
        inflateReset2: vi,
        inflateResetKeep: di,
        inflateInit: function inflateInit(e) {
          return mi(e, 15);
        },
        inflateInit2: mi,
        inflate: function inflate(e, t) {
          var r,
              n,
              i,
              a,
              o,
              s,
              u,
              f,
              l,
              c,
              h,
              d,
              p,
              v,
              m,
              g,
              y,
              w,
              b,
              k,
              x,
              A,
              P,
              _,
              I = 0,
              S = new Uint8Array(4),
              T = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

          if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return ri;
          (r = e.state).mode === si && (r.mode = 13), o = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, n = e.input, s = e.avail_in, f = r.hold, l = r.bits, c = s, h = u, A = $n;

          e: for (;;) {
            switch (r.mode) {
              case 1:
                if (0 === r.wrap) {
                  r.mode = 13;
                  break;
                }

                for (; l < 16;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if (2 & r.wrap && 35615 === f) {
                  r.check = 0, S[0] = 255 & f, S[1] = f >>> 8 & 255, r.check = On(r.check, S, 2, 0), f = 0, l = 0, r.mode = 2;
                  break;
                }

                if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & f) << 8) + (f >> 8)) % 31) {
                  e.msg = "incorrect header check", r.mode = ui;
                  break;
                }

                if ((15 & f) !== oi) {
                  e.msg = "unknown compression method", r.mode = ui;
                  break;
                }

                if (l -= 4, x = 8 + (15 & (f >>>= 4)), 0 === r.wbits) r.wbits = x;else if (x > r.wbits) {
                  e.msg = "invalid window size", r.mode = ui;
                  break;
                }
                r.dmax = 1 << r.wbits, e.adler = r.check = 1, r.mode = 512 & f ? 10 : si, f = 0, l = 0;
                break;

              case 2:
                for (; l < 16;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if (r.flags = f, (255 & r.flags) !== oi) {
                  e.msg = "unknown compression method", r.mode = ui;
                  break;
                }

                if (57344 & r.flags) {
                  e.msg = "unknown header flags set", r.mode = ui;
                  break;
                }

                r.head && (r.head.text = f >> 8 & 1), 512 & r.flags && (S[0] = 255 & f, S[1] = f >>> 8 & 255, r.check = On(r.check, S, 2, 0)), f = 0, l = 0, r.mode = 3;

              case 3:
                for (; l < 32;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                r.head && (r.head.time = f), 512 & r.flags && (S[0] = 255 & f, S[1] = f >>> 8 & 255, S[2] = f >>> 16 & 255, S[3] = f >>> 24 & 255, r.check = On(r.check, S, 4, 0)), f = 0, l = 0, r.mode = 4;

              case 4:
                for (; l < 16;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                r.head && (r.head.xflags = 255 & f, r.head.os = f >> 8), 512 & r.flags && (S[0] = 255 & f, S[1] = f >>> 8 & 255, r.check = On(r.check, S, 2, 0)), f = 0, l = 0, r.mode = 5;

              case 5:
                if (1024 & r.flags) {
                  for (; l < 16;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  r.length = f, r.head && (r.head.extra_len = f), 512 & r.flags && (S[0] = 255 & f, S[1] = f >>> 8 & 255, r.check = On(r.check, S, 2, 0)), f = 0, l = 0;
                } else r.head && (r.head.extra = null);

                r.mode = 6;

              case 6:
                if (1024 & r.flags && ((d = r.length) > s && (d = s), d && (r.head && (x = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(a, a + d), x)), 512 & r.flags && (r.check = On(r.check, n, d, a)), s -= d, a += d, r.length -= d), r.length)) break e;
                r.length = 0, r.mode = 7;

              case 7:
                if (2048 & r.flags) {
                  if (0 === s) break e;
                  d = 0;

                  do {
                    x = n[a + d++], r.head && x && r.length < 65536 && (r.head.name += String.fromCharCode(x));
                  } while (x && d < s);

                  if (512 & r.flags && (r.check = On(r.check, n, d, a)), s -= d, a += d, x) break e;
                } else r.head && (r.head.name = null);

                r.length = 0, r.mode = 8;

              case 8:
                if (4096 & r.flags) {
                  if (0 === s) break e;
                  d = 0;

                  do {
                    x = n[a + d++], r.head && x && r.length < 65536 && (r.head.comment += String.fromCharCode(x));
                  } while (x && d < s);

                  if (512 & r.flags && (r.check = On(r.check, n, d, a)), s -= d, a += d, x) break e;
                } else r.head && (r.head.comment = null);

                r.mode = 9;

              case 9:
                if (512 & r.flags) {
                  for (; l < 16;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  if (f !== (65535 & r.check)) {
                    e.msg = "header crc mismatch", r.mode = ui;
                    break;
                  }

                  f = 0, l = 0;
                }

                r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), e.adler = r.check = 0, r.mode = si;
                break;

              case 10:
                for (; l < 32;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                e.adler = r.check = fi(f), f = 0, l = 0, r.mode = 11;

              case 11:
                if (0 === r.havedict) return e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = f, r.bits = l, ti;
                e.adler = r.check = 1, r.mode = si;

              case si:
                if (t === Jn || t === Qn) break e;

              case 13:
                if (r.last) {
                  f >>>= 7 & l, l -= 7 & l, r.mode = 27;
                  break;
                }

                for (; l < 3;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                switch (r.last = 1 & f, l -= 1, 3 & (f >>>= 1)) {
                  case 0:
                    r.mode = 14;
                    break;

                  case 1:
                    if (yi(r), r.mode = 20, t === Qn) {
                      f >>>= 2, l -= 2;
                      break e;
                    }

                    break;

                  case 2:
                    r.mode = 17;
                    break;

                  case 3:
                    e.msg = "invalid block type", r.mode = ui;
                }

                f >>>= 2, l -= 2;
                break;

              case 14:
                for (f >>>= 7 & l, l -= 7 & l; l < 32;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if ((65535 & f) != (f >>> 16 ^ 65535)) {
                  e.msg = "invalid stored block lengths", r.mode = ui;
                  break;
                }

                if (r.length = 65535 & f, f = 0, l = 0, r.mode = 15, t === Qn) break e;

              case 15:
                r.mode = 16;

              case 16:
                if (d = r.length) {
                  if (d > s && (d = s), d > u && (d = u), 0 === d) break e;
                  i.set(n.subarray(a, a + d), o), s -= d, a += d, u -= d, o += d, r.length -= d;
                  break;
                }

                r.mode = si;
                break;

              case 17:
                for (; l < 14;) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if (r.nlen = 257 + (31 & f), f >>>= 5, l -= 5, r.ndist = 1 + (31 & f), f >>>= 5, l -= 5, r.ncode = 4 + (15 & f), f >>>= 4, l -= 4, r.nlen > 286 || r.ndist > 30) {
                  e.msg = "too many length or distance symbols", r.mode = ui;
                  break;
                }

                r.have = 0, r.mode = 18;

              case 18:
                for (; r.have < r.ncode;) {
                  for (; l < 3;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  r.lens[T[r.have++]] = 7 & f, f >>>= 3, l -= 3;
                }

                for (; r.have < 19;) {
                  r.lens[T[r.have++]] = 0;
                }

                if (r.lencode = r.lendyn, r.lenbits = 7, P = {
                  bits: r.lenbits
                }, A = Xn(0, r.lens, 0, 19, r.lencode, 0, r.work, P), r.lenbits = P.bits, A) {
                  e.msg = "invalid code lengths set", r.mode = ui;
                  break;
                }

                r.have = 0, r.mode = 19;

              case 19:
                for (; r.have < r.nlen + r.ndist;) {
                  for (; g = (I = r.lencode[f & (1 << r.lenbits) - 1]) >>> 16 & 255, y = 65535 & I, !((m = I >>> 24) <= l);) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  if (y < 16) f >>>= m, l -= m, r.lens[r.have++] = y;else {
                    if (16 === y) {
                      for (_ = m + 2; l < _;) {
                        if (0 === s) break e;
                        s--, f += n[a++] << l, l += 8;
                      }

                      if (f >>>= m, l -= m, 0 === r.have) {
                        e.msg = "invalid bit length repeat", r.mode = ui;
                        break;
                      }

                      x = r.lens[r.have - 1], d = 3 + (3 & f), f >>>= 2, l -= 2;
                    } else if (17 === y) {
                      for (_ = m + 3; l < _;) {
                        if (0 === s) break e;
                        s--, f += n[a++] << l, l += 8;
                      }

                      l -= m, x = 0, d = 3 + (7 & (f >>>= m)), f >>>= 3, l -= 3;
                    } else {
                      for (_ = m + 7; l < _;) {
                        if (0 === s) break e;
                        s--, f += n[a++] << l, l += 8;
                      }

                      l -= m, x = 0, d = 11 + (127 & (f >>>= m)), f >>>= 7, l -= 7;
                    }

                    if (r.have + d > r.nlen + r.ndist) {
                      e.msg = "invalid bit length repeat", r.mode = ui;
                      break;
                    }

                    for (; d--;) {
                      r.lens[r.have++] = x;
                    }
                  }
                }

                if (r.mode === ui) break;

                if (0 === r.lens[256]) {
                  e.msg = "invalid code -- missing end-of-block", r.mode = ui;
                  break;
                }

                if (r.lenbits = 9, P = {
                  bits: r.lenbits
                }, A = Xn(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, P), r.lenbits = P.bits, A) {
                  e.msg = "invalid literal/lengths set", r.mode = ui;
                  break;
                }

                if (r.distbits = 6, r.distcode = r.distdyn, P = {
                  bits: r.distbits
                }, A = Xn(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, P), r.distbits = P.bits, A) {
                  e.msg = "invalid distances set", r.mode = ui;
                  break;
                }

                if (r.mode = 20, t === Qn) break e;

              case 20:
                r.mode = 21;

              case 21:
                if (s >= 6 && u >= 258) {
                  e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = f, r.bits = l, zn(e, h), o = e.next_out, i = e.output, u = e.avail_out, a = e.next_in, n = e.input, s = e.avail_in, f = r.hold, l = r.bits, r.mode === si && (r.back = -1);
                  break;
                }

                for (r.back = 0; g = (I = r.lencode[f & (1 << r.lenbits) - 1]) >>> 16 & 255, y = 65535 & I, !((m = I >>> 24) <= l);) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if (g && 0 == (240 & g)) {
                  for (w = m, b = g, k = y; g = (I = r.lencode[k + ((f & (1 << w + b) - 1) >> w)]) >>> 16 & 255, y = 65535 & I, !(w + (m = I >>> 24) <= l);) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  f >>>= w, l -= w, r.back += w;
                }

                if (f >>>= m, l -= m, r.back += m, r.length = y, 0 === g) {
                  r.mode = 26;
                  break;
                }

                if (32 & g) {
                  r.back = -1, r.mode = si;
                  break;
                }

                if (64 & g) {
                  e.msg = "invalid literal/length code", r.mode = ui;
                  break;
                }

                r.extra = 15 & g, r.mode = 22;

              case 22:
                if (r.extra) {
                  for (_ = r.extra; l < _;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  r.length += f & (1 << r.extra) - 1, f >>>= r.extra, l -= r.extra, r.back += r.extra;
                }

                r.was = r.length, r.mode = 23;

              case 23:
                for (; g = (I = r.distcode[f & (1 << r.distbits) - 1]) >>> 16 & 255, y = 65535 & I, !((m = I >>> 24) <= l);) {
                  if (0 === s) break e;
                  s--, f += n[a++] << l, l += 8;
                }

                if (0 == (240 & g)) {
                  for (w = m, b = g, k = y; g = (I = r.distcode[k + ((f & (1 << w + b) - 1) >> w)]) >>> 16 & 255, y = 65535 & I, !(w + (m = I >>> 24) <= l);) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  f >>>= w, l -= w, r.back += w;
                }

                if (f >>>= m, l -= m, r.back += m, 64 & g) {
                  e.msg = "invalid distance code", r.mode = ui;
                  break;
                }

                r.offset = y, r.extra = 15 & g, r.mode = 24;

              case 24:
                if (r.extra) {
                  for (_ = r.extra; l < _;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  r.offset += f & (1 << r.extra) - 1, f >>>= r.extra, l -= r.extra, r.back += r.extra;
                }

                if (r.offset > r.dmax) {
                  e.msg = "invalid distance too far back", r.mode = ui;
                  break;
                }

                r.mode = 25;

              case 25:
                if (0 === u) break e;

                if (d = h - u, r.offset > d) {
                  if ((d = r.offset - d) > r.whave && r.sane) {
                    e.msg = "invalid distance too far back", r.mode = ui;
                    break;
                  }

                  d > r.wnext ? (d -= r.wnext, p = r.wsize - d) : p = r.wnext - d, d > r.length && (d = r.length), v = r.window;
                } else v = i, p = o - r.offset, d = r.length;

                d > u && (d = u), u -= d, r.length -= d;

                do {
                  i[o++] = v[p++];
                } while (--d);

                0 === r.length && (r.mode = 21);
                break;

              case 26:
                if (0 === u) break e;
                i[o++] = r.length, u--, r.mode = 21;
                break;

              case 27:
                if (r.wrap) {
                  for (; l < 32;) {
                    if (0 === s) break e;
                    s--, f |= n[a++] << l, l += 8;
                  }

                  if (h -= u, e.total_out += h, r.total += h, h && (e.adler = r.check = r.flags ? On(r.check, i, h, o - h) : Tn(r.check, i, h, o - h)), h = u, (r.flags ? f : fi(f)) !== r.check) {
                    e.msg = "incorrect data check", r.mode = ui;
                    break;
                  }

                  f = 0, l = 0;
                }

                r.mode = 28;

              case 28:
                if (r.wrap && r.flags) {
                  for (; l < 32;) {
                    if (0 === s) break e;
                    s--, f += n[a++] << l, l += 8;
                  }

                  if (f !== (4294967295 & r.total)) {
                    e.msg = "incorrect length check", r.mode = ui;
                    break;
                  }

                  f = 0, l = 0;
                }

                r.mode = 29;

              case 29:
                A = ei;
                break e;

              case ui:
                A = ni;
                break e;

              case 31:
                return ii;

              default:
                return ri;
            }
          }

          return e.next_out = o, e.avail_out = u, e.next_in = a, e.avail_in = s, r.hold = f, r.bits = l, (r.wsize || h !== e.avail_out && r.mode < ui && (r.mode < 27 || t !== Wn)) && wi(e, e.output, e.next_out, h - e.avail_out), c -= e.avail_in, h -= e.avail_out, e.total_in += c, e.total_out += h, r.total += h, r.wrap && h && (e.adler = r.check = r.flags ? On(r.check, i, h, e.next_out - h) : Tn(r.check, i, h, e.next_out - h)), e.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === si ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 === c && 0 === h || t === Wn) && A === $n && (A = ai), A;
        },
        inflateEnd: function inflateEnd(e) {
          if (!e || !e.state) return ri;
          var t = e.state;
          return t.window && (t.window = null), e.state = null, $n;
        },
        inflateGetHeader: function inflateGetHeader(e, t) {
          if (!e || !e.state) return ri;
          var r = e.state;
          return 0 == (2 & r.wrap) ? ri : (r.head = t, t.done = !1, $n);
        },
        inflateSetDictionary: function inflateSetDictionary(e, t) {
          var r,
              n = t.length;
          return e && e.state ? 0 !== (r = e.state).wrap && 11 !== r.mode ? ri : 11 === r.mode && Tn(1, t, n, 0) !== r.check ? ni : wi(e, t, n, n) ? (r.mode = 31, ii) : (r.havedict = 1, $n) : ri;
        },
        inflateInfo: "pako inflate (from Nodeca project)"
      };

      var ki = function ki() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      },
          xi = Object.prototype.toString,
          Ai = En.Z_NO_FLUSH,
          Pi = En.Z_FINISH,
          _i = En.Z_OK,
          Ii = En.Z_STREAM_END,
          Si = En.Z_NEED_DICT,
          Ti = En.Z_STREAM_ERROR,
          Ui = En.Z_DATA_ERROR,
          Oi = En.Z_MEM_ERROR;

      function Di(e) {
        this.options = Mn({
          chunkSize: 65536,
          windowBits: 15,
          to: ""
        }, e || {});
        var t = this.options;
        t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 == (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Nn(), this.strm.avail_out = 0;
        var r = bi.inflateInit2(this.strm, t.windowBits);
        if (r !== _i) throw new Error(Dn[r]);
        if (this.header = new ki(), bi.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = Vn(t.dictionary) : "[object ArrayBuffer]" === xi.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (r = bi.inflateSetDictionary(this.strm, t.dictionary)) !== _i)) throw new Error(Dn[r]);
      }

      function Ei(e, t) {
        var r = new Di(t);
        if (r.push(e), r.err) throw r.msg || Dn[r.err];
        return r.result;
      }

      Di.prototype.push = function (e, t) {
        var r,
            n,
            i,
            a = this.strm,
            o = this.options.chunkSize,
            s = this.options.dictionary;
        if (this.ended) return !1;

        for (n = t === ~~t ? t : !0 === t ? Pi : Ai, "[object ArrayBuffer]" === xi.call(e) ? a.input = new Uint8Array(e) : a.input = e, a.next_in = 0, a.avail_in = a.input.length;;) {
          for (0 === a.avail_out && (a.output = new Uint8Array(o), a.next_out = 0, a.avail_out = o), (r = bi.inflate(a, n)) === Si && s && ((r = bi.inflateSetDictionary(a, s)) === _i ? r = bi.inflate(a, n) : r === Ui && (r = Si)); a.avail_in > 0 && r === Ii && a.state.wrap > 0 && 0 !== e[a.next_in];) {
            bi.inflateReset(a), r = bi.inflate(a, n);
          }

          switch (r) {
            case Ti:
            case Ui:
            case Si:
            case Oi:
              return this.onEnd(r), this.ended = !0, !1;
          }

          if (i = a.avail_out, a.next_out && (0 === a.avail_out || r === Ii)) if ("string" === this.options.to) {
            var u = jn(a.output, a.next_out),
                f = a.next_out - u,
                l = Gn(a.output, u);
            a.next_out = f, a.avail_out = o - f, f && a.output.set(a.output.subarray(u, u + f), 0), this.onData(l);
          } else this.onData(a.output.length === a.next_out ? a.output : a.output.subarray(0, a.next_out));

          if (r !== _i || 0 !== i) {
            if (r === Ii) return r = bi.inflateEnd(this.strm), this.onEnd(r), this.ended = !0, !0;
            if (0 === a.avail_in) break;
          }
        }

        return !0;
      }, Di.prototype.onData = function (e) {
        this.chunks.push(e);
      }, Di.prototype.onEnd = function (e) {
        e === _i && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Bn(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg;
      };
      var Ri = {
        Inflate: Di,
        inflate: Ei,
        inflateRaw: function inflateRaw(e, t) {
          return (t = t || {}).raw = !0, Ei(e, t);
        },
        ungzip: Ei,
        constants: En
      }.inflate;

      function Mi(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Bi = function (e) {
        h(r, e);
        var t = Mi(r);

        function r() {
          return b(this, r), t.apply(this, arguments);
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            return Ri(new Uint8Array(e)).buffer;
          }
        }]), r;
      }(tn),
          Ci = Object.freeze({
        __proto__: null,
        "default": Bi
      });

      function Li(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Fi = function (e) {
        h(r, e);
        var t = Li(r);

        function r() {
          return b(this, r), t.apply(this, arguments);
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            for (var t = new DataView(e), r = [], n = 0; n < e.byteLength; ++n) {
              var i = t.getInt8(n);

              if (i < 0) {
                var a = t.getUint8(n + 1);
                i = -i;

                for (var o = 0; o <= i; ++o) {
                  r.push(a);
                }

                n += 1;
              } else {
                for (var s = 0; s <= i; ++s) {
                  r.push(t.getUint8(n + s + 1));
                }

                n += i + 1;
              }
            }

            return new Uint8Array(r).buffer;
          }
        }]), r;
      }(tn),
          Vi = Object.freeze({
        __proto__: null,
        "default": Fi
      }),
          Gi = {
        exports: {}
      };

      !function (e) {
        /* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */
        !function () {
          var t,
              r,
              n,
              i,
              a,
              o,
              s,
              u,
              f = (t = {
            defaultNoDataValue: -34027999387901484e22,
            decode: function decode(e, o) {
              var s = (o = o || {}).encodedMaskData || null === o.encodedMaskData,
                  u = a(e, o.inputOffset || 0, s),
                  f = null !== o.noDataValue ? o.noDataValue : t.defaultNoDataValue,
                  l = r(u, o.pixelType || Float32Array, o.encodedMaskData, f, o.returnMask),
                  c = {
                width: u.width,
                height: u.height,
                pixelData: l.resultPixels,
                minValue: l.minValue,
                maxValue: u.pixels.maxValue,
                noDataValue: f
              };
              return l.resultMask && (c.maskData = l.resultMask), o.returnEncodedMask && u.mask && (c.encodedMaskData = u.mask.bitset ? u.mask.bitset : null), o.returnFileInfo && (c.fileInfo = n(u), o.computeUsedBitDepths && (c.fileInfo.bitDepths = i(u))), c;
            }
          }, r = function r(e, t, _r2, n, i) {
            var a,
                s,
                u,
                f = 0,
                l = e.pixels.numBlocksX,
                c = e.pixels.numBlocksY,
                h = Math.floor(e.width / l),
                d = Math.floor(e.height / c),
                p = 2 * e.maxZError,
                v = Number.MAX_VALUE;
            _r2 = _r2 || (e.mask ? e.mask.bitset : null), s = new t(e.width * e.height), i && _r2 && (u = new Uint8Array(e.width * e.height));

            for (var m, g, y = new Float32Array(h * d), w = 0; w <= c; w++) {
              var b = w !== c ? d : e.height % c;
              if (0 !== b) for (var k = 0; k <= l; k++) {
                var x = k !== l ? h : e.width % l;

                if (0 !== x) {
                  var A,
                      P,
                      _,
                      I,
                      S = w * e.width * d + k * h,
                      T = e.width - x,
                      U = e.pixels.blocks[f];

                  if (U.encoding < 2 ? (0 === U.encoding ? A = U.rawData : (o(U.stuffedData, U.bitsPerPixel, U.numValidPixels, U.offset, p, y, e.pixels.maxValue), A = y), P = 0) : _ = 2 === U.encoding ? 0 : U.offset, _r2) for (g = 0; g < b; g++) {
                    for (7 & S && (I = _r2[S >> 3], I <<= 7 & S), m = 0; m < x; m++) {
                      7 & S || (I = _r2[S >> 3]), 128 & I ? (u && (u[S] = 1), v = v > (a = U.encoding < 2 ? A[P++] : _) ? a : v, s[S++] = a) : (u && (u[S] = 0), s[S++] = n), I <<= 1;
                    }

                    S += T;
                  } else if (U.encoding < 2) for (g = 0; g < b; g++) {
                    for (m = 0; m < x; m++) {
                      v = v > (a = A[P++]) ? a : v, s[S++] = a;
                    }

                    S += T;
                  } else for (v = v > _ ? _ : v, g = 0; g < b; g++) {
                    for (m = 0; m < x; m++) {
                      s[S++] = _;
                    }

                    S += T;
                  }
                  if (1 === U.encoding && P !== U.numValidPixels) throw "Block and Mask do not match";
                  f++;
                }
              }
            }

            return {
              resultPixels: s,
              resultMask: u,
              minValue: v
            };
          }, n = function n(e) {
            return {
              fileIdentifierString: e.fileIdentifierString,
              fileVersion: e.fileVersion,
              imageType: e.imageType,
              height: e.height,
              width: e.width,
              maxZError: e.maxZError,
              eofOffset: e.eofOffset,
              mask: e.mask ? {
                numBlocksX: e.mask.numBlocksX,
                numBlocksY: e.mask.numBlocksY,
                numBytes: e.mask.numBytes,
                maxValue: e.mask.maxValue
              } : null,
              pixels: {
                numBlocksX: e.pixels.numBlocksX,
                numBlocksY: e.pixels.numBlocksY,
                numBytes: e.pixels.numBytes,
                maxValue: e.pixels.maxValue,
                noDataValue: e.noDataValue
              }
            };
          }, i = function i(e) {
            for (var t = e.pixels.numBlocksX * e.pixels.numBlocksY, r = {}, n = 0; n < t; n++) {
              var i = e.pixels.blocks[n];
              0 === i.encoding ? r.float32 = !0 : 1 === i.encoding ? r[i.bitsPerPixel] = !0 : r[0] = !0;
            }

            return Object.keys(r);
          }, a = function a(e, t, r) {
            var n = {},
                i = new Uint8Array(e, t, 10);
            if (n.fileIdentifierString = String.fromCharCode.apply(null, i), "CntZImage" !== n.fileIdentifierString.trim()) throw "Unexpected file identifier string: " + n.fileIdentifierString;
            t += 10;
            var a = new DataView(e, t, 24);
            if (n.fileVersion = a.getInt32(0, !0), n.imageType = a.getInt32(4, !0), n.height = a.getUint32(8, !0), n.width = a.getUint32(12, !0), n.maxZError = a.getFloat64(16, !0), t += 24, !r) if (a = new DataView(e, t, 16), n.mask = {}, n.mask.numBlocksY = a.getUint32(0, !0), n.mask.numBlocksX = a.getUint32(4, !0), n.mask.numBytes = a.getUint32(8, !0), n.mask.maxValue = a.getFloat32(12, !0), t += 16, n.mask.numBytes > 0) {
              var o = new Uint8Array(Math.ceil(n.width * n.height / 8)),
                  s = (a = new DataView(e, t, n.mask.numBytes)).getInt16(0, !0),
                  u = 2,
                  f = 0;

              do {
                if (s > 0) for (; s--;) {
                  o[f++] = a.getUint8(u++);
                } else {
                  var l = a.getUint8(u++);

                  for (s = -s; s--;) {
                    o[f++] = l;
                  }
                }
                s = a.getInt16(u, !0), u += 2;
              } while (u < n.mask.numBytes);

              if (-32768 !== s || f < o.length) throw "Unexpected end of mask RLE encoding";
              n.mask.bitset = o, t += n.mask.numBytes;
            } else 0 == (n.mask.numBytes | n.mask.numBlocksY | n.mask.maxValue) && (n.mask.bitset = new Uint8Array(Math.ceil(n.width * n.height / 8)));
            a = new DataView(e, t, 16), n.pixels = {}, n.pixels.numBlocksY = a.getUint32(0, !0), n.pixels.numBlocksX = a.getUint32(4, !0), n.pixels.numBytes = a.getUint32(8, !0), n.pixels.maxValue = a.getFloat32(12, !0), t += 16;
            var c = n.pixels.numBlocksX,
                h = n.pixels.numBlocksY,
                d = c + (n.width % c > 0 ? 1 : 0),
                p = h + (n.height % h > 0 ? 1 : 0);
            n.pixels.blocks = new Array(d * p);

            for (var v = 0, m = 0; m < p; m++) {
              for (var g = 0; g < d; g++) {
                var y = 0,
                    w = e.byteLength - t;
                a = new DataView(e, t, Math.min(10, w));
                var b = {};
                n.pixels.blocks[v++] = b;
                var k = a.getUint8(0);
                if (y++, b.encoding = 63 & k, b.encoding > 3) throw "Invalid block encoding (" + b.encoding + ")";

                if (2 !== b.encoding) {
                  if (0 !== k && 2 !== k) {
                    if (k >>= 6, b.offsetType = k, 2 === k) b.offset = a.getInt8(1), y++;else if (1 === k) b.offset = a.getInt16(1, !0), y += 2;else {
                      if (0 !== k) throw "Invalid block offset type";
                      b.offset = a.getFloat32(1, !0), y += 4;
                    }
                    if (1 === b.encoding) if (k = a.getUint8(y), y++, b.bitsPerPixel = 63 & k, k >>= 6, b.numValidPixelsType = k, 2 === k) b.numValidPixels = a.getUint8(y), y++;else if (1 === k) b.numValidPixels = a.getUint16(y, !0), y += 2;else {
                      if (0 !== k) throw "Invalid valid pixel count type";
                      b.numValidPixels = a.getUint32(y, !0), y += 4;
                    }
                  }

                  var x;
                  if (t += y, 3 !== b.encoding) if (0 === b.encoding) {
                    var A = (n.pixels.numBytes - 1) / 4;
                    if (A !== Math.floor(A)) throw "uncompressed block has invalid length";
                    x = new ArrayBuffer(4 * A), new Uint8Array(x).set(new Uint8Array(e, t, 4 * A));
                    var P = new Float32Array(x);
                    b.rawData = P, t += 4 * A;
                  } else if (1 === b.encoding) {
                    var _ = Math.ceil(b.numValidPixels * b.bitsPerPixel / 8),
                        I = Math.ceil(_ / 4);

                    x = new ArrayBuffer(4 * I), new Uint8Array(x).set(new Uint8Array(e, t, _)), b.stuffedData = new Uint32Array(x), t += _;
                  }
                } else t++;
              }
            }

            return n.eofOffset = t, n;
          }, o = function o(e, t, r, n, i, a, _o) {
            var s,
                u,
                f,
                l = (1 << t) - 1,
                c = 0,
                h = 0,
                d = Math.ceil((_o - n) / i),
                p = 4 * e.length - Math.ceil(t * r / 8);

            for (e[e.length - 1] <<= 8 * p, s = 0; s < r; s++) {
              if (0 === h && (f = e[c++], h = 32), h >= t) u = f >>> h - t & l, h -= t;else {
                var v = t - h;
                u = (f & l) << v & l, u += (f = e[c++]) >>> (h = 32 - v);
              }
              a[s] = u < d ? n + u * i : _o;
            }

            return a;
          }, t),
              l = function () {
            var e = function e(_e8, t, r, n, i, a, o, s) {
              var u,
                  f,
                  l,
                  c,
                  h,
                  d = (1 << r) - 1,
                  p = 0,
                  v = 0,
                  m = 4 * _e8.length - Math.ceil(r * n / 8);
              if (_e8[_e8.length - 1] <<= 8 * m, i) for (u = 0; u < n; u++) {
                0 === v && (l = _e8[p++], v = 32), v >= r ? (f = l >>> v - r & d, v -= r) : (f = (l & d) << (c = r - v) & d, f += (l = _e8[p++]) >>> (v = 32 - c)), t[u] = i[f];
              } else for (h = Math.ceil((s - a) / o), u = 0; u < n; u++) {
                0 === v && (l = _e8[p++], v = 32), v >= r ? (f = l >>> v - r & d, v -= r) : (f = (l & d) << (c = r - v) & d, f += (l = _e8[p++]) >>> (v = 32 - c)), t[u] = f < h ? a + f * o : s;
              }
            },
                t = function t(e, _t2, r, n, i, a) {
              var o,
                  s = (1 << _t2) - 1,
                  u = 0,
                  f = 0,
                  l = 0,
                  c = 0,
                  h = 0,
                  d = [],
                  p = 4 * e.length - Math.ceil(_t2 * r / 8);
              e[e.length - 1] <<= 8 * p;
              var v = Math.ceil((a - n) / i);

              for (f = 0; f < r; f++) {
                0 === c && (o = e[u++], c = 32), c >= _t2 ? (h = o >>> c - _t2 & s, c -= _t2) : (h = (o & s) << (l = _t2 - c) & s, h += (o = e[u++]) >>> (c = 32 - l)), d[f] = h < v ? n + h * i : a;
              }

              return d.unshift(n), d;
            },
                r = function r(e, t, _r3, n, i, a, o, s) {
              var u,
                  f,
                  l,
                  c,
                  h = (1 << _r3) - 1,
                  d = 0,
                  p = 0,
                  v = 0;
              if (i) for (u = 0; u < n; u++) {
                0 === p && (l = e[d++], p = 32, v = 0), p >= _r3 ? (f = l >>> v & h, p -= _r3, v += _r3) : (f = l >>> v & h, p = 32 - (c = _r3 - p), f |= ((l = e[d++]) & (1 << c) - 1) << _r3 - c, v = c), t[u] = i[f];
              } else {
                var m = Math.ceil((s - a) / o);

                for (u = 0; u < n; u++) {
                  0 === p && (l = e[d++], p = 32, v = 0), p >= _r3 ? (f = l >>> v & h, p -= _r3, v += _r3) : (f = l >>> v & h, p = 32 - (c = _r3 - p), f |= ((l = e[d++]) & (1 << c) - 1) << _r3 - c, v = c), t[u] = f < m ? a + f * o : s;
                }
              }
              return t;
            },
                n = function n(e, t, r, _n5, i, a) {
              var o,
                  s = (1 << t) - 1,
                  u = 0,
                  f = 0,
                  l = 0,
                  c = 0,
                  h = 0,
                  d = 0,
                  p = [],
                  v = Math.ceil((a - _n5) / i);

              for (f = 0; f < r; f++) {
                0 === c && (o = e[u++], c = 32, d = 0), c >= t ? (h = o >>> d & s, c -= t, d += t) : (h = o >>> d & s, c = 32 - (l = t - c), h |= ((o = e[u++]) & (1 << l) - 1) << t - l, d = l), p[f] = h < v ? _n5 + h * i : a;
              }

              return p.unshift(_n5), p;
            },
                i = function i(e, t, r, n) {
              var i,
                  a,
                  o,
                  s,
                  u = (1 << r) - 1,
                  f = 0,
                  l = 0,
                  c = 4 * e.length - Math.ceil(r * n / 8);

              for (e[e.length - 1] <<= 8 * c, i = 0; i < n; i++) {
                0 === l && (o = e[f++], l = 32), l >= r ? (a = o >>> l - r & u, l -= r) : (a = (o & u) << (s = r - l) & u, a += (o = e[f++]) >>> (l = 32 - s)), t[i] = a;
              }

              return t;
            },
                a = function a(e, t, r, n) {
              var i,
                  a,
                  o,
                  s,
                  u = (1 << r) - 1,
                  f = 0,
                  l = 0,
                  c = 0;

              for (i = 0; i < n; i++) {
                0 === l && (o = e[f++], l = 32, c = 0), l >= r ? (a = o >>> c & u, l -= r, c += r) : (a = o >>> c & u, l = 32 - (s = r - l), a |= ((o = e[f++]) & (1 << s) - 1) << r - s, c = s), t[i] = a;
              }

              return t;
            },
                o = {
              HUFFMAN_LUT_BITS_MAX: 12,
              computeChecksumFletcher32: function computeChecksumFletcher32(e) {
                for (var t = 65535, r = 65535, n = e.length, i = Math.floor(n / 2), a = 0; i;) {
                  var o = i >= 359 ? 359 : i;
                  i -= o;

                  do {
                    t += e[a++] << 8, r += t += e[a++];
                  } while (--o);

                  t = (65535 & t) + (t >>> 16), r = (65535 & r) + (r >>> 16);
                }

                return 1 & n && (r += t += e[a] << 8), ((r = (65535 & r) + (r >>> 16)) << 16 | (t = (65535 & t) + (t >>> 16))) >>> 0;
              },
              readHeaderInfo: function readHeaderInfo(e, t) {
                var r = t.ptr,
                    n = new Uint8Array(e, r, 6),
                    i = {};
                if (i.fileIdentifierString = String.fromCharCode.apply(null, n), 0 !== i.fileIdentifierString.lastIndexOf("Lerc2", 0)) throw "Unexpected file identifier string (expect Lerc2 ): " + i.fileIdentifierString;
                r += 6;
                var a,
                    o = new DataView(e, r, 8),
                    s = o.getInt32(0, !0);
                if (i.fileVersion = s, r += 4, s >= 3 && (i.checksum = o.getUint32(4, !0), r += 4), o = new DataView(e, r, 12), i.height = o.getUint32(0, !0), i.width = o.getUint32(4, !0), r += 8, s >= 4 ? (i.numDims = o.getUint32(8, !0), r += 4) : i.numDims = 1, o = new DataView(e, r, 40), i.numValidPixel = o.getUint32(0, !0), i.microBlockSize = o.getInt32(4, !0), i.blobSize = o.getInt32(8, !0), i.imageType = o.getInt32(12, !0), i.maxZError = o.getFloat64(16, !0), i.zMin = o.getFloat64(24, !0), i.zMax = o.getFloat64(32, !0), r += 40, t.headerInfo = i, t.ptr = r, s >= 3 && (a = s >= 4 ? 52 : 48, this.computeChecksumFletcher32(new Uint8Array(e, r - a, i.blobSize - 14)) !== i.checksum)) throw "Checksum failed.";
                return !0;
              },
              checkMinMaxRanges: function checkMinMaxRanges(e, t) {
                var r = t.headerInfo,
                    n = this.getDataTypeArray(r.imageType),
                    i = r.numDims * this.getDataTypeSize(r.imageType),
                    a = this.readSubArray(e, t.ptr, n, i),
                    o = this.readSubArray(e, t.ptr + i, n, i);
                t.ptr += 2 * i;
                var s,
                    u = !0;

                for (s = 0; s < r.numDims; s++) {
                  if (a[s] !== o[s]) {
                    u = !1;
                    break;
                  }
                }

                return r.minValues = a, r.maxValues = o, u;
              },
              readSubArray: function readSubArray(e, t, r, n) {
                var i;
                if (r === Uint8Array) i = new Uint8Array(e, t, n);else {
                  var a = new ArrayBuffer(n);
                  new Uint8Array(a).set(new Uint8Array(e, t, n)), i = new r(a);
                }
                return i;
              },
              readMask: function readMask(e, t) {
                var r,
                    n,
                    i = t.ptr,
                    a = t.headerInfo,
                    o = a.width * a.height,
                    s = a.numValidPixel,
                    u = new DataView(e, i, 4),
                    f = {};
                if (f.numBytes = u.getUint32(0, !0), i += 4, (0 === s || o === s) && 0 !== f.numBytes) throw "invalid mask";
                if (0 === s) r = new Uint8Array(Math.ceil(o / 8)), f.bitset = r, n = new Uint8Array(o), t.pixels.resultMask = n, i += f.numBytes;else if (f.numBytes > 0) {
                  r = new Uint8Array(Math.ceil(o / 8));
                  var l = (u = new DataView(e, i, f.numBytes)).getInt16(0, !0),
                      c = 2,
                      h = 0,
                      d = 0;

                  do {
                    if (l > 0) for (; l--;) {
                      r[h++] = u.getUint8(c++);
                    } else for (d = u.getUint8(c++), l = -l; l--;) {
                      r[h++] = d;
                    }
                    l = u.getInt16(c, !0), c += 2;
                  } while (c < f.numBytes);

                  if (-32768 !== l || h < r.length) throw "Unexpected end of mask RLE encoding";
                  n = new Uint8Array(o);
                  var p = 0,
                      v = 0;

                  for (v = 0; v < o; v++) {
                    7 & v ? (p = r[v >> 3], p <<= 7 & v) : p = r[v >> 3], 128 & p && (n[v] = 1);
                  }

                  t.pixels.resultMask = n, f.bitset = r, i += f.numBytes;
                }
                return t.ptr = i, t.mask = f, !0;
              },
              readDataOneSweep: function readDataOneSweep(e, t, r, n) {
                var i,
                    a = t.ptr,
                    s = t.headerInfo,
                    u = s.numDims,
                    f = s.width * s.height,
                    l = s.imageType,
                    c = s.numValidPixel * o.getDataTypeSize(l) * u,
                    h = t.pixels.resultMask;
                if (r === Uint8Array) i = new Uint8Array(e, a, c);else {
                  var d = new ArrayBuffer(c);
                  new Uint8Array(d).set(new Uint8Array(e, a, c)), i = new r(d);
                }
                if (i.length === f * u) t.pixels.resultPixels = n ? o.swapDimensionOrder(i, f, u, r, !0) : i;else {
                  t.pixels.resultPixels = new r(f * u);
                  var p = 0,
                      v = 0,
                      m = 0,
                      g = 0;

                  if (u > 1) {
                    if (n) {
                      for (v = 0; v < f; v++) {
                        if (h[v]) for (g = v, m = 0; m < u; m++, g += f) {
                          t.pixels.resultPixels[g] = i[p++];
                        }
                      }
                    } else for (v = 0; v < f; v++) {
                      if (h[v]) for (g = v * u, m = 0; m < u; m++) {
                        t.pixels.resultPixels[g + m] = i[p++];
                      }
                    }
                  } else for (v = 0; v < f; v++) {
                    h[v] && (t.pixels.resultPixels[v] = i[p++]);
                  }
                }
                return a += c, t.ptr = a, !0;
              },
              readHuffmanTree: function readHuffmanTree(e, t) {
                var r = this.HUFFMAN_LUT_BITS_MAX,
                    n = new DataView(e, t.ptr, 16);
                if (t.ptr += 16, n.getInt32(0, !0) < 2) throw "unsupported Huffman version";
                var i = n.getInt32(4, !0),
                    a = n.getInt32(8, !0),
                    u = n.getInt32(12, !0);
                if (a >= u) return !1;
                var f = new Uint32Array(u - a);
                o.decodeBits(e, t, f);
                var l,
                    c,
                    h,
                    d,
                    p = [];

                for (l = a; l < u; l++) {
                  p[c = l - (l < i ? 0 : i)] = {
                    first: f[l - a],
                    second: null
                  };
                }

                var v = e.byteLength - t.ptr,
                    m = Math.ceil(v / 4),
                    g = new ArrayBuffer(4 * m);
                new Uint8Array(g).set(new Uint8Array(e, t.ptr, v));
                var y,
                    w = new Uint32Array(g),
                    b = 0,
                    k = 0;

                for (y = w[0], l = a; l < u; l++) {
                  (d = p[c = l - (l < i ? 0 : i)].first) > 0 && (p[c].second = y << b >>> 32 - d, 32 - b >= d ? 32 === (b += d) && (b = 0, y = w[++k]) : (b += d - 32, y = w[++k], p[c].second |= y >>> 32 - b));
                }

                var x = 0,
                    A = 0,
                    P = new s();

                for (l = 0; l < p.length; l++) {
                  void 0 !== p[l] && (x = Math.max(x, p[l].first));
                }

                A = x >= r ? r : x;

                var _,
                    I,
                    S,
                    T,
                    U,
                    O = [];

                for (l = a; l < u; l++) {
                  if ((d = p[c = l - (l < i ? 0 : i)].first) > 0) if (_ = [d, c], d <= A) for (I = p[c].second << A - d, S = 1 << A - d, h = 0; h < S; h++) {
                    O[I | h] = _;
                  } else for (I = p[c].second, U = P, T = d - 1; T >= 0; T--) {
                    I >>> T & 1 ? (U.right || (U.right = new s()), U = U.right) : (U.left || (U.left = new s()), U = U.left), 0 !== T || U.val || (U.val = _[1]);
                  }
                }

                return {
                  decodeLut: O,
                  numBitsLUTQick: A,
                  numBitsLUT: x,
                  tree: P,
                  stuffedData: w,
                  srcPtr: k,
                  bitPos: b
                };
              },
              readHuffman: function readHuffman(e, t, r, n) {
                var i,
                    a,
                    s,
                    u,
                    f,
                    l,
                    c,
                    h,
                    d,
                    p = t.headerInfo.numDims,
                    v = t.headerInfo.height,
                    m = t.headerInfo.width,
                    g = m * v,
                    y = this.readHuffmanTree(e, t),
                    w = y.decodeLut,
                    b = y.tree,
                    k = y.stuffedData,
                    x = y.srcPtr,
                    A = y.bitPos,
                    P = y.numBitsLUTQick,
                    _ = y.numBitsLUT,
                    I = 0 === t.headerInfo.imageType ? 128 : 0,
                    S = t.pixels.resultMask,
                    T = 0;
                A > 0 && (x++, A = 0);
                var U,
                    O = k[x],
                    D = 1 === t.encodeMode,
                    E = new r(g * p),
                    R = E;

                if (p < 2 || D) {
                  for (U = 0; U < p; U++) {
                    if (p > 1 && (R = new r(E.buffer, g * U, g), T = 0), t.headerInfo.numValidPixel === m * v) for (h = 0, l = 0; l < v; l++) {
                      for (c = 0; c < m; c++, h++) {
                        if (a = 0, f = u = O << A >>> 32 - P, 32 - A < P && (f = u |= k[x + 1] >>> 64 - A - P), w[f]) a = w[f][1], A += w[f][0];else for (f = u = O << A >>> 32 - _, 32 - A < _ && (f = u |= k[x + 1] >>> 64 - A - _), i = b, d = 0; d < _; d++) {
                          if (!(i = u >>> _ - d - 1 & 1 ? i.right : i.left).left && !i.right) {
                            a = i.val, A = A + d + 1;
                            break;
                          }
                        }
                        A >= 32 && (A -= 32, O = k[++x]), s = a - I, D ? (s += c > 0 ? T : l > 0 ? R[h - m] : T, s &= 255, R[h] = s, T = s) : R[h] = s;
                      }
                    } else for (h = 0, l = 0; l < v; l++) {
                      for (c = 0; c < m; c++, h++) {
                        if (S[h]) {
                          if (a = 0, f = u = O << A >>> 32 - P, 32 - A < P && (f = u |= k[x + 1] >>> 64 - A - P), w[f]) a = w[f][1], A += w[f][0];else for (f = u = O << A >>> 32 - _, 32 - A < _ && (f = u |= k[x + 1] >>> 64 - A - _), i = b, d = 0; d < _; d++) {
                            if (!(i = u >>> _ - d - 1 & 1 ? i.right : i.left).left && !i.right) {
                              a = i.val, A = A + d + 1;
                              break;
                            }
                          }
                          A >= 32 && (A -= 32, O = k[++x]), s = a - I, D ? (c > 0 && S[h - 1] ? s += T : l > 0 && S[h - m] ? s += R[h - m] : s += T, s &= 255, R[h] = s, T = s) : R[h] = s;
                        }
                      }
                    }
                  }
                } else for (h = 0, l = 0; l < v; l++) {
                  for (c = 0; c < m; c++) {
                    if (h = l * m + c, !S || S[h]) for (U = 0; U < p; U++, h += g) {
                      if (a = 0, f = u = O << A >>> 32 - P, 32 - A < P && (f = u |= k[x + 1] >>> 64 - A - P), w[f]) a = w[f][1], A += w[f][0];else for (f = u = O << A >>> 32 - _, 32 - A < _ && (f = u |= k[x + 1] >>> 64 - A - _), i = b, d = 0; d < _; d++) {
                        if (!(i = u >>> _ - d - 1 & 1 ? i.right : i.left).left && !i.right) {
                          a = i.val, A = A + d + 1;
                          break;
                        }
                      }
                      A >= 32 && (A -= 32, O = k[++x]), s = a - I, R[h] = s;
                    }
                  }
                }

                t.ptr = t.ptr + 4 * (x + 1) + (A > 0 ? 4 : 0), t.pixels.resultPixels = E, p > 1 && !n && (t.pixels.resultPixels = o.swapDimensionOrder(E, g, p, r));
              },
              decodeBits: function decodeBits(o, s, u, f, l) {
                var c = s.headerInfo,
                    h = c.fileVersion,
                    d = 0,
                    p = o.byteLength - s.ptr >= 5 ? 5 : o.byteLength - s.ptr,
                    v = new DataView(o, s.ptr, p),
                    m = v.getUint8(0);
                d++;
                var g = m >> 6,
                    y = 0 === g ? 4 : 3 - g,
                    w = (32 & m) > 0,
                    b = 31 & m,
                    k = 0;
                if (1 === y) k = v.getUint8(d), d++;else if (2 === y) k = v.getUint16(d, !0), d += 2;else {
                  if (4 !== y) throw "Invalid valid pixel count type";
                  k = v.getUint32(d, !0), d += 4;
                }

                var x,
                    A,
                    P,
                    _,
                    I,
                    S,
                    T,
                    U,
                    O,
                    D = 2 * c.maxZError,
                    E = c.numDims > 1 ? c.maxValues[l] : c.zMax;

                if (w) {
                  for (s.counter.lut++, U = v.getUint8(d), d++, _ = Math.ceil((U - 1) * b / 8), I = Math.ceil(_ / 4), A = new ArrayBuffer(4 * I), P = new Uint8Array(A), s.ptr += d, P.set(new Uint8Array(o, s.ptr, _)), T = new Uint32Array(A), s.ptr += _, O = 0; U - 1 >>> O;) {
                    O++;
                  }

                  _ = Math.ceil(k * O / 8), I = Math.ceil(_ / 4), A = new ArrayBuffer(4 * I), (P = new Uint8Array(A)).set(new Uint8Array(o, s.ptr, _)), x = new Uint32Array(A), s.ptr += _, S = h >= 3 ? n(T, b, U - 1, f, D, E) : t(T, b, U - 1, f, D, E), h >= 3 ? r(x, u, O, k, S) : e(x, u, O, k, S);
                } else s.counter.bitstuffer++, O = b, s.ptr += d, O > 0 && (_ = Math.ceil(k * O / 8), I = Math.ceil(_ / 4), A = new ArrayBuffer(4 * I), (P = new Uint8Array(A)).set(new Uint8Array(o, s.ptr, _)), x = new Uint32Array(A), s.ptr += _, h >= 3 ? null == f ? a(x, u, O, k) : r(x, u, O, k, !1, f, D, E) : null == f ? i(x, u, O, k) : e(x, u, O, k, !1, f, D, E));
              },
              readTiles: function readTiles(e, t, r, n) {
                var i = t.headerInfo,
                    a = i.width,
                    s = i.height,
                    u = a * s,
                    f = i.microBlockSize,
                    l = i.imageType,
                    c = o.getDataTypeSize(l),
                    h = Math.ceil(a / f),
                    d = Math.ceil(s / f);
                t.pixels.numBlocksY = d, t.pixels.numBlocksX = h, t.pixels.ptr = 0;
                var p,
                    v,
                    m,
                    g,
                    y,
                    w,
                    b,
                    k,
                    x,
                    A,
                    P = 0,
                    _ = 0,
                    I = 0,
                    S = 0,
                    T = 0,
                    U = 0,
                    O = 0,
                    D = 0,
                    E = 0,
                    R = 0,
                    M = 0,
                    B = 0,
                    C = 0,
                    L = 0,
                    F = 0,
                    V = new r(f * f),
                    G = s % f || f,
                    j = a % f || f,
                    N = i.numDims,
                    z = t.pixels.resultMask,
                    K = t.pixels.resultPixels,
                    Z = i.fileVersion >= 5 ? 14 : 15,
                    H = i.zMax;

                for (I = 0; I < d; I++) {
                  for (T = I !== d - 1 ? f : G, S = 0; S < h; S++) {
                    for (R = I * a * f + S * f, M = a - (U = S !== h - 1 ? f : j), k = 0; k < N; k++) {
                      if (N > 1 ? (A = K, R = I * a * f + S * f, K = new r(t.pixels.resultPixels.buffer, u * k * c, u), H = i.maxValues[k]) : A = null, O = e.byteLength - t.ptr, v = {}, F = 0, D = (p = new DataView(e, t.ptr, Math.min(10, O))).getUint8(0), F++, x = i.fileVersion >= 5 ? 4 & D : 0, E = D >> 6 & 255, (D >> 2 & Z) !== (S * f >> 3 & Z)) throw "integrity issue";
                      if (x && 0 === k) throw "integrity issue";
                      if ((y = 3 & D) > 3) throw t.ptr += F, "Invalid block encoding (" + y + ")";
                      if (2 !== y) {
                        if (0 === y) {
                          if (x) throw "integrity issue";
                          if (t.counter.uncompressed++, t.ptr += F, B = (B = T * U * c) < (C = e.byteLength - t.ptr) ? B : C, m = new ArrayBuffer(B % c == 0 ? B : B + c - B % c), new Uint8Array(m).set(new Uint8Array(e, t.ptr, B)), g = new r(m), L = 0, z) for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              z[R] && (K[R] = g[L++]), R++;
                            }

                            R += M;
                          } else for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              K[R++] = g[L++];
                            }

                            R += M;
                          }
                          t.ptr += L * c;
                        } else if (w = o.getDataTypeUsed(x && l < 6 ? 4 : l, E), b = o.getOnePixel(v, F, w, p), F += o.getDataTypeSize(w), 3 === y) {
                          if (t.ptr += F, t.counter.constantoffset++, z) for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              z[R] && (K[R] = x ? Math.min(H, A[R] + b) : b), R++;
                            }

                            R += M;
                          } else for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              K[R] = x ? Math.min(H, A[R] + b) : b, R++;
                            }

                            R += M;
                          }
                        } else if (t.ptr += F, o.decodeBits(e, t, V, b, k), F = 0, x) {
                          if (z) for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              z[R] && (K[R] = V[F++] + A[R]), R++;
                            }

                            R += M;
                          } else for (P = 0; P < T; P++) {
                            for (_ = 0; _ < U; _++) {
                              K[R] = V[F++] + A[R], R++;
                            }

                            R += M;
                          }
                        } else if (z) for (P = 0; P < T; P++) {
                          for (_ = 0; _ < U; _++) {
                            z[R] && (K[R] = V[F++]), R++;
                          }

                          R += M;
                        } else for (P = 0; P < T; P++) {
                          for (_ = 0; _ < U; _++) {
                            K[R++] = V[F++];
                          }

                          R += M;
                        }
                      } else {
                        if (x) if (z) for (P = 0; P < T; P++) {
                          for (_ = 0; _ < U; _++) {
                            z[R] && (K[R] = A[R]), R++;
                          }
                        } else for (P = 0; P < T; P++) {
                          for (_ = 0; _ < U; _++) {
                            K[R] = A[R], R++;
                          }
                        }
                        t.counter.constant++, t.ptr += F;
                      }
                    }
                  }
                }

                N > 1 && !n && (t.pixels.resultPixels = o.swapDimensionOrder(t.pixels.resultPixels, u, N, r));
              },
              formatFileInfo: function formatFileInfo(e) {
                return {
                  fileIdentifierString: e.headerInfo.fileIdentifierString,
                  fileVersion: e.headerInfo.fileVersion,
                  imageType: e.headerInfo.imageType,
                  height: e.headerInfo.height,
                  width: e.headerInfo.width,
                  numValidPixel: e.headerInfo.numValidPixel,
                  microBlockSize: e.headerInfo.microBlockSize,
                  blobSize: e.headerInfo.blobSize,
                  maxZError: e.headerInfo.maxZError,
                  pixelType: o.getPixelType(e.headerInfo.imageType),
                  eofOffset: e.eofOffset,
                  mask: e.mask ? {
                    numBytes: e.mask.numBytes
                  } : null,
                  pixels: {
                    numBlocksX: e.pixels.numBlocksX,
                    numBlocksY: e.pixels.numBlocksY,
                    maxValue: e.headerInfo.zMax,
                    minValue: e.headerInfo.zMin,
                    noDataValue: e.noDataValue
                  }
                };
              },
              constructConstantSurface: function constructConstantSurface(e, t) {
                var r = e.headerInfo.zMax,
                    n = e.headerInfo.zMin,
                    i = e.headerInfo.maxValues,
                    a = e.headerInfo.numDims,
                    o = e.headerInfo.height * e.headerInfo.width,
                    s = 0,
                    u = 0,
                    f = 0,
                    l = e.pixels.resultMask,
                    c = e.pixels.resultPixels;
                if (l) {
                  if (a > 1) {
                    if (t) for (s = 0; s < a; s++) {
                      for (f = s * o, r = i[s], u = 0; u < o; u++) {
                        l[u] && (c[f + u] = r);
                      }
                    } else for (u = 0; u < o; u++) {
                      if (l[u]) for (f = u * a, s = 0; s < a; s++) {
                        c[f + a] = i[s];
                      }
                    }
                  } else for (u = 0; u < o; u++) {
                    l[u] && (c[u] = r);
                  }
                } else if (a > 1 && n !== r) {
                  if (t) for (s = 0; s < a; s++) {
                    for (f = s * o, r = i[s], u = 0; u < o; u++) {
                      c[f + u] = r;
                    }
                  } else for (u = 0; u < o; u++) {
                    for (f = u * a, s = 0; s < a; s++) {
                      c[f + s] = i[s];
                    }
                  }
                } else for (u = 0; u < o * a; u++) {
                  c[u] = r;
                }
              },
              getDataTypeArray: function getDataTypeArray(e) {
                var t;

                switch (e) {
                  case 0:
                    t = Int8Array;
                    break;

                  case 1:
                    t = Uint8Array;
                    break;

                  case 2:
                    t = Int16Array;
                    break;

                  case 3:
                    t = Uint16Array;
                    break;

                  case 4:
                    t = Int32Array;
                    break;

                  case 5:
                    t = Uint32Array;
                    break;

                  case 6:
                  default:
                    t = Float32Array;
                    break;

                  case 7:
                    t = Float64Array;
                }

                return t;
              },
              getPixelType: function getPixelType(e) {
                var t;

                switch (e) {
                  case 0:
                    t = "S8";
                    break;

                  case 1:
                    t = "U8";
                    break;

                  case 2:
                    t = "S16";
                    break;

                  case 3:
                    t = "U16";
                    break;

                  case 4:
                    t = "S32";
                    break;

                  case 5:
                    t = "U32";
                    break;

                  case 6:
                  default:
                    t = "F32";
                    break;

                  case 7:
                    t = "F64";
                }

                return t;
              },
              isValidPixelValue: function isValidPixelValue(e, t) {
                if (null == t) return !1;
                var r;

                switch (e) {
                  case 0:
                    r = t >= -128 && t <= 127;
                    break;

                  case 1:
                    r = t >= 0 && t <= 255;
                    break;

                  case 2:
                    r = t >= -32768 && t <= 32767;
                    break;

                  case 3:
                    r = t >= 0 && t <= 65536;
                    break;

                  case 4:
                    r = t >= -2147483648 && t <= 2147483647;
                    break;

                  case 5:
                    r = t >= 0 && t <= 4294967296;
                    break;

                  case 6:
                    r = t >= -34027999387901484e22 && t <= 34027999387901484e22;
                    break;

                  case 7:
                    r = t >= -17976931348623157e292 && t <= 17976931348623157e292;
                    break;

                  default:
                    r = !1;
                }

                return r;
              },
              getDataTypeSize: function getDataTypeSize(e) {
                var t = 0;

                switch (e) {
                  case 0:
                  case 1:
                    t = 1;
                    break;

                  case 2:
                  case 3:
                    t = 2;
                    break;

                  case 4:
                  case 5:
                  case 6:
                    t = 4;
                    break;

                  case 7:
                    t = 8;
                    break;

                  default:
                    t = e;
                }

                return t;
              },
              getDataTypeUsed: function getDataTypeUsed(e, t) {
                var r = e;

                switch (e) {
                  case 2:
                  case 4:
                    r = e - t;
                    break;

                  case 3:
                  case 5:
                    r = e - 2 * t;
                    break;

                  case 6:
                    r = 0 === t ? e : 1 === t ? 2 : 1;
                    break;

                  case 7:
                    r = 0 === t ? e : e - 2 * t + 1;
                    break;

                  default:
                    r = e;
                }

                return r;
              },
              getOnePixel: function getOnePixel(e, t, r, n) {
                var i = 0;

                switch (r) {
                  case 0:
                    i = n.getInt8(t);
                    break;

                  case 1:
                    i = n.getUint8(t);
                    break;

                  case 2:
                    i = n.getInt16(t, !0);
                    break;

                  case 3:
                    i = n.getUint16(t, !0);
                    break;

                  case 4:
                    i = n.getInt32(t, !0);
                    break;

                  case 5:
                    i = n.getUInt32(t, !0);
                    break;

                  case 6:
                    i = n.getFloat32(t, !0);
                    break;

                  case 7:
                    i = n.getFloat64(t, !0);
                    break;

                  default:
                    throw "the decoder does not understand this pixel type";
                }

                return i;
              },
              swapDimensionOrder: function swapDimensionOrder(e, t, r, n, i) {
                var a = 0,
                    o = 0,
                    s = 0,
                    u = 0,
                    f = e;
                if (r > 1) if (f = new n(t * r), i) for (a = 0; a < t; a++) {
                  for (u = a, s = 0; s < r; s++, u += t) {
                    f[u] = e[o++];
                  }
                } else for (a = 0; a < t; a++) {
                  for (u = a, s = 0; s < r; s++, u += t) {
                    f[o++] = e[u];
                  }
                }
                return f;
              }
            },
                s = function s(e, t, r) {
              this.val = e, this.left = t, this.right = r;
            },
                u = {
              decode: function decode(e, t) {
                var r = (t = t || {}).noDataValue,
                    n = 0,
                    i = {};
                i.ptr = t.inputOffset || 0, i.pixels = {}, o.readHeaderInfo(e, i);
                var a = i.headerInfo,
                    s = a.fileVersion,
                    u = o.getDataTypeArray(a.imageType);
                if (s > 5) throw "unsupported lerc version 2." + s;
                o.readMask(e, i), a.numValidPixel === a.width * a.height || i.pixels.resultMask || (i.pixels.resultMask = t.maskData);
                var f = a.width * a.height;
                i.pixels.resultPixels = new u(f * a.numDims), i.counter = {
                  onesweep: 0,
                  uncompressed: 0,
                  lut: 0,
                  bitstuffer: 0,
                  constant: 0,
                  constantoffset: 0
                };
                var l,
                    c = !t.returnPixelInterleavedDims;
                if (0 !== a.numValidPixel) if (a.zMax === a.zMin) o.constructConstantSurface(i, c);else if (s >= 4 && o.checkMinMaxRanges(e, i)) o.constructConstantSurface(i, c);else {
                  var h = new DataView(e, i.ptr, 2),
                      d = h.getUint8(0);
                  if (i.ptr++, d) o.readDataOneSweep(e, i, u, c);else if (s > 1 && a.imageType <= 1 && Math.abs(a.maxZError - .5) < 1e-5) {
                    var p = h.getUint8(1);
                    if (i.ptr++, i.encodeMode = p, p > 2 || s < 4 && p > 1) throw "Invalid Huffman flag " + p;
                    p ? o.readHuffman(e, i, u, c) : o.readTiles(e, i, u, c);
                  } else o.readTiles(e, i, u, c);
                }
                i.eofOffset = i.ptr, t.inputOffset ? (l = i.headerInfo.blobSize + t.inputOffset - i.ptr, Math.abs(l) >= 1 && (i.eofOffset = t.inputOffset + i.headerInfo.blobSize)) : (l = i.headerInfo.blobSize - i.ptr, Math.abs(l) >= 1 && (i.eofOffset = i.headerInfo.blobSize));
                var v = {
                  width: a.width,
                  height: a.height,
                  pixelData: i.pixels.resultPixels,
                  minValue: a.zMin,
                  maxValue: a.zMax,
                  validPixelCount: a.numValidPixel,
                  dimCount: a.numDims,
                  dimStats: {
                    minValues: a.minValues,
                    maxValues: a.maxValues
                  },
                  maskData: i.pixels.resultMask
                };

                if (i.pixels.resultMask && o.isValidPixelValue(a.imageType, r)) {
                  var m = i.pixels.resultMask;

                  for (n = 0; n < f; n++) {
                    m[n] || (v.pixelData[n] = r);
                  }

                  v.noDataValue = r;
                }

                return i.noDataValue = r, t.returnFileInfo && (v.fileInfo = o.formatFileInfo(i)), v;
              },
              getBandCount: function getBandCount(e) {
                for (var t = 0, r = 0, n = {
                  ptr: 0,
                  pixels: {}
                }; r < e.byteLength - 58;) {
                  o.readHeaderInfo(e, n), r += n.headerInfo.blobSize, t++, n.ptr = r;
                }

                return t;
              }
            };

            return u;
          }(),
              c = (s = new ArrayBuffer(4), u = new Uint8Array(s), new Uint32Array(s)[0] = 1, 1 === u[0]),
              h = {
            decode: function decode(e, t) {
              if (!c) throw "Big endian system is not supported.";
              var r,
                  n,
                  i = (t = t || {}).inputOffset || 0,
                  a = new Uint8Array(e, i, 10),
                  o = String.fromCharCode.apply(null, a);
              if ("CntZImage" === o.trim()) r = f, n = 1;else {
                if ("Lerc2" !== o.substring(0, 5)) throw "Unexpected file identifier string: " + o;
                r = l, n = 2;
              }

              for (var s, u, h, d, p, v, m = 0, g = e.byteLength - 10, y = [], w = {
                width: 0,
                height: 0,
                pixels: [],
                pixelType: t.pixelType,
                mask: null,
                statistics: []
              }, b = 0; i < g;) {
                var k = r.decode(e, {
                  inputOffset: i,
                  encodedMaskData: s,
                  maskData: h,
                  returnMask: 0 === m,
                  returnEncodedMask: 0 === m,
                  returnFileInfo: !0,
                  returnPixelInterleavedDims: t.returnPixelInterleavedDims,
                  pixelType: t.pixelType || null,
                  noDataValue: t.noDataValue || null
                });
                i = k.fileInfo.eofOffset, h = k.maskData, 0 === m && (s = k.encodedMaskData, w.width = k.width, w.height = k.height, w.dimCount = k.dimCount || 1, w.pixelType = k.pixelType || k.fileInfo.pixelType, w.mask = h), n > 1 && (h && y.push(h), k.fileInfo.mask && k.fileInfo.mask.numBytes > 0 && b++), m++, w.pixels.push(k.pixelData), w.statistics.push({
                  minValue: k.minValue,
                  maxValue: k.maxValue,
                  noDataValue: k.noDataValue,
                  dimStats: k.dimStats
                });
              }

              if (n > 1 && b > 1) {
                for (v = w.width * w.height, w.bandMasks = y, (h = new Uint8Array(v)).set(y[0]), d = 1; d < y.length; d++) {
                  for (u = y[d], p = 0; p < v; p++) {
                    h[p] = h[p] & u[p];
                  }
                }

                w.maskData = h;
              }

              return w;
            }
          };

          e.exports ? e.exports = h : this.Lerc = h;
        }();
      }(Gi);
      var ji = Gi.exports;

      function Ni(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var zi = function (e) {
        h(r, e);
        var t = Ni(r);

        function r(e) {
          var n;
          return b(this, r), (n = t.call(this)).planarConfiguration = void 0 !== e.PlanarConfiguration ? e.PlanarConfiguration : 1, n.samplesPerPixel = void 0 !== e.SamplesPerPixel ? e.SamplesPerPixel : 1, n.addCompression = e.LercParameters[oe.AddCompression], n;
        }

        return l(r, [{
          key: "decodeBlock",
          value: function value(e) {
            switch (this.addCompression) {
              case se.None:
                break;

              case se.Deflate:
                e = Ri(new Uint8Array(e)).buffer;
                break;

              default:
                throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression));
            }

            return ji.decode(e, {
              returnPixelInterleavedDims: 1 === this.planarConfiguration
            }).pixels[0].buffer;
          }
        }]), r;
      }(tn),
          Ki = Object.freeze({
        __proto__: null,
        "default": zi
      });

      function Zi(e) {
        var t = function () {
          if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
          if (Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;

          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;
          } catch (e) {
            return !1;
          }
        }();

        return function () {
          var r,
              n = m(e);

          if (t) {
            var i = m(this).constructor;
            r = Reflect.construct(n, arguments, i);
          } else r = n.apply(this, arguments);

          return v(this, r);
        };
      }

      var Hi = function (e) {
        h(n, e);
        var t,
            r = Zi(n);

        function n() {
          var e;
          if (b(this, n), e = r.call(this), "undefined" == typeof createImageBitmap) throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");
          if ("undefined" == typeof document && "undefined" == typeof OffscreenCanvas) throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");
          return e;
        }

        return l(n, [{
          key: "decode",
          value: (t = u(x.mark(function e(t, r) {
            var n, i, a, o;
            return x.wrap(function (e) {
              for (;;) {
                switch (e.prev = e.next) {
                  case 0:
                    return n = new Blob([r]), e.next = 3, createImageBitmap(n);

                  case 3:
                    return i = e.sent, "undefined" != typeof document ? ((a = document.createElement("canvas")).width = i.width, a.height = i.height) : a = new OffscreenCanvas(i.width, i.height), (o = a.getContext("2d")).drawImage(i, 0, 0), e.abrupt("return", o.getImageData(0, 0, i.width, i.height).data.buffer);

                  case 8:
                  case "end":
                    return e.stop();
                }
              }
            }, e);
          })), function (e, r) {
            return t.apply(this, arguments);
          })
        }]), n;
      }(tn),
          Yi = Object.freeze({
        __proto__: null,
        "default": Hi
      }),
          qi = Worker;

      var Xi = Object.freeze({
        __proto__: null,
        create: function create() {
          var e = 'function e(e,t,r,n,i,a,o){try{var s=e[a](o),f=s.value}catch(e){return void r(e)}s.done?t(f):Promise.resolve(f).then(n,i)}function t(t){return function(){var r=this,n=arguments;return new Promise((function(i,a){var o=t.apply(r,n);function s(t){e(o,i,a,s,f,"next",t)}function f(t){e(o,i,a,s,f,"throw",t)}s(void 0)}))}}function r(e){return r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r(e)}var n={exports:{}};!function(e){var t=function(e){var t,n=Object.prototype,i=n.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",s=a.asyncIterator||"@@asyncIterator",f=a.toStringTag||"@@toStringTag";function l(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},"")}catch(e){l=function(e,t,r){return e[t]=r}}function u(e,t,r,n){var i=t&&t.prototype instanceof y?t:y,a=Object.create(i.prototype),o=new T(n||[]);return a._invoke=function(e,t,r){var n=h;return function(i,a){if(n===p)throw new Error("Generator is already running");if(n===m){if("throw"===i)throw a;return E()}for(r.method=i,r.arg=a;;){var o=r.delegate;if(o){var s=I(o,r);if(s){if(s===v)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===h)throw n=m,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=p;var f=c(e,t,r);if("normal"===f.type){if(n=r.done?m:d,f.arg===v)continue;return{value:f.arg,done:r.done}}"throw"===f.type&&(n=m,r.method="throw",r.arg=f.arg)}}}(e,r,o),a}function c(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}e.wrap=u;var h="suspendedStart",d="suspendedYield",p="executing",m="completed",v={};function y(){}function w(){}function g(){}var b={};l(b,o,(function(){return this}));var k=Object.getPrototypeOf,x=k&&k(k(D([])));x&&x!==n&&i.call(x,o)&&(b=x);var _=g.prototype=y.prototype=Object.create(b);function A(e){["next","throw","return"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function P(e,t){function n(a,o,s,f){var l=c(e[a],e,o);if("throw"!==l.type){var u=l.arg,h=u.value;return h&&"object"===r(h)&&i.call(h,"__await")?t.resolve(h.__await).then((function(e){n("next",e,s,f)}),(function(e){n("throw",e,s,f)})):t.resolve(h).then((function(e){u.value=e,s(u)}),(function(e){return n("throw",e,s,f)}))}f(l.arg)}var a;this._invoke=function(e,r){function i(){return new t((function(t,i){n(e,r,t,i)}))}return a=a?a.then(i,i):i()}}function I(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,"throw"===r.method){if(e.iterator.return&&(r.method="return",r.arg=t,I(e,r),"throw"===r.method))return v;r.method="throw",r.arg=new TypeError("The iterator does not provide a \'throw\' method")}return v}var i=c(n,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,v;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,v):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,v)}function U(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function S(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function T(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(U,this),this.reset(!0)}function D(e){if(e){var r=e[o];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var n=-1,a=function r(){for(;++n<e.length;)if(i.call(e,n))return r.value=e[n],r.done=!1,r;return r.value=t,r.done=!0,r};return a.next=a}}return{next:E}}function E(){return{value:t,done:!0}}return w.prototype=g,l(_,"constructor",g),l(g,"constructor",w),w.displayName=l(g,f,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===w||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,g):(e.__proto__=g,l(e,f,"GeneratorFunction")),e.prototype=Object.create(_),e},e.awrap=function(e){return{__await:e}},A(P.prototype),l(P.prototype,s,(function(){return this})),e.AsyncIterator=P,e.async=function(t,r,n,i,a){void 0===a&&(a=Promise);var o=new P(u(t,r,n,i),a);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},A(_),l(_,f,"Generator"),l(_,o,(function(){return this})),l(_,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=D,T.prototype={constructor:T,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(S),!e)for(var r in this)"t"===r.charAt(0)&&i.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function n(n,i){return s.type="throw",s.arg=e,r.next=n,i&&(r.method="next",r.arg=t),!!i}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],s=o.completion;if("root"===o.tryLoc)return n("end");if(o.tryLoc<=this.prev){var f=i.call(o,"catchLoc"),l=i.call(o,"finallyLoc");if(f&&l){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(f){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var a=n;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=e,o.arg=t,a?(this.method="next",this.next=a.finallyLoc,v):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),v},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),S(r),v}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var i=n.arg;S(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:D(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),v}},e}(e.exports);try{regeneratorRuntime=t}catch(e){"object"===("undefined"==typeof globalThis?"undefined":r(globalThis))?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}}(n);var i=n.exports,a=new Map;function o(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){return a.set(e,t)}))}function s(e){return f.apply(this,arguments)}function f(){return(f=t(i.mark((function e(t){var r,n;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=a.get(t.Compression)){e.next=3;break}throw new Error("Unknown compression method identifier: ".concat(t.Compression));case 3:return e.next=5,r();case 5:return n=e.sent,e.abrupt("return",new n(t));case 7:case"end":return e.stop()}}),e)})))).apply(this,arguments)}o([void 0,1],(function(){return Promise.resolve().then((function(){return _})).then((function(e){return e.default}))})),o(5,(function(){return Promise.resolve().then((function(){return S})).then((function(e){return e.default}))})),o(6,(function(){throw new Error("old style JPEG compression is not supported.")})),o(7,(function(){return Promise.resolve().then((function(){return L})).then((function(e){return e.default}))})),o([8,32946],(function(){return Promise.resolve().then((function(){return Ne})).then((function(e){return e.default}))})),o(32773,(function(){return Promise.resolve().then((function(){return Ye})).then((function(e){return e.default}))})),o(34887,(function(){return Promise.resolve().then((function(){return ut})).then((function(e){return e.default}))})),o(50001,(function(){return Promise.resolve().then((function(){return dt})).then((function(e){return e.default}))}));var l=globalThis;function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function c(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function h(e,t,r){return t&&c(e.prototype,t),r&&c(e,r),e}function d(e,t){return d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},d(e,t)}function p(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&d(e,t)}function m(e,t){if(t&&("object"===r(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return e}(e)}function v(e){return v=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},v(e)}function y(e,t){var r=e.length-t,n=0;do{for(var i=t;i>0;i--)e[n+t]+=e[n],n++;r-=t}while(r>0)}function w(e,t,r){for(var n=0,i=e.length,a=i/r;i>t;){for(var o=t;o>0;--o)e[n+t]+=e[n],++n;i-=t}for(var s=e.slice(),f=0;f<a;++f)for(var l=0;l<r;++l)e[r*f+l]=s[(r-l-1)*a+f]}function g(e,t,r,n,i,a){if(!t||1===t)return e;for(var o=0;o<i.length;++o){if(i[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(i[o]!==i[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var s=i[0]/8,f=2===a?1:i.length,l=0;l<n&&!(l*f*r*s>=e.byteLength);++l){var u=void 0;if(2===t){switch(i[0]){case 8:u=new Uint8Array(e,l*f*r*s,f*r*s);break;case 16:u=new Uint16Array(e,l*f*r*s,f*r*s/2);break;case 32:u=new Uint32Array(e,l*f*r*s,f*r*s/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(i[0]," bits per sample."))}y(u,f)}else 3===t&&w(u=new Uint8Array(e,l*f*r*s,f*r*s),f,s)}return e}l.addEventListener("message",function(){var e=t(i.mark((function e(t){var r,n,a,o,f,u;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return r=t.data,n=r.id,a=r.fileDirectory,o=r.buffer,e.next=3,s(a);case 3:return f=e.sent,e.next=6,f.decode(a,o);case 6:u=e.sent,l.postMessage({decoded:u,id:n},[u]);case 8:case"end":return e.stop()}}),e)})));return function(t){return e.apply(this,arguments)}}());var b=function(){function e(){u(this,e)}var r;return h(e,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s,f;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.decodeBlock(r);case 2:if(n=e.sent,1===(a=t.Predictor||1)){e.next=9;break}return o=!t.StripOffsets,s=o?t.TileWidth:t.ImageWidth,f=o?t.TileLength:t.RowsPerStrip||t.ImageLength,e.abrupt("return",g(n,a,s,f,t.BitsPerSample,t.PlanarConfiguration));case 9:return e.abrupt("return",n);case 10:case"end":return e.stop()}}),e,this)}))),function(e,t){return r.apply(this,arguments)})}]),e}();function k(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var x=function(e){p(r,b);var t=k(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return e}}]),r}(),_=Object.freeze({__proto__:null,default:x});function A(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}function P(e,t){for(var r=t.length-1;r>=0;r--)e.push(t[r]);return e}function I(e){for(var t=new Uint16Array(4093),r=new Uint8Array(4093),n=0;n<=257;n++)t[n]=4096,r[n]=n;var i=258,a=9,o=0;function s(){i=258,a=9}function f(e){var t=function(e,t,r){var n=t%8,i=Math.floor(t/8),a=8-n,o=t+r-8*(i+1),s=8*(i+2)-(t+r),f=8*(i+2)-t;if(s=Math.max(0,s),i>=e.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),257;var l=e[i]&Math.pow(2,8-n)-1,u=l<<=r-a;if(i+1<e.length){var c=e[i+1]>>>s;u+=c<<=Math.max(0,r-f)}if(o>8&&i+2<e.length){var h=8*(i+3)-(t+r);u+=e[i+2]>>>h}return u}(e,o,a);return o+=a,t}function l(e,n){return r[i]=n,t[i]=e,++i-1}function u(e){for(var n=[],i=e;4096!==i;i=t[i])n.push(r[i]);return n}var c=[];s();for(var h,d=new Uint8Array(e),p=f(d);257!==p;){if(256===p){for(s(),p=f(d);256===p;)p=f(d);if(257===p)break;if(p>256)throw new Error("corrupted code at scanline ".concat(p));P(c,u(p)),h=p}else if(p<i){var m=u(p);P(c,m),l(h,m[m.length-1]),h=p}else{var v=u(h);if(!v)throw new Error("Bogus entry. Not in dictionary, ".concat(h," / ").concat(i,", position: ").concat(o));P(c,v),c.push(v[v.length-1]),l(h,v[v.length-1]),h=p}i+1>=Math.pow(2,a)&&(12===a?h=void 0:a++),p=f(d)}return new Uint8Array(c)}var U=function(e){p(r,b);var t=A(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return I(e).buffer}}]),r}(),S=Object.freeze({__proto__:null,default:U});function T(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var D=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]);function E(e,t){for(var r=0,n=[],i=16;i>0&&!e[i-1];)--i;n.push({children:[],index:0});for(var a,o=n[0],s=0;s<i;s++){for(var f=0;f<e[s];f++){for((o=n.pop()).children[o.index]=t[r];o.index>0;)o=n.pop();for(o.index++,n.push(o);n.length<=s;)n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a;r++}s+1<i&&(n.push(a={children:[],index:0}),o.children[o.index]=a.children,o=a)}return n[0].children}function B(e,t,n,i,a,o,s,f,l){var u=n.mcusPerLine,c=n.progressive,h=t,d=t,p=0,m=0;function v(){if(m>0)return m--,p>>m&1;if(255===(p=e[d++])){var t=e[d++];if(t)throw new Error("unexpected marker: ".concat((p<<8|t).toString(16)))}return m=7,p>>>7}function y(e){for(var t,n=e;null!==(t=v());){if("number"==typeof(n=n[t]))return n;if("object"!==r(n))throw new Error("invalid huffman sequence")}return null}function w(e){for(var t=e,r=0;t>0;){var n=v();if(null===n)return;r=r<<1|n,--t}return r}function g(e){var t=w(e);return t>=1<<e-1?t:t+(-1<<e)+1}var b=0;var k,x=0;function _(e,t,r,n,i){var a=r%u,o=(r/u|0)*e.v+n,s=a*e.h+i;t(e,e.blocks[o][s])}function A(e,t,r){var n=r/e.blocksPerLine|0,i=r%e.blocksPerLine;t(e,e.blocks[n][i])}var P,I,U,S,T,E,B=i.length;E=c?0===o?0===f?function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r)<<l;e.pred+=n,t[0]=e.pred}:function(e,t){t[0]|=v()<<l}:0===f?function(e,t){if(b>0)b--;else for(var r=o,n=s;r<=n;){var i=y(e.huffmanTableAC),a=15&i,f=i>>4;if(0===a){if(f<15){b=w(f)+(1<<f)-1;break}r+=16}else t[D[r+=f]]=g(a)*(1<<l),r++}}:function(e,t){for(var r=o,n=s,i=0;r<=n;){var a=D[r],f=t[a]<0?-1:1;switch(x){case 0:var u=y(e.huffmanTableAC),c=15&u;if(i=u>>4,0===c)i<15?(b=w(i)+(1<<i),x=4):(i=16,x=1);else{if(1!==c)throw new Error("invalid ACn encoding");k=g(c),x=i?2:3}continue;case 1:case 2:t[a]?t[a]+=(v()<<l)*f:0==--i&&(x=2===x?3:0);break;case 3:t[a]?t[a]+=(v()<<l)*f:(t[a]=k<<l,x=0);break;case 4:t[a]&&(t[a]+=(v()<<l)*f)}r++}4===x&&0==--b&&(x=0)}:function(e,t){var r=y(e.huffmanTableDC),n=0===r?0:g(r);e.pred+=n,t[0]=e.pred;for(var i=1;i<64;){var a=y(e.huffmanTableAC),o=15&a,s=a>>4;if(0===o){if(s<15)break;i+=16}else t[D[i+=s]]=g(o),i++}};var O,M,C=0;M=1===B?i[0].blocksPerLine*i[0].blocksPerColumn:u*n.mcusPerColumn;for(var L=a||M;C<M;){for(I=0;I<B;I++)i[I].pred=0;if(b=0,1===B)for(P=i[0],T=0;T<L;T++)A(P,E,C),C++;else for(T=0;T<L;T++){for(I=0;I<B;I++){var R=P=i[I],V=R.h,G=R.v;for(U=0;U<G;U++)for(S=0;S<V;S++)_(P,E,C,U,S)}if(++C===M)break}if(m=0,(O=e[d]<<8|e[d+1])<65280)throw new Error("marker was not found");if(!(O>=65488&&O<=65495))break;d+=2}return d-h}function O(e,t){var r=[],n=t.blocksPerLine,i=t.blocksPerColumn,a=n<<3,o=new Int32Array(64),s=new Uint8Array(64);function f(e,r,n){var i,a,o,s,f,l,u,c,h,d,p=t.quantizationTable,m=n;for(d=0;d<64;d++)m[d]=e[d]*p[d];for(d=0;d<8;++d){var v=8*d;0!==m[1+v]||0!==m[2+v]||0!==m[3+v]||0!==m[4+v]||0!==m[5+v]||0!==m[6+v]||0!==m[7+v]?(i=5793*m[0+v]+128>>8,a=5793*m[4+v]+128>>8,o=m[2+v],s=m[6+v],f=2896*(m[1+v]-m[7+v])+128>>8,c=2896*(m[1+v]+m[7+v])+128>>8,l=m[3+v]<<4,h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+128>>8,o=1567*o-3784*s+128>>8,s=h,h=f-(u=m[5+v]<<4)+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+v]=i+c,m[7+v]=i-c,m[1+v]=a+u,m[6+v]=a-u,m[2+v]=o+l,m[5+v]=o-l,m[3+v]=s+f,m[4+v]=s-f):(h=5793*m[0+v]+512>>10,m[0+v]=h,m[1+v]=h,m[2+v]=h,m[3+v]=h,m[4+v]=h,m[5+v]=h,m[6+v]=h,m[7+v]=h)}for(d=0;d<8;++d){var y=d;0!==m[8+y]||0!==m[16+y]||0!==m[24+y]||0!==m[32+y]||0!==m[40+y]||0!==m[48+y]||0!==m[56+y]?(i=5793*m[0+y]+2048>>12,a=5793*m[32+y]+2048>>12,o=m[16+y],s=m[48+y],f=2896*(m[8+y]-m[56+y])+2048>>12,c=2896*(m[8+y]+m[56+y])+2048>>12,l=m[24+y],h=i-a+1>>1,i=i+a+1>>1,a=h,h=3784*o+1567*s+2048>>12,o=1567*o-3784*s+2048>>12,s=h,h=f-(u=m[40+y])+1>>1,f=f+u+1>>1,u=h,h=c+l+1>>1,l=c-l+1>>1,c=h,h=i-s+1>>1,i=i+s+1>>1,s=h,h=a-o+1>>1,a=a+o+1>>1,o=h,h=2276*f+3406*c+2048>>12,f=3406*f-2276*c+2048>>12,c=h,h=799*l+4017*u+2048>>12,l=4017*l-799*u+2048>>12,u=h,m[0+y]=i+c,m[56+y]=i-c,m[8+y]=a+u,m[48+y]=a-u,m[16+y]=o+l,m[40+y]=o-l,m[24+y]=s+f,m[32+y]=s-f):(h=5793*n[d+0]+8192>>14,m[0+y]=h,m[8+y]=h,m[16+y]=h,m[24+y]=h,m[32+y]=h,m[40+y]=h,m[48+y]=h,m[56+y]=h)}for(d=0;d<64;++d){var w=128+(m[d]+8>>4);r[d]=w<0?0:w>255?255:w}}for(var l=0;l<i;l++){for(var u=l<<3,c=0;c<8;c++)r.push(new Uint8Array(a));for(var h=0;h<n;h++){f(t.blocks[l][h],s,o);for(var d=0,p=h<<3,m=0;m<8;m++)for(var v=r[u+m],y=0;y<8;y++)v[p+y]=s[d++]}}return r}var M=function(){function e(){u(this,e),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return h(e,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(e){var t=0;function r(){var r=e[t]<<8|e[t+1];return t+=2,r}function n(e){var t,r,n=0,i=0;for(r in e.components)e.components.hasOwnProperty(r)&&(n<(t=e.components[r]).h&&(n=t.h),i<t.v&&(i=t.v));var a=Math.ceil(e.samplesPerLine/8/n),o=Math.ceil(e.scanLines/8/i);for(r in e.components)if(e.components.hasOwnProperty(r)){t=e.components[r];for(var s=Math.ceil(Math.ceil(e.samplesPerLine/8)*t.h/n),f=Math.ceil(Math.ceil(e.scanLines/8)*t.v/i),l=a*t.h,u=o*t.v,c=[],h=0;h<u;h++){for(var d=[],p=0;p<l;p++)d.push(new Int32Array(64));c.push(d)}t.blocksPerLine=s,t.blocksPerColumn=f,t.blocks=c}e.maxH=n,e.maxV=i,e.mcusPerLine=a,e.mcusPerColumn=o}var i,a,o=r();if(65496!==o)throw new Error("SOI not found");for(o=r();65497!==o;){switch(o){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var s=(i=void 0,a=void 0,i=r(),a=e.subarray(t,t+i-2),t+=a.length,a);65504===o&&74===s[0]&&70===s[1]&&73===s[2]&&70===s[3]&&0===s[4]&&(this.jfif={version:{major:s[5],minor:s[6]},densityUnits:s[7],xDensity:s[8]<<8|s[9],yDensity:s[10]<<8|s[11],thumbWidth:s[12],thumbHeight:s[13],thumbData:s.subarray(14,14+3*s[12]*s[13])}),65518===o&&65===s[0]&&100===s[1]&&111===s[2]&&98===s[3]&&101===s[4]&&0===s[5]&&(this.adobe={version:s[6],flags0:s[7]<<8|s[8],flags1:s[9]<<8|s[10],transformCode:s[11]});break;case 65499:for(var f=r()+t-2;t<f;){var l=e[t++],u=new Int32Array(64);if(l>>4==0)for(var c=0;c<64;c++){u[D[c]]=e[t++]}else{if(l>>4!=1)throw new Error("DQT: invalid table spec");for(var h=0;h<64;h++){u[D[h]]=r()}}this.quantizationTables[15&l]=u}break;case 65472:case 65473:case 65474:r();for(var d={extended:65473===o,progressive:65474===o,precision:e[t++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},p=e[t++],m=void 0,v=0;v<p;v++){m=e[t];var y=e[t+1]>>4,w=15&e[t+1],g=e[t+2];d.componentsOrder.push(m),d.components[m]={h:y,v:w,quantizationIdx:g},t+=3}n(d),this.frames.push(d);break;case 65476:for(var b=r(),k=2;k<b;){for(var x=e[t++],_=new Uint8Array(16),A=0,P=0;P<16;P++,t++)_[P]=e[t],A+=_[P];for(var I=new Uint8Array(A),U=0;U<A;U++,t++)I[U]=e[t];k+=17+A,x>>4==0?this.huffmanTablesDC[15&x]=E(_,I):this.huffmanTablesAC[15&x]=E(_,I)}break;case 65501:r(),this.resetInterval=r();break;case 65498:r();for(var S=e[t++],T=[],O=this.frames[0],M=0;M<S;M++){var C=O.components[e[t++]],L=e[t++];C.huffmanTableDC=this.huffmanTablesDC[L>>4],C.huffmanTableAC=this.huffmanTablesAC[15&L],T.push(C)}var R=e[t++],V=e[t++],G=e[t++],F=B(e,t,O,T,this.resetInterval,R,V,G>>4,15&G);t+=F;break;case 65535:255!==e[t]&&t--;break;default:if(255===e[t-3]&&e[t-2]>=192&&e[t-2]<=254){t-=3;break}throw new Error("unknown JPEG marker ".concat(o.toString(16)))}o=r()}}},{key:"getResult",value:function(){var e=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var t=0;t<this.frames.length;t++)for(var r=this.frames[t].components,n=0,i=Object.keys(r);n<i.length;n++){var a=i[n];r[a].quantizationTable=this.quantizationTables[r[a].quantizationIdx],delete r[a].quantizationIdx}for(var o=e[0],s=o.components,f=o.componentsOrder,l=[],u=o.samplesPerLine,c=o.scanLines,h=0;h<f.length;h++){var d=s[f[h]];l.push({lines:O(0,d),scaleX:d.h/o.maxH,scaleY:d.v/o.maxV})}for(var p=new Uint8Array(u*c*l.length),m=0,v=0;v<c;++v)for(var y=0;y<u;++y)for(var w=0;w<l.length;++w){var g=l[w];p[m]=g.lines[0|v*g.scaleY][0|y*g.scaleX],++m}return p}}]),e}(),C=function(e){p(r,b);var t=T(r);function r(e){var n;return u(this,r),(n=t.call(this)).reader=new M,e.JPEGTables&&n.reader.parse(e.JPEGTables),n}return h(r,[{key:"decodeBlock",value:function(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}]),r}(),L=Object.freeze({__proto__:null,default:C});function R(e){for(var t=e.length;--t>=0;)e[t]=0}R(new Array(576)),R(new Array(60)),R(new Array(512)),R(new Array(256)),R(new Array(29)),R(new Array(30));var V=function(e,t,r,n){for(var i=65535&e|0,a=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{a=a+(i=i+t[n++]|0)|0}while(--o);i%=65521,a%=65521}return i|a<<16|0},G=new Uint32Array(function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}()),F=function(e,t,r,n){var i=G,a=n+r;e^=-1;for(var o=n;o<a;o++)e=e>>>8^i[255&(e^t[o])];return-1^e},z={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},j={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},N=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},Z=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var n=t.shift();if(n){if("object"!==r(n))throw new TypeError(n+"must be non-object");for(var i in n)N(n,i)&&(e[i]=n[i])}}return e},K=function(e){for(var t=0,r=0,n=e.length;r<n;r++)t+=e[r].length;for(var i=new Uint8Array(t),a=0,o=0,s=e.length;a<s;a++){var f=e[a];i.set(f,o),o+=f.length}return i},H=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){H=!1}for(var Y=new Uint8Array(256),X=0;X<256;X++)Y[X]=X>=252?6:X>=248?5:X>=240?4:X>=224?3:X>=192?2:1;Y[254]=Y[254]=1;var W=function(e){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);var t,r,n,i,a,o=e.length,s=0;for(i=0;i<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),s+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(s),a=0,i=0;a<s;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<o&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[a++]=r:r<2048?(t[a++]=192|r>>>6,t[a++]=128|63&r):r<65536?(t[a++]=224|r>>>12,t[a++]=128|r>>>6&63,t[a++]=128|63&r):(t[a++]=240|r>>>18,t[a++]=128|r>>>12&63,t[a++]=128|r>>>6&63,t[a++]=128|63&r);return t},q=function(e,t){var r,n,i=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));var a=new Array(2*i);for(n=0,r=0;r<i;){var o=e[r++];if(o<128)a[n++]=o;else{var s=Y[o];if(s>4)a[n++]=65533,r+=s-1;else{for(o&=2===s?31:3===s?15:7;s>1&&r<i;)o=o<<6|63&e[r++],s--;s>1?a[n++]=65533:o<65536?a[n++]=o:(o-=65536,a[n++]=55296|o>>10&1023,a[n++]=56320|1023&o)}}}return function(e,t){if(t<65534&&e.subarray&&H)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}(a,n)},J=function(e,t){(t=t||e.length)>e.length&&(t=e.length);for(var r=t-1;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+Y[e[r]]>t?r:t};var Q=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0},$=function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=e.state;r=e.next_in,A=e.input,n=r+(e.avail_in-5),i=e.next_out,P=e.output,a=i-(t-e.avail_out),o=i+(e.avail_out-257),s=I.dmax,f=I.wsize,l=I.whave,u=I.wnext,c=I.window,h=I.hold,d=I.bits,p=I.lencode,m=I.distcode,v=(1<<I.lenbits)-1,y=(1<<I.distbits)-1;e:do{d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=p[h&v];t:for(;;){if(h>>>=g=w>>>24,d-=g,0===(g=w>>>16&255))P[i++]=65535&w;else{if(!(16&g)){if(0==(64&g)){w=p[(65535&w)+(h&(1<<g)-1)];continue t}if(32&g){I.mode=12;break e}e.msg="invalid literal/length code",I.mode=30;break e}b=65535&w,(g&=15)&&(d<g&&(h+=A[r++]<<d,d+=8),b+=h&(1<<g)-1,h>>>=g,d-=g),d<15&&(h+=A[r++]<<d,d+=8,h+=A[r++]<<d,d+=8),w=m[h&y];r:for(;;){if(h>>>=g=w>>>24,d-=g,!(16&(g=w>>>16&255))){if(0==(64&g)){w=m[(65535&w)+(h&(1<<g)-1)];continue r}e.msg="invalid distance code",I.mode=30;break e}if(k=65535&w,d<(g&=15)&&(h+=A[r++]<<d,(d+=8)<g&&(h+=A[r++]<<d,d+=8)),(k+=h&(1<<g)-1)>s){e.msg="invalid distance too far back",I.mode=30;break e}if(h>>>=g,d-=g,k>(g=i-a)){if((g=k-g)>l&&I.sane){e.msg="invalid distance too far back",I.mode=30;break e}if(x=0,_=c,0===u){if(x+=f-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}else if(u<g){if(x+=f+u-g,(g-=u)<b){b-=g;do{P[i++]=c[x++]}while(--g);if(x=0,u<b){b-=g=u;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}}}else if(x+=u-g,g<b){b-=g;do{P[i++]=c[x++]}while(--g);x=i-k,_=P}for(;b>2;)P[i++]=_[x++],P[i++]=_[x++],P[i++]=_[x++],b-=3;b&&(P[i++]=_[x++],b>1&&(P[i++]=_[x++]))}else{x=i-k;do{P[i++]=P[x++],P[i++]=P[x++],P[i++]=P[x++],b-=3}while(b>2);b&&(P[i++]=P[x++],b>1&&(P[i++]=P[x++]))}break}}break}}while(r<n&&i<o);r-=b=d>>3,h&=(1<<(d-=b<<3))-1,e.next_in=r,e.next_out=i,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=i<o?o-i+257:257-(i-o),I.hold=h,I.bits=d},ee=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),te=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),re=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),ne=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),ie=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d,p,m,v,y=s.bits,w=0,g=0,b=0,k=0,x=0,_=0,A=0,P=0,I=0,U=0,S=null,T=0,D=new Uint16Array(16),E=new Uint16Array(16),B=null,O=0;for(w=0;w<=15;w++)D[w]=0;for(g=0;g<n;g++)D[t[r+g]]++;for(x=y,k=15;k>=1&&0===D[k];k--);if(x>k&&(x=k),0===k)return i[a++]=20971520,i[a++]=20971520,s.bits=1,0;for(b=1;b<k&&0===D[b];b++);for(x<b&&(x=b),P=1,w=1;w<=15;w++)if(P<<=1,(P-=D[w])<0)return-1;if(P>0&&(0===e||1!==k))return-1;for(E[1]=0,w=1;w<15;w++)E[w+1]=E[w]+D[w];for(g=0;g<n;g++)0!==t[r+g]&&(o[E[t[r+g]]++]=g);if(0===e?(S=B=o,d=19):1===e?(S=ee,T-=257,B=te,O-=257,d=256):(S=re,B=ne,d=-1),U=0,g=0,w=b,h=a,_=x,A=0,u=-1,c=(I=1<<x)-1,1===e&&I>852||2===e&&I>592)return 1;for(;;){p=w-A,o[g]<d?(m=0,v=o[g]):o[g]>d?(m=B[O+o[g]],v=S[T+o[g]]):(m=96,v=0),f=1<<w-A,b=l=1<<_;do{i[h+(U>>A)+(l-=f)]=p<<24|m<<16|v|0}while(0!==l);for(f=1<<w-1;U&f;)f>>=1;if(0!==f?(U&=f-1,U+=f):U=0,g++,0==--D[w]){if(w===k)break;w=t[r+o[g]]}if(w>x&&(U&c)!==u){for(0===A&&(A=x),h+=b,P=1<<(_=w-A);_+A<k&&!((P-=D[_+A])<=0);)_++,P<<=1;if(I+=1<<_,1===e&&I>852||2===e&&I>592)return 1;i[u=U&c]=x<<24|_<<16|h-a|0}}return 0!==U&&(i[h+U]=w-A<<24|64<<16|0),s.bits=x,0},ae=j.Z_FINISH,oe=j.Z_BLOCK,se=j.Z_TREES,fe=j.Z_OK,le=j.Z_STREAM_END,ue=j.Z_NEED_DICT,ce=j.Z_STREAM_ERROR,he=j.Z_DATA_ERROR,de=j.Z_MEM_ERROR,pe=j.Z_BUF_ERROR,me=j.Z_DEFLATED,ve=function(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)};function ye(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var we,ge,be=function(e){if(!e||!e.state)return ce;var t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=1,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,fe},ke=function(e){if(!e||!e.state)return ce;var t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,be(e)},xe=function(e,t){var r;if(!e||!e.state)return ce;var n=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?ce:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,ke(e))},_e=function(e,t){if(!e)return ce;var r=new ye;e.state=r,r.window=null;var n=xe(e,t);return n!==fe&&(e.state=null),n},Ae=!0,Pe=function(e){if(Ae){we=new Int32Array(512),ge=new Int32Array(32);for(var t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(ie(1,e.lens,0,288,we,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;ie(2,e.lens,0,32,ge,0,e.work,{bits:5}),Ae=!1}e.lencode=we,e.lenbits=9,e.distcode=ge,e.distbits=5},Ie=function(e,t,r,n){var i,a=e.state;return null===a.window&&(a.wsize=1<<a.wbits,a.wnext=0,a.whave=0,a.window=new Uint8Array(a.wsize)),n>=a.wsize?(a.window.set(t.subarray(r-a.wsize,r),0),a.wnext=0,a.whave=a.wsize):((i=a.wsize-a.wnext)>n&&(i=n),a.window.set(t.subarray(r-n,r-n+i),a.wnext),(n-=i)?(a.window.set(t.subarray(r-n,r),0),a.wnext=n,a.whave=a.wsize):(a.wnext+=i,a.wnext===a.wsize&&(a.wnext=0),a.whave<a.wsize&&(a.whave+=i))),0},Ue={inflateReset:ke,inflateReset2:xe,inflateResetKeep:be,inflateInit:function(e){return _e(e,15)},inflateInit2:_e,inflate:function(e,t){var r,n,i,a,o,s,f,l,u,c,h,d,p,m,v,y,w,g,b,k,x,_,A,P,I=0,U=new Uint8Array(4),S=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return ce;12===(r=e.state).mode&&(r.mode=13),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,c=s,h=f,_=fe;e:for(;;)switch(r.mode){case 1:if(0===r.wrap){r.mode=13;break}for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(2&r.wrap&&35615===l){r.check=0,U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0),l=0,u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&l)<<8)+(l>>8))%31){e.msg="incorrect header check",r.mode=30;break}if((15&l)!==me){e.msg="unknown compression method",r.mode=30;break}if(u-=4,x=8+(15&(l>>>=4)),0===r.wbits)r.wbits=x;else if(x>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&l?10:12,l=0,u=0;break;case 2:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.flags=l,(255&r.flags)!==me){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=l>>8&1),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=3;case 3:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.time=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,U[2]=l>>>16&255,U[3]=l>>>24&255,r.check=F(r.check,U,4,0)),l=0,u=0,r.mode=4;case 4:for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.head&&(r.head.xflags=255&l,r.head.os=l>>8),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0,r.mode=5;case 5:if(1024&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length=l,r.head&&(r.head.extra_len=l),512&r.flags&&(U[0]=255&l,U[1]=l>>>8&255,r.check=F(r.check,U,2,0)),l=0,u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&((d=r.length)>s&&(d=s),d&&(r.head&&(x=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(a,a+d),x)),512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.name+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===s)break e;d=0;do{x=n[a+d++],r.head&&x&&r.length<65536&&(r.head.comment+=String.fromCharCode(x))}while(x&&d<s);if(512&r.flags&&(r.check=F(r.check,n,d,a)),s-=d,a+=d,x)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;u<16;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=0,u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}e.adler=r.check=ve(l),l=0,u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,ue;e.adler=r.check=1,r.mode=12;case 12:if(t===oe||t===se)break e;case 13:if(r.last){l>>>=7&u,u-=7&u,r.mode=27;break}for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}switch(r.last=1&l,u-=1,3&(l>>>=1)){case 0:r.mode=14;break;case 1:if(Pe(r),r.mode=20,t===se){l>>>=2,u-=2;break e}break;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30}l>>>=2,u-=2;break;case 14:for(l>>>=7&u,u-=7&u;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if((65535&l)!=(l>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&l,l=0,u=0,r.mode=15,t===se)break e;case 15:r.mode=16;case 16:if(d=r.length){if(d>s&&(d=s),d>f&&(d=f),0===d)break e;i.set(n.subarray(a,a+d),o),s-=d,a+=d,f-=d,o+=d,r.length-=d;break}r.mode=12;break;case 17:for(;u<14;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(r.nlen=257+(31&l),l>>>=5,u-=5,r.ndist=1+(31&l),l>>>=5,u-=5,r.ncode=4+(15&l),l>>>=4,u-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;u<3;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.lens[S[r.have++]]=7&l,l>>>=3,u-=3}for(;r.have<19;)r.lens[S[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,A={bits:r.lenbits},_=ie(0,r.lens,0,19,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(w<16)l>>>=v,u-=v,r.lens[r.have++]=w;else{if(16===w){for(P=v+2;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l>>>=v,u-=v,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}x=r.lens[r.have-1],d=3+(3&l),l>>>=2,u-=2}else if(17===w){for(P=v+3;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=3+(7&(l>>>=v)),l>>>=3,u-=3}else{for(P=v+7;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}u-=v,x=0,d=11+(127&(l>>>=v)),l>>>=7,u-=7}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=x}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,A={bits:r.lenbits},_=ie(1,r.lens,0,r.nlen,r.lencode,0,r.work,A),r.lenbits=A.bits,_){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,A={bits:r.distbits},_=ie(2,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,A),r.distbits=A.bits,_){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,t===se)break e;case 20:r.mode=21;case 21:if(s>=6&&f>=258){e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,$(e,h),o=e.next_out,i=e.output,f=e.avail_out,a=e.next_in,n=e.input,s=e.avail_in,l=r.hold,u=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;y=(I=r.lencode[l&(1<<r.lenbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(y&&0==(240&y)){for(g=v,b=y,k=w;y=(I=r.lencode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,r.length=w,0===y){r.mode=26;break}if(32&y){r.back=-1,r.mode=12;break}if(64&y){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&y,r.mode=22;case 22:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.length+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;y=(I=r.distcode[l&(1<<r.distbits)-1])>>>16&255,w=65535&I,!((v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(0==(240&y)){for(g=v,b=y,k=w;y=(I=r.distcode[k+((l&(1<<g+b)-1)>>g)])>>>16&255,w=65535&I,!(g+(v=I>>>24)<=u);){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}l>>>=g,u-=g,r.back+=g}if(l>>>=v,u-=v,r.back+=v,64&y){e.msg="invalid distance code",r.mode=30;break}r.offset=w,r.extra=15&y,r.mode=24;case 24:if(r.extra){for(P=r.extra;u<P;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}r.offset+=l&(1<<r.extra)-1,l>>>=r.extra,u-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===f)break e;if(d=h-f,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}d>r.wnext?(d-=r.wnext,p=r.wsize-d):p=r.wnext-d,d>r.length&&(d=r.length),m=r.window}else m=i,p=o-r.offset,d=r.length;d>f&&(d=f),f-=d,r.length-=d;do{i[o++]=m[p++]}while(--d);0===r.length&&(r.mode=21);break;case 26:if(0===f)break e;i[o++]=r.length,f--,r.mode=21;break;case 27:if(r.wrap){for(;u<32;){if(0===s)break e;s--,l|=n[a++]<<u,u+=8}if(h-=f,e.total_out+=h,r.total+=h,h&&(e.adler=r.check=r.flags?F(r.check,i,h,o-h):V(r.check,i,h,o-h)),h=f,(r.flags?l:ve(l))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=0,u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;u<32;){if(0===s)break e;s--,l+=n[a++]<<u,u+=8}if(l!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=0,u=0}r.mode=29;case 29:_=le;break e;case 30:_=he;break e;case 31:return de;default:return ce}return e.next_out=o,e.avail_out=f,e.next_in=a,e.avail_in=s,r.hold=l,r.bits=u,(r.wsize||h!==e.avail_out&&r.mode<30&&(r.mode<27||t!==ae))&&Ie(e,e.output,e.next_out,h-e.avail_out),c-=e.avail_in,h-=e.avail_out,e.total_in+=c,e.total_out+=h,r.total+=h,r.wrap&&h&&(e.adler=r.check=r.flags?F(r.check,i,h,e.next_out-h):V(r.check,i,h,e.next_out-h)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0===c&&0===h||t===ae)&&_===fe&&(_=pe),_},inflateEnd:function(e){if(!e||!e.state)return ce;var t=e.state;return t.window&&(t.window=null),e.state=null,fe},inflateGetHeader:function(e,t){if(!e||!e.state)return ce;var r=e.state;return 0==(2&r.wrap)?ce:(r.head=t,t.done=!1,fe)},inflateSetDictionary:function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?ce:11===r.mode&&V(1,t,n,0)!==r.check?he:Ie(e,t,n,n)?(r.mode=31,de):(r.havedict=1,fe):ce},inflateInfo:"pako inflate (from Nodeca project)"};var Se=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1},Te=Object.prototype.toString,De=j.Z_NO_FLUSH,Ee=j.Z_FINISH,Be=j.Z_OK,Oe=j.Z_STREAM_END,Me=j.Z_NEED_DICT,Ce=j.Z_STREAM_ERROR,Le=j.Z_DATA_ERROR,Re=j.Z_MEM_ERROR;function Ve(e){this.options=Z({chunkSize:65536,windowBits:15,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new Q,this.strm.avail_out=0;var r=Ue.inflateInit2(this.strm,t.windowBits);if(r!==Be)throw new Error(z[r]);if(this.header=new Se,Ue.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=W(t.dictionary):"[object ArrayBuffer]"===Te.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=Ue.inflateSetDictionary(this.strm,t.dictionary))!==Be))throw new Error(z[r])}function Ge(e,t){var r=new Ve(t);if(r.push(e),r.err)throw r.msg||z[r.err];return r.result}Ve.prototype.push=function(e,t){var r,n,i,a=this.strm,o=this.options.chunkSize,s=this.options.dictionary;if(this.ended)return!1;for(n=t===~~t?t:!0===t?Ee:De,"[object ArrayBuffer]"===Te.call(e)?a.input=new Uint8Array(e):a.input=e,a.next_in=0,a.avail_in=a.input.length;;){for(0===a.avail_out&&(a.output=new Uint8Array(o),a.next_out=0,a.avail_out=o),(r=Ue.inflate(a,n))===Me&&s&&((r=Ue.inflateSetDictionary(a,s))===Be?r=Ue.inflate(a,n):r===Le&&(r=Me));a.avail_in>0&&r===Oe&&a.state.wrap>0&&0!==e[a.next_in];)Ue.inflateReset(a),r=Ue.inflate(a,n);switch(r){case Ce:case Le:case Me:case Re:return this.onEnd(r),this.ended=!0,!1}if(i=a.avail_out,a.next_out&&(0===a.avail_out||r===Oe))if("string"===this.options.to){var f=J(a.output,a.next_out),l=a.next_out-f,u=q(a.output,f);a.next_out=l,a.avail_out=o-l,l&&a.output.set(a.output.subarray(f,f+l),0),this.onData(u)}else this.onData(a.output.length===a.next_out?a.output:a.output.subarray(0,a.next_out));if(r!==Be||0!==i){if(r===Oe)return r=Ue.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===a.avail_in)break}}return!0},Ve.prototype.onData=function(e){this.chunks.push(e)},Ve.prototype.onEnd=function(e){e===Be&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=K(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Fe={Inflate:Ve,inflate:Ge,inflateRaw:function(e,t){return(t=t||{}).raw=!0,Ge(e,t)},ungzip:Ge,constants:j}.inflate;function ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var je=function(e){p(r,b);var t=ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){return Fe(new Uint8Array(e)).buffer}}]),r}(),Ne=Object.freeze({__proto__:null,default:je});function Ze(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var Ke,He=function(e){p(r,b);var t=Ze(r);function r(){return u(this,r),t.apply(this,arguments)}return h(r,[{key:"decodeBlock",value:function(e){for(var t=new DataView(e),r=[],n=0;n<e.byteLength;++n){var i=t.getInt8(n);if(i<0){var a=t.getUint8(n+1);i=-i;for(var o=0;o<=i;++o)r.push(a);n+=1}else{for(var s=0;s<=i;++s)r.push(t.getUint8(n+s+1));n+=i+1}}return new Uint8Array(r).buffer}}]),r}(),Ye=Object.freeze({__proto__:null,default:He}),Xe={exports:{}};Ke=Xe,\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\nfunction(){var e,t,r,n,i,a,o,s,f,l,u,c,h,d,p,m,v=(e={defaultNoDataValue:-34027999387901484e22,decode:function(a,o){var s=(o=o||{}).encodedMaskData||null===o.encodedMaskData,f=i(a,o.inputOffset||0,s),l=null!==o.noDataValue?o.noDataValue:e.defaultNoDataValue,u=t(f,o.pixelType||Float32Array,o.encodedMaskData,l,o.returnMask),c={width:f.width,height:f.height,pixelData:u.resultPixels,minValue:u.minValue,maxValue:f.pixels.maxValue,noDataValue:l};return u.resultMask&&(c.maskData=u.resultMask),o.returnEncodedMask&&f.mask&&(c.encodedMaskData=f.mask.bitset?f.mask.bitset:null),o.returnFileInfo&&(c.fileInfo=r(f),o.computeUsedBitDepths&&(c.fileInfo.bitDepths=n(f))),c}},t=function(e,t,r,n,i){var o,s,f,l=0,u=e.pixels.numBlocksX,c=e.pixels.numBlocksY,h=Math.floor(e.width/u),d=Math.floor(e.height/c),p=2*e.maxZError,m=Number.MAX_VALUE;r=r||(e.mask?e.mask.bitset:null),s=new t(e.width*e.height),i&&r&&(f=new Uint8Array(e.width*e.height));for(var v,y,w=new Float32Array(h*d),g=0;g<=c;g++){var b=g!==c?d:e.height%c;if(0!==b)for(var k=0;k<=u;k++){var x=k!==u?h:e.width%u;if(0!==x){var _,A,P,I,U=g*e.width*d+k*h,S=e.width-x,T=e.pixels.blocks[l];if(T.encoding<2?(0===T.encoding?_=T.rawData:(a(T.stuffedData,T.bitsPerPixel,T.numValidPixels,T.offset,p,w,e.pixels.maxValue),_=w),A=0):P=2===T.encoding?0:T.offset,r)for(y=0;y<b;y++){for(7&U&&(I=r[U>>3],I<<=7&U),v=0;v<x;v++)7&U||(I=r[U>>3]),128&I?(f&&(f[U]=1),m=m>(o=T.encoding<2?_[A++]:P)?o:m,s[U++]=o):(f&&(f[U]=0),s[U++]=n),I<<=1;U+=S}else if(T.encoding<2)for(y=0;y<b;y++){for(v=0;v<x;v++)m=m>(o=_[A++])?o:m,s[U++]=o;U+=S}else for(m=m>P?P:m,y=0;y<b;y++){for(v=0;v<x;v++)s[U++]=P;U+=S}if(1===T.encoding&&A!==T.numValidPixels)throw"Block and Mask do not match";l++}}}return{resultPixels:s,resultMask:f,minValue:m}},r=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},n=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,r={},n=0;n<t;n++){var i=e.pixels.blocks[n];0===i.encoding?r.float32=!0:1===i.encoding?r[i.bitsPerPixel]=!0:r[0]=!0}return Object.keys(r)},i=function(e,t,r){var n={},i=new Uint8Array(e,t,10);if(n.fileIdentifierString=String.fromCharCode.apply(null,i),"CntZImage"!==n.fileIdentifierString.trim())throw"Unexpected file identifier string: "+n.fileIdentifierString;t+=10;var a=new DataView(e,t,24);if(n.fileVersion=a.getInt32(0,!0),n.imageType=a.getInt32(4,!0),n.height=a.getUint32(8,!0),n.width=a.getUint32(12,!0),n.maxZError=a.getFloat64(16,!0),t+=24,!r)if(a=new DataView(e,t,16),n.mask={},n.mask.numBlocksY=a.getUint32(0,!0),n.mask.numBlocksX=a.getUint32(4,!0),n.mask.numBytes=a.getUint32(8,!0),n.mask.maxValue=a.getFloat32(12,!0),t+=16,n.mask.numBytes>0){var o=new Uint8Array(Math.ceil(n.width*n.height/8)),s=(a=new DataView(e,t,n.mask.numBytes)).getInt16(0,!0),f=2,l=0;do{if(s>0)for(;s--;)o[l++]=a.getUint8(f++);else{var u=a.getUint8(f++);for(s=-s;s--;)o[l++]=u}s=a.getInt16(f,!0),f+=2}while(f<n.mask.numBytes);if(-32768!==s||l<o.length)throw"Unexpected end of mask RLE encoding";n.mask.bitset=o,t+=n.mask.numBytes}else 0==(n.mask.numBytes|n.mask.numBlocksY|n.mask.maxValue)&&(n.mask.bitset=new Uint8Array(Math.ceil(n.width*n.height/8)));a=new DataView(e,t,16),n.pixels={},n.pixels.numBlocksY=a.getUint32(0,!0),n.pixels.numBlocksX=a.getUint32(4,!0),n.pixels.numBytes=a.getUint32(8,!0),n.pixels.maxValue=a.getFloat32(12,!0),t+=16;var c=n.pixels.numBlocksX,h=n.pixels.numBlocksY,d=c+(n.width%c>0?1:0),p=h+(n.height%h>0?1:0);n.pixels.blocks=new Array(d*p);for(var m=0,v=0;v<p;v++)for(var y=0;y<d;y++){var w=0,g=e.byteLength-t;a=new DataView(e,t,Math.min(10,g));var b={};n.pixels.blocks[m++]=b;var k=a.getUint8(0);if(w++,b.encoding=63&k,b.encoding>3)throw"Invalid block encoding ("+b.encoding+")";if(2!==b.encoding){if(0!==k&&2!==k){if(k>>=6,b.offsetType=k,2===k)b.offset=a.getInt8(1),w++;else if(1===k)b.offset=a.getInt16(1,!0),w+=2;else{if(0!==k)throw"Invalid block offset type";b.offset=a.getFloat32(1,!0),w+=4}if(1===b.encoding)if(k=a.getUint8(w),w++,b.bitsPerPixel=63&k,k>>=6,b.numValidPixelsType=k,2===k)b.numValidPixels=a.getUint8(w),w++;else if(1===k)b.numValidPixels=a.getUint16(w,!0),w+=2;else{if(0!==k)throw"Invalid valid pixel count type";b.numValidPixels=a.getUint32(w,!0),w+=4}}var x;if(t+=w,3!==b.encoding)if(0===b.encoding){var _=(n.pixels.numBytes-1)/4;if(_!==Math.floor(_))throw"uncompressed block has invalid length";x=new ArrayBuffer(4*_),new Uint8Array(x).set(new Uint8Array(e,t,4*_));var A=new Float32Array(x);b.rawData=A,t+=4*_}else if(1===b.encoding){var P=Math.ceil(b.numValidPixels*b.bitsPerPixel/8),I=Math.ceil(P/4);x=new ArrayBuffer(4*I),new Uint8Array(x).set(new Uint8Array(e,t,P)),b.stuffedData=new Uint32Array(x),t+=P}}else t++}return n.eofOffset=t,n},a=function(e,t,r,n,i,a,o){var s,f,l,u=(1<<t)-1,c=0,h=0,d=Math.ceil((o-n)/i),p=4*e.length-Math.ceil(t*r/8);for(e[e.length-1]<<=8*p,s=0;s<r;s++){if(0===h&&(l=e[c++],h=32),h>=t)f=l>>>h-t&u,h-=t;else{var m=t-h;f=(l&u)<<m&u,f+=(l=e[c++])>>>(h=32-m)}a[s]=f<d?n+f*i:o}return a},e),y=(o=function(e,t,r,n,i,a,o,s){var f,l,u,c,h,d=(1<<r)-1,p=0,m=0,v=4*e.length-Math.ceil(r*n/8);if(e[e.length-1]<<=8*v,i)for(f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=i[l];else for(h=Math.ceil((s-a)/o),f=0;f<n;f++)0===m&&(u=e[p++],m=32),m>=r?(l=u>>>m-r&d,m-=r):(l=(u&d)<<(c=r-m)&d,l+=(u=e[p++])>>>(m=32-c)),t[f]=l<h?a+l*o:s},s=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=[],p=4*e.length-Math.ceil(t*r/8);e[e.length-1]<<=8*p;var m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32),c>=t?(h=o>>>c-t&s,c-=t):(h=(o&s)<<(u=t-c)&s,h+=(o=e[f++])>>>(c=32-u)),d[l]=h<m?n+h*i:a;return d.unshift(n),d},f=function(e,t,r,n,i,a,o,s){var f,l,u,c,h=(1<<r)-1,d=0,p=0,m=0;if(i)for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=i[l];else{var v=Math.ceil((s-a)/o);for(f=0;f<n;f++)0===p&&(u=e[d++],p=32,m=0),p>=r?(l=u>>>m&h,p-=r,m+=r):(l=u>>>m&h,p=32-(c=r-p),l|=((u=e[d++])&(1<<c)-1)<<r-c,m=c),t[f]=l<v?a+l*o:s}return t},l=function(e,t,r,n,i,a){var o,s=(1<<t)-1,f=0,l=0,u=0,c=0,h=0,d=0,p=[],m=Math.ceil((a-n)/i);for(l=0;l<r;l++)0===c&&(o=e[f++],c=32,d=0),c>=t?(h=o>>>d&s,c-=t,d+=t):(h=o>>>d&s,c=32-(u=t-c),h|=((o=e[f++])&(1<<u)-1)<<t-u,d=u),p[l]=h<m?n+h*i:a;return p.unshift(n),p},u=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=4*e.length-Math.ceil(r*n/8);for(e[e.length-1]<<=8*c,i=0;i<n;i++)0===u&&(o=e[l++],u=32),u>=r?(a=o>>>u-r&f,u-=r):(a=(o&f)<<(s=r-u)&f,a+=(o=e[l++])>>>(u=32-s)),t[i]=a;return t},c=function(e,t,r,n){var i,a,o,s,f=(1<<r)-1,l=0,u=0,c=0;for(i=0;i<n;i++)0===u&&(o=e[l++],u=32,c=0),u>=r?(a=o>>>c&f,u-=r,c+=r):(a=o>>>c&f,u=32-(s=r-u),a|=((o=e[l++])&(1<<s)-1)<<r-s,c=s),t[i]=a;return t},h={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,r=65535,n=e.length,i=Math.floor(n/2),a=0;i;){var o=i>=359?359:i;i-=o;do{t+=e[a++]<<8,r+=t+=e[a++]}while(--o);t=(65535&t)+(t>>>16),r=(65535&r)+(r>>>16)}return 1&n&&(r+=t+=e[a]<<8),((r=(65535&r)+(r>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var r=t.ptr,n=new Uint8Array(e,r,6),i={};if(i.fileIdentifierString=String.fromCharCode.apply(null,n),0!==i.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+i.fileIdentifierString;r+=6;var a,o=new DataView(e,r,8),s=o.getInt32(0,!0);if(i.fileVersion=s,r+=4,s>=3&&(i.checksum=o.getUint32(4,!0),r+=4),o=new DataView(e,r,12),i.height=o.getUint32(0,!0),i.width=o.getUint32(4,!0),r+=8,s>=4?(i.numDims=o.getUint32(8,!0),r+=4):i.numDims=1,o=new DataView(e,r,40),i.numValidPixel=o.getUint32(0,!0),i.microBlockSize=o.getInt32(4,!0),i.blobSize=o.getInt32(8,!0),i.imageType=o.getInt32(12,!0),i.maxZError=o.getFloat64(16,!0),i.zMin=o.getFloat64(24,!0),i.zMax=o.getFloat64(32,!0),r+=40,t.headerInfo=i,t.ptr=r,s>=3&&(a=s>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(e,r-a,i.blobSize-14))!==i.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(e,t){var r=t.headerInfo,n=this.getDataTypeArray(r.imageType),i=r.numDims*this.getDataTypeSize(r.imageType),a=this.readSubArray(e,t.ptr,n,i),o=this.readSubArray(e,t.ptr+i,n,i);t.ptr+=2*i;var s,f=!0;for(s=0;s<r.numDims;s++)if(a[s]!==o[s]){f=!1;break}return r.minValues=a,r.maxValues=o,f},readSubArray:function(e,t,r,n){var i;if(r===Uint8Array)i=new Uint8Array(e,t,n);else{var a=new ArrayBuffer(n);new Uint8Array(a).set(new Uint8Array(e,t,n)),i=new r(a)}return i},readMask:function(e,t){var r,n,i=t.ptr,a=t.headerInfo,o=a.width*a.height,s=a.numValidPixel,f=new DataView(e,i,4),l={};if(l.numBytes=f.getUint32(0,!0),i+=4,(0===s||o===s)&&0!==l.numBytes)throw"invalid mask";if(0===s)r=new Uint8Array(Math.ceil(o/8)),l.bitset=r,n=new Uint8Array(o),t.pixels.resultMask=n,i+=l.numBytes;else if(l.numBytes>0){r=new Uint8Array(Math.ceil(o/8));var u=(f=new DataView(e,i,l.numBytes)).getInt16(0,!0),c=2,h=0,d=0;do{if(u>0)for(;u--;)r[h++]=f.getUint8(c++);else for(d=f.getUint8(c++),u=-u;u--;)r[h++]=d;u=f.getInt16(c,!0),c+=2}while(c<l.numBytes);if(-32768!==u||h<r.length)throw"Unexpected end of mask RLE encoding";n=new Uint8Array(o);var p=0,m=0;for(m=0;m<o;m++)7&m?(p=r[m>>3],p<<=7&m):p=r[m>>3],128&p&&(n[m]=1);t.pixels.resultMask=n,l.bitset=r,i+=l.numBytes}return t.ptr=i,t.mask=l,!0},readDataOneSweep:function(e,t,r,n){var i,a=t.ptr,o=t.headerInfo,s=o.numDims,f=o.width*o.height,l=o.imageType,u=o.numValidPixel*h.getDataTypeSize(l)*s,c=t.pixels.resultMask;if(r===Uint8Array)i=new Uint8Array(e,a,u);else{var d=new ArrayBuffer(u);new Uint8Array(d).set(new Uint8Array(e,a,u)),i=new r(d)}if(i.length===f*s)t.pixels.resultPixels=n?h.swapDimensionOrder(i,f,s,r,!0):i;else{t.pixels.resultPixels=new r(f*s);var p=0,m=0,v=0,y=0;if(s>1){if(n){for(m=0;m<f;m++)if(c[m])for(y=m,v=0;v<s;v++,y+=f)t.pixels.resultPixels[y]=i[p++]}else for(m=0;m<f;m++)if(c[m])for(y=m*s,v=0;v<s;v++)t.pixels.resultPixels[y+v]=i[p++]}else for(m=0;m<f;m++)c[m]&&(t.pixels.resultPixels[m]=i[p++])}return a+=u,t.ptr=a,!0},readHuffmanTree:function(e,t){var r=this.HUFFMAN_LUT_BITS_MAX,n=new DataView(e,t.ptr,16);if(t.ptr+=16,n.getInt32(0,!0)<2)throw"unsupported Huffman version";var i=n.getInt32(4,!0),a=n.getInt32(8,!0),o=n.getInt32(12,!0);if(a>=o)return!1;var s=new Uint32Array(o-a);h.decodeBits(e,t,s);var f,l,u,c,p=[];for(f=a;f<o;f++)p[l=f-(f<i?0:i)]={first:s[f-a],second:null};var m=e.byteLength-t.ptr,v=Math.ceil(m/4),y=new ArrayBuffer(4*v);new Uint8Array(y).set(new Uint8Array(e,t.ptr,m));var w,g=new Uint32Array(y),b=0,k=0;for(w=g[0],f=a;f<o;f++)(c=p[l=f-(f<i?0:i)].first)>0&&(p[l].second=w<<b>>>32-c,32-b>=c?32===(b+=c)&&(b=0,w=g[++k]):(b+=c-32,w=g[++k],p[l].second|=w>>>32-b));var x=0,_=0,A=new d;for(f=0;f<p.length;f++)void 0!==p[f]&&(x=Math.max(x,p[f].first));_=x>=r?r:x;var P,I,U,S,T,D=[];for(f=a;f<o;f++)if((c=p[l=f-(f<i?0:i)].first)>0)if(P=[c,l],c<=_)for(I=p[l].second<<_-c,U=1<<_-c,u=0;u<U;u++)D[I|u]=P;else for(I=p[l].second,T=A,S=c-1;S>=0;S--)I>>>S&1?(T.right||(T.right=new d),T=T.right):(T.left||(T.left=new d),T=T.left),0!==S||T.val||(T.val=P[1]);return{decodeLut:D,numBitsLUTQick:_,numBitsLUT:x,tree:A,stuffedData:g,srcPtr:k,bitPos:b}},readHuffman:function(e,t,r,n){var i,a,o,s,f,l,u,c,d,p=t.headerInfo.numDims,m=t.headerInfo.height,v=t.headerInfo.width,y=v*m,w=this.readHuffmanTree(e,t),g=w.decodeLut,b=w.tree,k=w.stuffedData,x=w.srcPtr,_=w.bitPos,A=w.numBitsLUTQick,P=w.numBitsLUT,I=0===t.headerInfo.imageType?128:0,U=t.pixels.resultMask,S=0;_>0&&(x++,_=0);var T,D=k[x],E=1===t.encodeMode,B=new r(y*p),O=B;if(p<2||E){for(T=0;T<p;T++)if(p>1&&(O=new r(B.buffer,y*T,y),S=0),t.headerInfo.numValidPixel===v*m)for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(o+=u>0?S:l>0?O[c-v]:S,o&=255,O[c]=o,S=o):O[c]=o}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++,c++)if(U[c]){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,E?(u>0&&U[c-1]?o+=S:l>0&&U[c-v]?o+=O[c-v]:o+=S,o&=255,O[c]=o,S=o):O[c]=o}}else for(c=0,l=0;l<m;l++)for(u=0;u<v;u++)if(c=l*v+u,!U||U[c])for(T=0;T<p;T++,c+=y){if(a=0,f=s=D<<_>>>32-A,32-_<A&&(f=s|=k[x+1]>>>64-_-A),g[f])a=g[f][1],_+=g[f][0];else for(f=s=D<<_>>>32-P,32-_<P&&(f=s|=k[x+1]>>>64-_-P),i=b,d=0;d<P;d++)if(!(i=s>>>P-d-1&1?i.right:i.left).left&&!i.right){a=i.val,_=_+d+1;break}_>=32&&(_-=32,D=k[++x]),o=a-I,O[c]=o}t.ptr=t.ptr+4*(x+1)+(_>0?4:0),t.pixels.resultPixels=B,p>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(B,y,p,r))},decodeBits:function(e,t,r,n,i){var a=t.headerInfo,h=a.fileVersion,d=0,p=e.byteLength-t.ptr>=5?5:e.byteLength-t.ptr,m=new DataView(e,t.ptr,p),v=m.getUint8(0);d++;var y=v>>6,w=0===y?4:3-y,g=(32&v)>0,b=31&v,k=0;if(1===w)k=m.getUint8(d),d++;else if(2===w)k=m.getUint16(d,!0),d+=2;else{if(4!==w)throw"Invalid valid pixel count type";k=m.getUint32(d,!0),d+=4}var x,_,A,P,I,U,S,T,D,E=2*a.maxZError,B=a.numDims>1?a.maxValues[i]:a.zMax;if(g){for(t.counter.lut++,T=m.getUint8(d),d++,P=Math.ceil((T-1)*b/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),A=new Uint8Array(_),t.ptr+=d,A.set(new Uint8Array(e,t.ptr,P)),S=new Uint32Array(_),t.ptr+=P,D=0;T-1>>>D;)D++;P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,U=h>=3?l(S,b,T-1,n,E,B):s(S,b,T-1,n,E,B),h>=3?f(x,r,D,k,U):o(x,r,D,k,U)}else t.counter.bitstuffer++,D=b,t.ptr+=d,D>0&&(P=Math.ceil(k*D/8),I=Math.ceil(P/4),_=new ArrayBuffer(4*I),(A=new Uint8Array(_)).set(new Uint8Array(e,t.ptr,P)),x=new Uint32Array(_),t.ptr+=P,h>=3?null==n?c(x,r,D,k):f(x,r,D,k,!1,n,E,B):null==n?u(x,r,D,k):o(x,r,D,k,!1,n,E,B))},readTiles:function(e,t,r,n){var i=t.headerInfo,a=i.width,o=i.height,s=a*o,f=i.microBlockSize,l=i.imageType,u=h.getDataTypeSize(l),c=Math.ceil(a/f),d=Math.ceil(o/f);t.pixels.numBlocksY=d,t.pixels.numBlocksX=c,t.pixels.ptr=0;var p,m,v,y,w,g,b,k,x,_,A=0,P=0,I=0,U=0,S=0,T=0,D=0,E=0,B=0,O=0,M=0,C=0,L=0,R=0,V=0,G=new r(f*f),F=o%f||f,z=a%f||f,j=i.numDims,N=t.pixels.resultMask,Z=t.pixels.resultPixels,K=i.fileVersion>=5?14:15,H=i.zMax;for(I=0;I<d;I++)for(S=I!==d-1?f:F,U=0;U<c;U++)for(O=I*a*f+U*f,M=a-(T=U!==c-1?f:z),k=0;k<j;k++){if(j>1?(_=Z,O=I*a*f+U*f,Z=new r(t.pixels.resultPixels.buffer,s*k*u,s),H=i.maxValues[k]):_=null,D=e.byteLength-t.ptr,m={},V=0,E=(p=new DataView(e,t.ptr,Math.min(10,D))).getUint8(0),V++,x=i.fileVersion>=5?4&E:0,B=E>>6&255,(E>>2&K)!=(U*f>>3&K))throw"integrity issue";if(x&&0===k)throw"integrity issue";if((w=3&E)>3)throw t.ptr+=V,"Invalid block encoding ("+w+")";if(2!==w)if(0===w){if(x)throw"integrity issue";if(t.counter.uncompressed++,t.ptr+=V,C=(C=S*T*u)<(L=e.byteLength-t.ptr)?C:L,v=new ArrayBuffer(C%u==0?C:C+u-C%u),new Uint8Array(v).set(new Uint8Array(e,t.ptr,C)),y=new r(v),R=0,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=y[R++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=y[R++];O+=M}t.ptr+=R*u}else if(g=h.getDataTypeUsed(x&&l<6?4:l,B),b=h.getOnePixel(m,V,g,p),V+=h.getDataTypeSize(g),3===w)if(t.ptr+=V,t.counter.constantoffset++,N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=x?Math.min(H,_[O]+b):b),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=x?Math.min(H,_[O]+b):b,O++;O+=M}else if(t.ptr+=V,h.decodeBits(e,t,G,b,k),V=0,x)if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]+_[O]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O]=G[V++]+_[O],O++;O+=M}else if(N)for(A=0;A<S;A++){for(P=0;P<T;P++)N[O]&&(Z[O]=G[V++]),O++;O+=M}else for(A=0;A<S;A++){for(P=0;P<T;P++)Z[O++]=G[V++];O+=M}else{if(x)if(N)for(A=0;A<S;A++)for(P=0;P<T;P++)N[O]&&(Z[O]=_[O]),O++;else for(A=0;A<S;A++)for(P=0;P<T;P++)Z[O]=_[O],O++;t.counter.constant++,t.ptr+=V}}j>1&&!n&&(t.pixels.resultPixels=h.swapDimensionOrder(t.pixels.resultPixels,s,j,r))},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:h.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e,t){var r=e.headerInfo.zMax,n=e.headerInfo.zMin,i=e.headerInfo.maxValues,a=e.headerInfo.numDims,o=e.headerInfo.height*e.headerInfo.width,s=0,f=0,l=0,u=e.pixels.resultMask,c=e.pixels.resultPixels;if(u)if(a>1){if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)u[f]&&(c[l+f]=r);else for(f=0;f<o;f++)if(u[f])for(l=f*a,s=0;s<a;s++)c[l+a]=i[s]}else for(f=0;f<o;f++)u[f]&&(c[f]=r);else if(a>1&&n!==r)if(t)for(s=0;s<a;s++)for(l=s*o,r=i[s],f=0;f<o;f++)c[l+f]=r;else for(f=0;f<o;f++)for(l=f*a,s=0;s<a;s++)c[l+s]=i[s];else for(f=0;f<o*a;f++)c[f]=r},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:default:t=Float32Array;break;case 7:t=Float64Array}return t},getPixelType:function(e){var t;switch(e){case 0:t="S8";break;case 1:t="U8";break;case 2:t="S16";break;case 3:t="U16";break;case 4:t="S32";break;case 5:t="U32";break;case 6:default:t="F32";break;case 7:t="F64"}return t},isValidPixelValue:function(e,t){if(null==t)return!1;var r;switch(e){case 0:r=t>=-128&&t<=127;break;case 1:r=t>=0&&t<=255;break;case 2:r=t>=-32768&&t<=32767;break;case 3:r=t>=0&&t<=65536;break;case 4:r=t>=-2147483648&&t<=2147483647;break;case 5:r=t>=0&&t<=4294967296;break;case 6:r=t>=-34027999387901484e22&&t<=34027999387901484e22;break;case 7:r=t>=-17976931348623157e292&&t<=17976931348623157e292;break;default:r=!1}return r},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var r=e;switch(e){case 2:case 4:r=e-t;break;case 3:case 5:r=e-2*t;break;case 6:r=0===t?e:1===t?2:1;break;case 7:r=0===t?e:e-2*t+1;break;default:r=e}return r},getOnePixel:function(e,t,r,n){var i=0;switch(r){case 0:i=n.getInt8(t);break;case 1:i=n.getUint8(t);break;case 2:i=n.getInt16(t,!0);break;case 3:i=n.getUint16(t,!0);break;case 4:i=n.getInt32(t,!0);break;case 5:i=n.getUInt32(t,!0);break;case 6:i=n.getFloat32(t,!0);break;case 7:i=n.getFloat64(t,!0);break;default:throw"the decoder does not understand this pixel type"}return i},swapDimensionOrder:function(e,t,r,n,i){var a=0,o=0,s=0,f=0,l=e;if(r>1)if(l=new n(t*r),i)for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[f]=e[o++];else for(a=0;a<t;a++)for(f=a,s=0;s<r;s++,f+=t)l[o++]=e[f];return l}},d=function(e,t,r){this.val=e,this.left=t,this.right=r},{decode:function(e,t){var r=(t=t||{}).noDataValue,n=0,i={};i.ptr=t.inputOffset||0,i.pixels={},h.readHeaderInfo(e,i);var a=i.headerInfo,o=a.fileVersion,s=h.getDataTypeArray(a.imageType);if(o>5)throw"unsupported lerc version 2."+o;h.readMask(e,i),a.numValidPixel===a.width*a.height||i.pixels.resultMask||(i.pixels.resultMask=t.maskData);var f=a.width*a.height;i.pixels.resultPixels=new s(f*a.numDims),i.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var l,u=!t.returnPixelInterleavedDims;if(0!==a.numValidPixel)if(a.zMax===a.zMin)h.constructConstantSurface(i,u);else if(o>=4&&h.checkMinMaxRanges(e,i))h.constructConstantSurface(i,u);else{var c=new DataView(e,i.ptr,2),d=c.getUint8(0);if(i.ptr++,d)h.readDataOneSweep(e,i,s,u);else if(o>1&&a.imageType<=1&&Math.abs(a.maxZError-.5)<1e-5){var p=c.getUint8(1);if(i.ptr++,i.encodeMode=p,p>2||o<4&&p>1)throw"Invalid Huffman flag "+p;p?h.readHuffman(e,i,s,u):h.readTiles(e,i,s,u)}else h.readTiles(e,i,s,u)}i.eofOffset=i.ptr,t.inputOffset?(l=i.headerInfo.blobSize+t.inputOffset-i.ptr,Math.abs(l)>=1&&(i.eofOffset=t.inputOffset+i.headerInfo.blobSize)):(l=i.headerInfo.blobSize-i.ptr,Math.abs(l)>=1&&(i.eofOffset=i.headerInfo.blobSize));var m={width:a.width,height:a.height,pixelData:i.pixels.resultPixels,minValue:a.zMin,maxValue:a.zMax,validPixelCount:a.numValidPixel,dimCount:a.numDims,dimStats:{minValues:a.minValues,maxValues:a.maxValues},maskData:i.pixels.resultMask};if(i.pixels.resultMask&&h.isValidPixelValue(a.imageType,r)){var v=i.pixels.resultMask;for(n=0;n<f;n++)v[n]||(m.pixelData[n]=r);m.noDataValue=r}return i.noDataValue=r,t.returnFileInfo&&(m.fileInfo=h.formatFileInfo(i)),m},getBandCount:function(e){for(var t=0,r=0,n={ptr:0,pixels:{}};r<e.byteLength-58;)h.readHeaderInfo(e,n),r+=n.headerInfo.blobSize,t++,n.ptr=r;return t}}),w=(p=new ArrayBuffer(4),m=new Uint8Array(p),new Uint32Array(p)[0]=1,1===m[0]),g={decode:function(e,t){if(!w)throw"Big endian system is not supported.";var r,n,i=(t=t||{}).inputOffset||0,a=new Uint8Array(e,i,10),o=String.fromCharCode.apply(null,a);if("CntZImage"===o.trim())r=v,n=1;else{if("Lerc2"!==o.substring(0,5))throw"Unexpected file identifier string: "+o;r=y,n=2}for(var s,f,l,u,c,h,d=0,p=e.byteLength-10,m=[],g={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]},b=0;i<p;){var k=r.decode(e,{inputOffset:i,encodedMaskData:s,maskData:l,returnMask:0===d,returnEncodedMask:0===d,returnFileInfo:!0,returnPixelInterleavedDims:t.returnPixelInterleavedDims,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null});i=k.fileInfo.eofOffset,l=k.maskData,0===d&&(s=k.encodedMaskData,g.width=k.width,g.height=k.height,g.dimCount=k.dimCount||1,g.pixelType=k.pixelType||k.fileInfo.pixelType,g.mask=l),n>1&&(l&&m.push(l),k.fileInfo.mask&&k.fileInfo.mask.numBytes>0&&b++),d++,g.pixels.push(k.pixelData),g.statistics.push({minValue:k.minValue,maxValue:k.maxValue,noDataValue:k.noDataValue,dimStats:k.dimStats})}if(n>1&&b>1){for(h=g.width*g.height,g.bandMasks=m,(l=new Uint8Array(h)).set(m[0]),u=1;u<m.length;u++)for(f=m[u],c=0;c<h;c++)l[c]=l[c]&f[c];g.maskData=l}return g}};Ke.exports?Ke.exports=g:this.Lerc=g}();var We=Xe.exports,qe={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},Je={};for(var Qe in qe)qe.hasOwnProperty(Qe)&&(Je[qe[Qe]]=parseInt(Qe,10));Je.BitsPerSample,Je.ExtraSamples,Je.SampleFormat,Je.StripByteCounts,Je.StripOffsets,Je.StripRowCounts,Je.TileByteCounts,Je.TileOffsets,Je.SubIFDs;var $e={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},et={};for(var tt in $e)$e.hasOwnProperty(tt)&&(et[$e[tt]]=parseInt(tt,10));var rt=1,nt=0,it=1,at={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},ot={};for(var st in at)at.hasOwnProperty(st)&&(ot[at[st]]=parseInt(st,10));function ft(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var lt=function(e){p(r,b);var t=ft(r);function r(e){var n;return u(this,r),(n=t.call(this)).planarConfiguration=void 0!==e.PlanarConfiguration?e.PlanarConfiguration:1,n.samplesPerPixel=void 0!==e.SamplesPerPixel?e.SamplesPerPixel:1,n.addCompression=e.LercParameters[rt],n}return h(r,[{key:"decodeBlock",value:function(e){switch(this.addCompression){case nt:break;case it:e=Fe(new Uint8Array(e)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return We.decode(e,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),r}(),ut=Object.freeze({__proto__:null,default:lt});function ct(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=v(e);if(t){var i=v(this).constructor;r=Reflect.construct(n,arguments,i)}else r=n.apply(this,arguments);return m(this,r)}}var ht=function(e){p(a,b);var r,n=ct(a);function a(){var e;if(u(this,a),e=n.call(this),"undefined"==typeof createImageBitmap)throw new Error("Cannot decode WebImage as `createImageBitmap` is not available");if("undefined"==typeof document&&"undefined"==typeof OffscreenCanvas)throw new Error("Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available");return e}return h(a,[{key:"decode",value:(r=t(i.mark((function e(t,r){var n,a,o,s;return i.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=new Blob([r]),e.next=3,createImageBitmap(n);case 3:return a=e.sent,"undefined"!=typeof document?((o=document.createElement("canvas")).width=a.width,o.height=a.height):o=new OffscreenCanvas(a.width,a.height),(s=o.getContext("2d")).drawImage(a,0,0),e.abrupt("return",s.getImageData(0,0,a.width,a.height).data.buffer);case 8:case"end":return e.stop()}}),e)}))),function(e,t){return r.apply(this,arguments)})}]),a}(),dt=Object.freeze({__proto__:null,default:ht});';
          return new qi("undefined" == typeof Blob ? "data:application/javascript;base64," + Buffer.from(e, "binary").toString("base64") : URL.createObjectURL(new Blob([e], {
            type: "application/javascript"
          })));
        }
      });
      e.GeoTIFF = Zr, e.GeoTIFFImage = Ce, e.MultiGeoTIFF = Hr, e.Pool = je, e.addDecoder = be, e["default"] = Zr, e.fromArrayBuffer = function (e, t) {
        return qr.apply(this, arguments);
      }, e.fromBlob = function (e, t) {
        return Wr.apply(this, arguments);
      }, e.fromFile = function (e, t) {
        return Xr.apply(this, arguments);
      }, e.fromUrl = function (e) {
        return Yr.apply(this, arguments);
      }, e.fromUrls = function (e) {
        return Jr.apply(this, arguments);
      }, e.getDecoder = ke, e.globals = ce, e.rgb = ye, e.setLogger = function () {
        arguments.length > 0 && void 0 !== arguments[0] || new Br();
      }, e.writeArrayBuffer = function (e, t) {
        return Mr(e, t);
      }, Object.defineProperty(e, "__esModule", {
        value: !0
      });
    });
  })(geotiff, geotiff.exports);

  /**
   * Determine if an image type is a mask.
   * See https://www.awaresystems.be/imaging/tiff/tifftags/newsubfiletype.html
   * @param {GeoTIFFImage} image The image.
   * @return {boolean} The image is a mask.
   */

  function isMask(image) {
    var fileDirectory = image.fileDirectory;
    var type = fileDirectory.NewSubfileType || 0;
    return (type & 4) === 4;
  }
  /**
   * @param {true|false|'auto'} preference The convertToRGB option.
   * @param {GeoTIFFImage} image The image.
   * @return {boolean} Use the `image.readRGB()` method.
   */


  function readRGB(preference, image) {
    if (!preference) {
      return false;
    }

    if (preference === true) {
      return true;
    }

    if (image.getSamplesPerPixel() !== 3) {
      return false;
    }

    var interpretation = image.fileDirectory.PhotometricInterpretation;
    var interpretations = geotiff.exports.globals.photometricInterpretations;
    return interpretation === interpretations.CMYK || interpretation === interpretations.YCbCr || interpretation === interpretations.CIELab || interpretation === interpretations.ICCLab;
  }
  /**
   * @typedef {Object} SourceInfo
   * @property {string} [url] URL for the source GeoTIFF.
   * @property {Array<string>} [overviews] List of any overview URLs, only applies if the url parameter is given.
   * @property {Blob} [blob] Blob containing the source GeoTIFF. `blob` and `url` are mutually exclusive.
   * @property {number} [min=0] The minimum source data value.  Rendered values are scaled from 0 to 1 based on
   * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
   * If neither are available, the minimum for the data type will be used.  To disable this behavior, set
   * the `normalize` option to `false` in the constructor.
   * @property {number} [max] The maximum source data value.  Rendered values are scaled from 0 to 1 based on
   * the configured min and max.  If not provided and raster statistics are available, those will be used instead.
   * If neither are available, the maximum for the data type will be used.  To disable this behavior, set
   * the `normalize` option to `false` in the constructor.
   * @property {number} [nodata] Values to discard (overriding any nodata values in the metadata).
   * When provided, an additional alpha band will be added to the data.  Often the GeoTIFF metadata
   * will include information about nodata values, so you should only need to set this property if
   * you find that it is not already extracted from the metadata.
   * @property {Array<number>} [bands] Band numbers to be read from (where the first band is `1`). If not provided, all bands will
   * be read. For example, if a GeoTIFF has blue (1), green (2), red (3), and near-infrared (4) bands, and you only need the
   * near-infrared band, configure `bands: [4]`.
   */

  /**
   * @typedef {Object} GeoKeys
   * @property {number} GTModelTypeGeoKey Model type.
   * @property {number} GTRasterTypeGeoKey Raster type.
   * @property {number} GeogAngularUnitsGeoKey Angular units.
   * @property {number} GeogInvFlatteningGeoKey Inverse flattening.
   * @property {number} GeogSemiMajorAxisGeoKey Semi-major axis.
   * @property {number} GeographicTypeGeoKey Geographic coordinate system code.
   * @property {number} ProjLinearUnitsGeoKey Projected linear unit code.
   * @property {number} ProjectedCSTypeGeoKey Projected coordinate system code.
   */

  /**
   * @typedef {import("geotiff").GeoTIFF} GeoTIFF
   */

  /**
   * @typedef {import("geotiff").MultiGeoTIFF} MultiGeoTIFF
   */

  /**
   * @typedef {Object} GDALMetadata
   * @property {string} STATISTICS_MINIMUM The minimum value (as a string).
   * @property {string} STATISTICS_MAXIMUM The maximum value (as a string).
   */


  var STATISTICS_MAXIMUM = 'STATISTICS_MAXIMUM';
  var STATISTICS_MINIMUM = 'STATISTICS_MINIMUM';
  /**
   * @typedef {import("geotiff").GeoTIFFImage} GeoTIFFImage
   */

  var workerPool;

  function getWorkerPool() {
    if (!workerPool) {
      workerPool = new geotiff.exports.Pool();
    }

    return workerPool;
  }
  /**
   * Get the bounding box of an image.  If the image does not have an affine transform,
   * the pixel bounds are returned.
   * @param {GeoTIFFImage} image The image.
   * @return {Array<number>} The image bounding box.
   */


  function getBoundingBox(image) {
    try {
      return image.getBoundingBox();
    } catch (_) {
      var fileDirectory = image.fileDirectory;
      return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];
    }
  }
  /**
   * Get the origin of an image.  If the image does not have an affine transform,
   * the top-left corner of the pixel bounds is returned.
   * @param {GeoTIFFImage} image The image.
   * @return {Array<number>} The image origin.
   */


  function getOrigin(image) {
    try {
      return image.getOrigin().slice(0, 2);
    } catch (_) {
      return [0, image.fileDirectory.ImageLength];
    }
  }
  /**
   * Get the resolution of an image.  If the image does not have an affine transform,
   * the width of the image is compared with the reference image.
   * @param {GeoTIFFImage} image The image.
   * @param {GeoTIFFImage} referenceImage The reference image.
   * @return {Array<number>} The map x and y units per pixel.
   */


  function getResolutions(image, referenceImage) {
    try {
      return image.getResolution(referenceImage);
    } catch (_) {
      return [referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth, referenceImage.fileDirectory.ImageHeight / image.fileDirectory.ImageHeight];
    }
  }
  /**
   * @param {GeoTIFFImage} image A GeoTIFF.
   * @return {import("../proj/Projection.js").default} The image projection.
   */


  function getProjection(image) {
    var geoKeys = image.geoKeys;

    if (!geoKeys) {
      return null;
    }

    if (geoKeys.ProjectedCSTypeGeoKey) {
      var code = 'EPSG:' + geoKeys.ProjectedCSTypeGeoKey;
      var projection = get$1(code);

      if (!projection) {
        var units = fromCode(geoKeys.ProjLinearUnitsGeoKey);

        if (units) {
          projection = new Projection({
            code: code,
            units: units
          });
        }
      }

      return projection;
    }

    if (geoKeys.GeographicTypeGeoKey) {
      var _code = 'EPSG:' + geoKeys.GeographicTypeGeoKey;

      var _projection = get$1(_code);

      if (!_projection) {
        var _units = fromCode(geoKeys.GeogAngularUnitsGeoKey);

        if (_units) {
          _projection = new Projection({
            code: _code,
            units: _units
          });
        }
      }

      return _projection;
    }

    return null;
  }
  /**
   * @param {GeoTIFF|MultiGeoTIFF} tiff A GeoTIFF.
   * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
   */


  function getImagesForTIFF(tiff) {
    return tiff.getImageCount().then(function (count) {
      var requests = new Array(count);

      for (var i = 0; i < count; ++i) {
        requests[i] = tiff.getImage(i);
      }

      return Promise.all(requests);
    });
  }
  /**
   * @param {SourceInfo} source The GeoTIFF source.
   * @param {Object} options Options for the GeoTIFF source.
   * @return {Promise<Array<GeoTIFFImage>>} Resolves to a list of images.
   */


  function getImagesForSource(source, options) {
    var request;

    if (source.blob) {
      request = geotiff.exports.fromBlob(source.blob);
    } else if (source.overviews) {
      request = geotiff.exports.fromUrls(source.url, source.overviews, options);
    } else {
      request = geotiff.exports.fromUrl(source.url, options);
    }

    return request.then(getImagesForTIFF);
  }
  /**
   * @param {number|Array<number>|Array<Array<number>>} expected Expected value.
   * @param {number|Array<number>|Array<Array<number>>} got Actual value.
   * @param {number} tolerance Accepted tolerance in fraction of expected between expected and got.
   * @param {string} message The error message.
   * @param {function(Error):void} rejector A function to be called with any error.
   */


  function assertEqual(expected, got, tolerance, message, rejector) {
    if (Array.isArray(expected)) {
      var length = expected.length;

      if (!Array.isArray(got) || length != got.length) {
        var error = new Error(message);
        rejector(error);
        throw error;
      }

      for (var i = 0; i < length; ++i) {
        assertEqual(expected[i], got[i], tolerance, message, rejector);
      }

      return;
    }

    got =
    /** @type {number} */
    got;

    if (Math.abs(expected - got) > tolerance * expected) {
      throw new Error(message);
    }
  }
  /**
   * @param {Array} array The data array.
   * @return {number} The minimum value.
   */


  function getMinForDataType(array) {
    if (array instanceof Int8Array) {
      return -128;
    }

    if (array instanceof Int16Array) {
      return -32768;
    }

    if (array instanceof Int32Array) {
      return -2147483648;
    }

    if (array instanceof Float32Array) {
      return 1.2e-38;
    }

    return 0;
  }
  /**
   * @param {Array} array The data array.
   * @return {number} The maximum value.
   */


  function getMaxForDataType(array) {
    if (array instanceof Int8Array) {
      return 127;
    }

    if (array instanceof Uint8Array) {
      return 255;
    }

    if (array instanceof Uint8ClampedArray) {
      return 255;
    }

    if (array instanceof Int16Array) {
      return 32767;
    }

    if (array instanceof Uint16Array) {
      return 65535;
    }

    if (array instanceof Int32Array) {
      return 2147483647;
    }

    if (array instanceof Uint32Array) {
      return 4294967295;
    }

    if (array instanceof Float32Array) {
      return 3.4e38;
    }

    return 255;
  }
  /**
   * @typedef {Object} GeoTIFFSourceOptions
   * @property {boolean} [forceXHR=false] Whether to force the usage of the browsers XMLHttpRequest API.
   * @property {Object<string, string>} [headers] additional key-value pairs of headers to be passed with each request. Key is the header name, value the header value.
   * @property {string} [credentials] How credentials shall be handled. See
   * https://developer.mozilla.org/en-US/docs/Web/API/fetch for reference and possible values
   * @property {number} [maxRanges] The maximum amount of ranges to request in a single multi-range request.
   * By default only a single range is used.
   * @property {boolean} [allowFullFile=false] Whether or not a full file is accepted when only a portion is
   * requested. Only use this when you know the source image to be small enough to fit in memory.
   * @property {number} [blockSize=65536] The block size to use.
   * @property {number} [cacheSize=100] The number of blocks that shall be held in a LRU cache.
   */

  /**
   * @typedef {Object} Options
   * @property {Array<SourceInfo>} sources List of information about GeoTIFF sources.
   * Multiple sources can be combined when their resolution sets are equal after applying a scale.
   * The list of sources defines a mapping between input bands as they are read from each GeoTIFF and
   * the output bands that are provided by data tiles. To control which bands to read from each GeoTIFF,
   * use the {@link import("./GeoTIFF.js").SourceInfo bands} property. If, for example, you specify two
   * sources, one with 3 bands and {@link import("./GeoTIFF.js").SourceInfo nodata} configured, and
   * another with 1 band, the resulting data tiles will have 5 bands: 3 from the first source, 1 alpha
   * band from the first source, and 1 band from the second source.
   * @property {GeoTIFFSourceOptions} [sourceOptions] Additional options to be passed to [geotiff.js](https://geotiffjs.github.io/geotiff.js/module-geotiff.html)'s `fromUrl` or `fromUrls` methods.
   * @property {true|false|'auto'} [convertToRGB=false] By default, bands from the sources are read as-is. When
   * reading GeoTIFFs with the purpose of displaying them as RGB images, setting this to `true` will
   * convert other color spaces (YCbCr, CMYK) to RGB.  Setting the option to `'auto'` will make it so CMYK, YCbCr,
   * CIELab, and ICCLab images will automatically be converted to RGB.
   * @property {boolean} [normalize=true] By default, the source data is normalized to values between
   * 0 and 1 with scaling factors based on the raster statistics or `min` and `max` properties of each source.
   * If instead you want to work with the raw values in a style expression, set this to `false`.  Setting this option
   * to `false` will make it so any `min` and `max` properties on sources are ignored.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {number} [transition=250] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {boolean} [wrapX=false] Render tiles beyond the tile grid extent.
   * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
   * the linear interpolation is used to resample the data.  If false, nearest neighbor is used.
   */

  /**
   * @classdesc
   * A source for working with GeoTIFF data.
   * **Note for users of the full build**: The `GeoTIFF` source requires the
   * [geotiff.js](https://github.com/geotiffjs/geotiff.js) library to be loaded as well.
   *
   * @api
   */


  var GeoTIFFSource = /*#__PURE__*/function (_DataTile) {
    _inherits(GeoTIFFSource, _DataTile);

    var _super = _createSuper(GeoTIFFSource);

    /**
     * @param {Options} options Data tile options.
     */
    function GeoTIFFSource(options) {
      var _this;

      _classCallCheck(this, GeoTIFFSource);

      _this = _super.call(this, {
        state: 'loading',
        tileGrid: null,
        projection: null,
        opaque: options.opaque,
        transition: options.transition,
        interpolate: options.interpolate !== false,
        wrapX: options.wrapX
      });
      /**
       * @type {Array<SourceInfo>}
       * @private
       */

      _this.sourceInfo_ = options.sources;
      var numSources = _this.sourceInfo_.length;
      /**
       * @type {Object}
       * @private
       */

      _this.sourceOptions_ = options.sourceOptions;
      /**
       * @type {Array<Array<GeoTIFFImage>>}
       * @private
       */

      _this.sourceImagery_ = new Array(numSources);
      /**
       * @type {Array<Array<GeoTIFFImage>>}
       * @private
       */

      _this.sourceMasks_ = new Array(numSources);
      /**
       * @type {Array<number>}
       * @private
       */

      _this.resolutionFactors_ = new Array(numSources);
      /**
       * @type {Array<number>}
       * @private
       */

      _this.samplesPerPixel_;
      /**
       * @type {Array<Array<number>>}
       * @private
       */

      _this.nodataValues_;
      /**
       * @type {Array<Array<GDALMetadata>>}
       * @private
       */

      _this.metadata_;
      /**
       * @type {boolean}
       * @private
       */

      _this.normalize_ = options.normalize !== false;
      /**
       * @type {boolean}
       * @private
       */

      _this.addAlpha_ = false;
      /**
       * @type {Error}
       * @private
       */

      _this.error_ = null;
      /**
       * @type {true|false|'auto'}
       */

      _this.convertToRGB_ = options.convertToRGB || false;

      _this.setKey(_this.sourceInfo_.map(function (source) {
        return source.url;
      }).join(','));

      var self = _assertThisInitialized(_this);

      var requests = new Array(numSources);

      for (var i = 0; i < numSources; ++i) {
        requests[i] = getImagesForSource(_this.sourceInfo_[i], _this.sourceOptions_);
      }

      Promise.all(requests).then(function (sources) {
        self.configure_(sources);
      })["catch"](function (error) {
        console.error(error); // eslint-disable-line no-console

        self.error_ = error;
        self.setState('error');
      });
      return _this;
    }
    /**
     * @return {Error} A source loading error. When the source state is `error`, use this function
     * to get more information about the error. To debug a faulty configuration, you may want to use
     * a listener like
     * ```js
     * geotiffSource.on('change', () => {
     *   if (geotiffSource.getState() === 'error') {
     *     console.error(geotiffSource.getError());
     *   }
     * });
     * ```
     */


    _createClass(GeoTIFFSource, [{
      key: "getError",
      value: function getError() {
        return this.error_;
      }
      /**
       * Configure the tile grid based on images within the source GeoTIFFs.  Each GeoTIFF
       * must have the same internal tiled structure.
       * @param {Array<Array<GeoTIFFImage>>} sources Each source is a list of images
       * from a single GeoTIFF.
       * @private
       */

    }, {
      key: "configure_",
      value: function configure_(sources) {
        var _this2 = this;

        var extent;
        var origin;
        var commonRenderTileSizes;
        var commonSourceTileSizes;
        var resolutions;
        var samplesPerPixel = new Array(sources.length);
        var nodataValues = new Array(sources.length);
        var metadata = new Array(sources.length);
        var minZoom = 0;
        var sourceCount = sources.length;

        var _loop = function _loop(sourceIndex) {
          var images = [];
          var masks = [];
          sources[sourceIndex].forEach(function (item) {
            if (isMask(item)) {
              masks.push(item);
            } else {
              images.push(item);
            }
          });
          var imageCount = images.length;

          if (masks.length > 0 && masks.length !== imageCount) {
            throw new Error("Expected one mask per image found ".concat(masks.length, " masks and ").concat(imageCount, " images"));
          }

          var sourceExtent = void 0;
          var sourceOrigin = void 0;
          var sourceTileSizes = new Array(imageCount);
          var renderTileSizes = new Array(imageCount);
          var sourceResolutions = new Array(imageCount);
          nodataValues[sourceIndex] = new Array(imageCount);
          metadata[sourceIndex] = new Array(imageCount);

          for (var _imageIndex = 0; _imageIndex < imageCount; ++_imageIndex) {
            var _image = images[_imageIndex];

            var nodataValue = _image.getGDALNoData();

            metadata[sourceIndex][_imageIndex] = _image.getGDALMetadata(0);
            nodataValues[sourceIndex][_imageIndex] = nodataValue;
            var wantedSamples = _this2.sourceInfo_[sourceIndex].bands;
            samplesPerPixel[sourceIndex] = wantedSamples ? wantedSamples.length : _image.getSamplesPerPixel();
            var level = imageCount - (_imageIndex + 1);

            if (!sourceExtent) {
              sourceExtent = getBoundingBox(_image);
            }

            if (!sourceOrigin) {
              sourceOrigin = getOrigin(_image);
            }

            var imageResolutions = getResolutions(_image, images[0]);
            sourceResolutions[level] = imageResolutions[0];
            var sourceTileSize = [_image.getTileWidth(), _image.getTileHeight()];
            sourceTileSizes[level] = sourceTileSize;
            var aspectRatio = imageResolutions[0] / Math.abs(imageResolutions[1]);
            renderTileSizes[level] = [sourceTileSize[0], sourceTileSize[1] / aspectRatio];
          }

          if (!extent) {
            extent = sourceExtent;
          } else {
            getIntersection(extent, sourceExtent, extent);
          }

          if (!origin) {
            origin = sourceOrigin;
          } else {
            var message = "Origin mismatch for source ".concat(sourceIndex, ", got [").concat(sourceOrigin, "] but expected [").concat(origin, "]");
            assertEqual(origin, sourceOrigin, 0, message, _this2.viewRejector);
          }

          if (!resolutions) {
            resolutions = sourceResolutions;
            _this2.resolutionFactors_[sourceIndex] = 1;
          } else {
            if (resolutions.length - minZoom > sourceResolutions.length) {
              minZoom = resolutions.length - sourceResolutions.length;
            }

            var resolutionFactor = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
            _this2.resolutionFactors_[sourceIndex] = resolutionFactor;
            var scaledSourceResolutions = sourceResolutions.map(function (resolution) {
              return resolution *= resolutionFactor;
            });

            var _message = "Resolution mismatch for source ".concat(sourceIndex, ", got [").concat(scaledSourceResolutions, "] but expected [").concat(resolutions, "]");

            assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 0.02, _message, _this2.viewRejector);
          }

          if (!commonRenderTileSizes) {
            commonRenderTileSizes = renderTileSizes;
          } else {
            assertEqual(commonRenderTileSizes.slice(minZoom, commonRenderTileSizes.length), renderTileSizes, 0.01, "Tile size mismatch for source ".concat(sourceIndex), _this2.viewRejector);
          }

          if (!commonSourceTileSizes) {
            commonSourceTileSizes = sourceTileSizes;
          } else {
            assertEqual(commonSourceTileSizes.slice(minZoom, commonSourceTileSizes.length), sourceTileSizes, 0, "Tile size mismatch for source ".concat(sourceIndex), _this2.viewRejector);
          }

          _this2.sourceImagery_[sourceIndex] = images.reverse();
          _this2.sourceMasks_[sourceIndex] = masks.reverse();
        };

        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
          _loop(sourceIndex);
        }

        for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {
          var sourceImagery = this.sourceImagery_[i];

          while (sourceImagery.length < resolutions.length) {
            sourceImagery.unshift(undefined);
          }
        }

        if (!this.getProjection()) {
          var firstSource = sources[0];

          for (var _i = firstSource.length - 1; _i >= 0; --_i) {
            var image = firstSource[_i];
            var projection = getProjection(image);

            if (projection) {
              this.projection = projection;
              break;
            }
          }
        }

        this.samplesPerPixel_ = samplesPerPixel;
        this.nodataValues_ = nodataValues;
        this.metadata_ = metadata; // decide if we need to add an alpha band to handle nodata

        outer: for (var _sourceIndex = 0; _sourceIndex < sourceCount; ++_sourceIndex) {
          // option 1: source is configured with a nodata value
          if (this.sourceInfo_[_sourceIndex].nodata !== undefined) {
            this.addAlpha_ = true;
            break;
          }

          if (this.sourceMasks_[_sourceIndex].length) {
            this.addAlpha_ = true;
            break;
          }

          var values = nodataValues[_sourceIndex]; // option 2: check image metadata for limited bands

          var bands = this.sourceInfo_[_sourceIndex].bands;

          if (bands) {
            for (var _i2 = 0; _i2 < bands.length; ++_i2) {
              if (values[bands[_i2] - 1] !== null) {
                this.addAlpha_ = true;
                break outer;
              }
            }

            continue;
          } // option 3: check image metadata for all bands


          for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {
            if (values[imageIndex] !== null) {
              this.addAlpha_ = true;
              break outer;
            }
          }
        }

        var bandCount = this.addAlpha_ ? 1 : 0;

        for (var _sourceIndex2 = 0; _sourceIndex2 < sourceCount; ++_sourceIndex2) {
          bandCount += samplesPerPixel[_sourceIndex2];
        }

        this.bandCount = bandCount;
        var tileGrid = new TileGrid({
          extent: extent,
          minZoom: minZoom,
          origin: origin,
          resolutions: resolutions,
          tileSizes: commonRenderTileSizes
        });
        this.tileGrid = tileGrid;
        this.setTileSizes(commonSourceTileSizes);
        this.setLoader(this.loadTile_.bind(this));
        this.setState('ready');
        var zoom = 0;

        if (resolutions.length === 1) {
          resolutions = [resolutions[0] * 2, resolutions[0]];
          zoom = 1;
        }

        this.viewResolver({
          showFullExtent: true,
          projection: this.projection,
          resolutions: resolutions,
          center: toUserCoordinate(getCenter(extent), this.projection),
          extent: toUserExtent(extent, this.projection),
          zoom: zoom
        });
      }
      /**
       * @param {number} z The z tile index.
       * @param {number} x The x tile index.
       * @param {number} y The y tile index.
       * @return {Promise} The composed tile data.
       * @private
       */

    }, {
      key: "loadTile_",
      value: function loadTile_(z, x, y) {
        var _this3 = this;

        var sourceTileSize = this.getTileSize(z);
        var sourceCount = this.sourceImagery_.length;
        var requests = new Array(sourceCount * 2);
        var nodataValues = this.nodataValues_;
        var sourceInfo = this.sourceInfo_;
        var pool = getWorkerPool();

        var _loop2 = function _loop2(sourceIndex) {
          var source = sourceInfo[sourceIndex];
          var resolutionFactor = _this3.resolutionFactors_[sourceIndex];
          var pixelBounds = [Math.round(x * (sourceTileSize[0] * resolutionFactor)), Math.round(y * (sourceTileSize[1] * resolutionFactor)), Math.round((x + 1) * (sourceTileSize[0] * resolutionFactor)), Math.round((y + 1) * (sourceTileSize[1] * resolutionFactor))];
          var image = _this3.sourceImagery_[sourceIndex][z];
          var samples = void 0;

          if (source.bands) {
            samples = source.bands.map(function (bandNumber) {
              return bandNumber - 1;
            });
          }
          /** @type {number|Array<number>} */


          var fillValue = void 0;

          if ('nodata' in source && source.nodata !== null) {
            fillValue = source.nodata;
          } else {
            if (!samples) {
              fillValue = nodataValues[sourceIndex];
            } else {
              fillValue = samples.map(function (sampleIndex) {
                return nodataValues[sourceIndex][sampleIndex];
              });
            }
          }

          var readOptions = {
            window: pixelBounds,
            width: sourceTileSize[0],
            height: sourceTileSize[1],
            samples: samples,
            fillValue: fillValue,
            pool: pool,
            interleave: false
          };

          if (readRGB(_this3.convertToRGB_, image)) {
            requests[sourceIndex] = image.readRGB(readOptions);
          } else {
            requests[sourceIndex] = image.readRasters(readOptions);
          } // requests after `sourceCount` are for mask data (if any)


          var maskIndex = sourceCount + sourceIndex;
          var mask = _this3.sourceMasks_[sourceIndex][z];

          if (!mask) {
            requests[maskIndex] = Promise.resolve(null);
            return "continue";
          }

          requests[maskIndex] = mask.readRasters({
            window: pixelBounds,
            width: sourceTileSize[0],
            height: sourceTileSize[1],
            samples: [0],
            pool: pool,
            interleave: false
          });
        };

        for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
          var _ret = _loop2(sourceIndex);

          if (_ret === "continue") continue;
        }

        return Promise.all(requests).then(this.composeTile_.bind(this, sourceTileSize))["catch"](function (error) {
          console.error(error); // eslint-disable-line no-console

          throw error;
        });
      }
      /**
       * @param {import("../size.js").Size} sourceTileSize The source tile size.
       * @param {Array} sourceSamples The source samples.
       * @return {import("../DataTile.js").Data} The composed tile data.
       * @private
       */

    }, {
      key: "composeTile_",
      value: function composeTile_(sourceTileSize, sourceSamples) {
        var metadata = this.metadata_;
        var sourceInfo = this.sourceInfo_;
        var sourceCount = this.sourceImagery_.length;
        var bandCount = this.bandCount;
        var samplesPerPixel = this.samplesPerPixel_;
        var nodataValues = this.nodataValues_;
        var normalize = this.normalize_;
        var addAlpha = this.addAlpha_;
        var pixelCount = sourceTileSize[0] * sourceTileSize[1];
        var dataLength = pixelCount * bandCount;
        /** @type {Uint8Array|Float32Array} */

        var data;

        if (normalize) {
          data = new Uint8Array(dataLength);
        } else {
          data = new Float32Array(dataLength);
        }

        var dataIndex = 0;

        for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {
          var transparent = addAlpha;

          for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
            var source = sourceInfo[sourceIndex];
            var min = source.min;
            var max = source.max;
            var gain = void 0,
                bias = void 0;

            if (normalize) {
              var stats = metadata[sourceIndex][0];

              if (min === undefined) {
                if (stats && STATISTICS_MINIMUM in stats) {
                  min = parseFloat(stats[STATISTICS_MINIMUM]);
                } else {
                  min = getMinForDataType(sourceSamples[sourceIndex][0]);
                }
              }

              if (max === undefined) {
                if (stats && STATISTICS_MAXIMUM in stats) {
                  max = parseFloat(stats[STATISTICS_MAXIMUM]);
                } else {
                  max = getMaxForDataType(sourceSamples[sourceIndex][0]);
                }
              }

              gain = 255 / (max - min);
              bias = -min * gain;
            }

            for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex]; ++sampleIndex) {
              var sourceValue = sourceSamples[sourceIndex][sampleIndex][pixelIndex];
              var value = void 0;

              if (normalize) {
                value = clamp(gain * sourceValue + bias, 0, 255);
              } else {
                value = sourceValue;
              }

              if (!addAlpha) {
                data[dataIndex] = value;
              } else {
                var nodata = source.nodata;

                if (nodata === undefined) {
                  var bandIndex = void 0;

                  if (source.bands) {
                    bandIndex = source.bands[sampleIndex] - 1;
                  } else {
                    bandIndex = sampleIndex;
                  }

                  nodata = nodataValues[sourceIndex][bandIndex];
                }

                var nodataIsNaN = isNaN(nodata);

                if (!nodataIsNaN && sourceValue !== nodata || nodataIsNaN && !isNaN(sourceValue)) {
                  transparent = false;
                  data[dataIndex] = value;
                }
              }

              dataIndex++;
            }

            if (!transparent) {
              var maskIndex = sourceCount + sourceIndex;
              var mask = sourceSamples[maskIndex];

              if (mask && !mask[0][pixelIndex]) {
                transparent = true;
              }
            }
          }

          if (addAlpha) {
            if (!transparent) {
              data[dataIndex] = 255;
            }

            dataIndex++;
          }
        }

        return data;
      }
    }]);

    return GeoTIFFSource;
  }(DataTileSource);
  /**
   * Get a promise for view properties based on the source.  Use the result of this function
   * as the `view` option in a map constructor.
   *
   *     const source = new GeoTIFF(options);
   *
   *     const map = new Map({
   *       target: 'map',
   *       layers: [
   *         new TileLayer({
   *           source: source,
   *         }),
   *       ],
   *       view: source.getView(),
   *     });
   *
   * @function
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   * @api
   *
   */


  GeoTIFFSource.prototype.getView;

  /**
   * The attribution containing a link to the OpenStreetMap Copyright and License
   * page.
   * @const
   * @type {string}
   * @api
   */

  var ATTRIBUTION = '&#169; ' + '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' + 'contributors.';
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,
   * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.
   * @property {number} [maxZoom=19] Max zoom.
   * @property {boolean} [opaque=true] Whether the layer is opaque.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [transition=250] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {string} [url='https://tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
   * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
   * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
   * @property {number|import("../array.js").NearestDirectionFunction} [zDirection=0]
   * Choose whether to use tiles with a higher or lower zoom level when between integer
   * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.
   */

  /**
   * @classdesc
   * Layer source for the OpenStreetMap tile server.
   * @api
   */

  var OSM = /*#__PURE__*/function (_XYZ) {
    _inherits(OSM, _XYZ);

    var _super = _createSuper(OSM);

    /**
     * @param {Options} [options] Open Street Map options.
     */
    function OSM(options) {
      _classCallCheck(this, OSM);

      options = options || {};
      var attributions;

      if (options.attributions !== undefined) {
        attributions = options.attributions;
      } else {
        attributions = [ATTRIBUTION];
      }

      var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
      var url = options.url !== undefined ? options.url : 'https://tile.openstreetmap.org/{z}/{x}/{y}.png';
      return _super.call(this, {
        attributions: attributions,
        attributionsCollapsible: false,
        cacheSize: options.cacheSize,
        crossOrigin: crossOrigin,
        interpolate: options.interpolate,
        maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
        opaque: options.opaque !== undefined ? options.opaque : true,
        reprojectionErrorThreshold: options.reprojectionErrorThreshold,
        tileLoadFunction: options.tileLoadFunction,
        transition: options.transition,
        url: url,
        wrapX: options.wrapX,
        zDirection: options.zDirection
      });
    }

    return _createClass(OSM);
  }(XYZ);

  /**
   * @template {import("../layer/Layer.js").default} LayerType
   */

  var LayerRenderer = /*#__PURE__*/function (_Observable) {
    _inherits(LayerRenderer, _Observable);

    var _super = _createSuper(LayerRenderer);

    /**
     * @param {LayerType} layer Layer.
     */
    function LayerRenderer(layer) {
      var _this;

      _classCallCheck(this, LayerRenderer);

      _this = _super.call(this);
      /**
       * The renderer is initialized and ready to render.
       * @type {boolean}
       */

      _this.ready = true;
      /** @private */

      _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_assertThisInitialized(_this));
      /**
       * @protected
       * @type {LayerType}
       */

      _this.layer_ = layer;
      /**
       * @type {import("../render/canvas/ExecutorGroup").default}
       */

      _this.declutterExecutorGroup = null;
      return _this;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
     * an array of features.
     */


    _createClass(LayerRenderer, [{
      key: "getFeatures",
      value: function getFeatures(pixel) {
        return _abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */

    }, {
      key: "getData",
      value: function getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */

    }, {
      key: "prepareFrame",
      value: function prepareFrame(frameState) {
        return _abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */

    }, {
      key: "renderFrame",
      value: function renderFrame(frameState, target) {
        return _abstract();
      }
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */

    }, {
      key: "loadedTileCallback",
      value: function loadedTileCallback(tiles, zoom, tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }

        tiles[zoom][tile.tileCoord.toString()] = tile;
        return undefined;
      }
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */

    }, {
      key: "createLoadedTileFinder",
      value: function createLoadedTileFinder(source, projection, tiles) {
        return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           * @this {LayerRenderer}
           */
          function (zoom, tileRange) {
            var callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }.bind(this)
        );
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */

    }, {
      key: "forEachFeatureAtCoordinate",
      value: function forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return undefined;
      }
      /**
       * @return {LayerType} Layer.
       */

    }, {
      key: "getLayer",
      value: function getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */

    }, {
      key: "handleFontsChanged",
      value: function handleFontsChanged() {}
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */

    }, {
      key: "handleImageChange_",
      value: function handleImageChange_(event) {
        var image =
        /** @type {import("../Image.js").default} */
        event.target;

        if (image.getState() === ImageState.LOADED) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../ImageBase.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */

    }, {
      key: "loadImage",
      value: function loadImage(image) {
        var imageState = image.getState();

        if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
          image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
        }

        if (imageState == ImageState.IDLE) {
          image.load();
          imageState = image.getState();
        }

        return imageState == ImageState.LOADED;
      }
      /**
       * @protected
       */

    }, {
      key: "renderIfReadyAndVisible",
      value: function renderIfReadyAndVisible() {
        var layer = this.getLayer();

        if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {
          layer.changed();
        }
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        delete this.layer_;

        _get(_getPrototypeOf(LayerRenderer.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return LayerRenderer;
  }(Observable);

  /**
   * @type {CanvasRenderingContext2D}
   */

  var pixelContext$1 = null;

  function createPixelContext$1() {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    pixelContext$1 = canvas.getContext('2d');
  }
  /**
   * @abstract
   * @template {import("../../layer/Layer.js").default} LayerType
   * @extends {LayerRenderer<LayerType>}
   */


  var CanvasLayerRenderer = /*#__PURE__*/function (_LayerRenderer) {
    _inherits(CanvasLayerRenderer, _LayerRenderer);

    var _super = _createSuper(CanvasLayerRenderer);

    /**
     * @param {LayerType} layer Layer.
     */
    function CanvasLayerRenderer(layer) {
      var _this;

      _classCallCheck(this, CanvasLayerRenderer);

      _this = _super.call(this, layer);
      /**
       * @protected
       * @type {HTMLElement}
       */

      _this.container = null;
      /**
       * @protected
       * @type {number}
       */

      _this.renderedResolution;
      /**
       * A temporary transform.  The values in this transform should only be used in a
       * function that sets the values.
       * @protected
       * @type {import("../../transform.js").Transform}
       */

      _this.tempTransform = create$1();
      /**
       * The transform for rendered pixels to viewport CSS pixels.  This transform must
       * be set when rendering a frame and may be used by other functions after rendering.
       * @protected
       * @type {import("../../transform.js").Transform}
       */

      _this.pixelTransform = create$1();
      /**
       * The transform for viewport CSS pixels to rendered pixels.  This transform must
       * be set when rendering a frame and may be used by other functions after rendering.
       * @protected
       * @type {import("../../transform.js").Transform}
       */

      _this.inversePixelTransform = create$1();
      /**
       * @type {CanvasRenderingContext2D}
       */

      _this.context = null;
      /**
       * @type {boolean}
       */

      _this.containerReused = false;
      /**
       * @private
       * @type {CanvasRenderingContext2D}
       */

      _this.pixelContext_ = null;
      /**
       * @protected
       * @type {import("../../Map.js").FrameState|null}
       */

      _this.frameState = null;
      return _this;
    }
    /**
     * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */


    _createClass(CanvasLayerRenderer, [{
      key: "getImageData",
      value: function getImageData(image, col, row) {
        if (!pixelContext$1) {
          createPixelContext$1();
        }

        pixelContext$1.clearRect(0, 0, 1, 1);
        var data;

        try {
          pixelContext$1.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext$1.getImageData(0, 0, 1, 1).data;
        } catch (err) {
          pixelContext$1 = null;
          return null;
        }

        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */

    }, {
      key: "getBackground",
      value: function getBackground(frameState) {
        var layer = this.getLayer();
        var background = layer.getBackground();

        if (typeof background === 'function') {
          background = background(frameState.viewState.resolution);
        }

        return background || undefined;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {string} [backgroundColor] Background color.
       */

    }, {
      key: "useContainer",
      value: function useContainer(target, transform, backgroundColor) {
        var layerClassName = this.getLayer().getClassName();
        var container, context;

        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals$3(asArray(target.style.backgroundColor), asArray(backgroundColor)))) {
          var canvas = target.firstElementChild;

          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext('2d');
          }
        }

        if (context && context.canvas.style.transform === transform) {
          // Container of the previous layer renderer can be used.
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          // Previously reused container cannot be used any more.
          this.container = null;
          this.context = null;
          this.containerReused = false;
        }

        if (!this.container) {
          container = document.createElement('div');
          container.className = layerClassName;
          var style = container.style;
          style.position = 'absolute';
          style.width = '100%';
          style.height = '100%';
          context = createCanvasContext2D();
          var _canvas = context.canvas;
          container.appendChild(_canvas);
          style = _canvas.style;
          style.position = 'absolute';
          style.left = '0';
          style.transformOrigin = 'top left';
          this.container = container;
          this.context = context;
        }

        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */

    }, {
      key: "clipUnrotated",
      value: function clipUnrotated(context, frameState, extent) {
        var topLeft = getTopLeft(extent);
        var topRight = getTopRight(extent);
        var bottomRight = getBottomRight(extent);
        var bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        var inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */

    }, {
      key: "dispatchRenderEvent_",
      value: function dispatchRenderEvent_(type, context, frameState) {
        var layer = this.getLayer();

        if (layer.hasListener(type)) {
          var event = new RenderEvent(type, this.inversePixelTransform, frameState, context);
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "preRender",
      value: function preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "postRender",
      value: function postRender(context, frameState) {
        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */

    }, {
      key: "getRenderTransform",
      value: function getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        var dx1 = width / 2;
        var dy1 = height / 2;
        var sx = pixelRatio / resolution;
        var sy = -sx;
        var dx2 = -center[0] + offsetX;
        var dy2 = -center[1];
        return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        delete this.frameState;

        _get(_getPrototypeOf(CanvasLayerRenderer.prototype), "disposeInternal", this).call(this);
      }
    }]);

    return CanvasLayerRenderer;
  }(LayerRenderer);

  /**
   * @module ol/layer/TileProperty
   */

  /**
   * @enum {string}
   */
  var TileProperty = {
    PRELOAD: 'preload',
    USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
  };

  /***
   * @template Return
   * @typedef {import("../Observable").OnSignature<import("../Observable").EventTypes, import("../events/Event.js").default, Return> &
   *   import("../Observable").OnSignature<import("./Base").BaseLayerObjectEventTypes|
   *     'change:source'|'change:preload'|'change:useInterimTilesOnError', import("../Object").ObjectEvent, Return> &
   *   import("../Observable").OnSignature<import("../render/EventType").LayerRenderEventTypes, import("../render/Event").default, Return> &
   *   import("../Observable").CombinedOnSignature<import("../Observable").EventTypes|import("./Base").BaseLayerObjectEventTypes|
   *   'change:source'|'change:preload'|'change:useInterimTilesOnError'|import("../render/EventType").LayerRenderEventTypes, Return>} BaseTileLayerOnSignature
   */

  /**
   * @template {import("../source/Tile.js").default} TileSourceType
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
   * means no preloading.
   * @property {TileSourceType} [source] Source for this layer.
   * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link import("../Map.js").default#addLayer map.addLayer()}.
   * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
   * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
   */

  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @template {import("../source/Tile.js").default} TileSourceType
   * @template {import("../renderer/Layer.js").default} RendererType
   * @extends {Layer<TileSourceType, RendererType>}
   * @api
   */

  var BaseTileLayer = /*#__PURE__*/function (_Layer) {
    _inherits(BaseTileLayer, _Layer);

    var _super = _createSuper(BaseTileLayer);

    /**
     * @param {Options<TileSourceType>} [options] Tile layer options.
     */
    function BaseTileLayer(options) {
      var _this;

      _classCallCheck(this, BaseTileLayer);

      options = options ? options : {};
      var baseOptions = Object.assign({}, options);
      delete baseOptions.preload;
      delete baseOptions.useInterimTilesOnError;
      _this = _super.call(this, baseOptions);
      /***
       * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
       */

      _this.on;
      /***
       * @type {BaseTileLayerOnSignature<import("../events").EventsKey>}
       */

      _this.once;
      /***
       * @type {BaseTileLayerOnSignature<void>}
       */

      _this.un;

      _this.setPreload(options.preload !== undefined ? options.preload : 0);

      _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

      return _this;
    }
    /**
     * Return the level as number to which we will preload tiles up to.
     * @return {number} The level to preload tiles up to.
     * @observable
     * @api
     */


    _createClass(BaseTileLayer, [{
      key: "getPreload",
      value: function getPreload() {
        return (
          /** @type {number} */
          this.get(TileProperty.PRELOAD)
        );
      }
      /**
       * Set the level as number to which we will preload tiles up to.
       * @param {number} preload The level to preload tiles up to.
       * @observable
       * @api
       */

    }, {
      key: "setPreload",
      value: function setPreload(preload) {
        this.set(TileProperty.PRELOAD, preload);
      }
      /**
       * Whether we use interim tiles on error.
       * @return {boolean} Use interim tiles on error.
       * @observable
       * @api
       */

    }, {
      key: "getUseInterimTilesOnError",
      value: function getUseInterimTilesOnError() {
        return (
          /** @type {boolean} */
          this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)
        );
      }
      /**
       * Set whether we use interim tiles on error.
       * @param {boolean} useInterimTilesOnError Use interim tiles on error.
       * @observable
       * @api
       */

    }, {
      key: "setUseInterimTilesOnError",
      value: function setUseInterimTilesOnError(useInterimTilesOnError) {
        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      }
      /**
       * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
       * a four element RGBA array will be returned.  For data tiles, the array length will match the
       * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
       * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
       *
       * ```js
       * // display layer data on every pointer move
       * map.on('pointermove', (event) => {
       *   console.log(layer.getData(event.pixel));
       * });
       * ```
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       * @api
       */

    }, {
      key: "getData",
      value: function getData(pixel) {
        return _get(_getPrototypeOf(BaseTileLayer.prototype), "getData", this).call(this, pixel);
      }
    }]);

    return BaseTileLayer;
  }(Layer);

  /**
   * @classdesc
   * Canvas renderer for tile layers.
   * @api
   * @template {import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default} [LayerType=import("../../layer/Tile.js").default<import("../../source/Tile.js").default>|import("../../layer/VectorTile.js").default]
   * @extends {CanvasLayerRenderer<LayerType>}
   */

  var CanvasTileLayerRenderer = /*#__PURE__*/function (_CanvasLayerRenderer) {
    _inherits(CanvasTileLayerRenderer, _CanvasLayerRenderer);

    var _super = _createSuper(CanvasTileLayerRenderer);

    /**
     * @param {LayerType} tileLayer Tile layer.
     */
    function CanvasTileLayerRenderer(tileLayer) {
      var _this;

      _classCallCheck(this, CanvasTileLayerRenderer);

      _this = _super.call(this, tileLayer);
      /**
       * Rendered extent has changed since the previous `renderFrame()` call
       * @type {boolean}
       */

      _this.extentChanged = true;
      /**
       * @private
       * @type {?import("../../extent.js").Extent}
       */

      _this.renderedExtent_ = null;
      /**
       * @protected
       * @type {number}
       */

      _this.renderedPixelRatio;
      /**
       * @protected
       * @type {import("../../proj/Projection.js").default}
       */

      _this.renderedProjection = null;
      /**
       * @protected
       * @type {number}
       */

      _this.renderedRevision;
      /**
       * @protected
       * @type {!Array<import("../../Tile.js").default>}
       */

      _this.renderedTiles = [];
      /**
       * @private
       * @type {boolean}
       */

      _this.newTiles_ = false;
      /**
       * @protected
       * @type {import("../../extent.js").Extent}
       */

      _this.tmpExtent = createEmpty();
      /**
       * @private
       * @type {import("../../TileRange.js").default}
       */

      _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);
      return _this;
    }
    /**
     * @protected
     * @param {import("../../Tile.js").default} tile Tile.
     * @return {boolean} Tile is drawable.
     */


    _createClass(CanvasTileLayerRenderer, [{
      key: "isDrawableTile",
      value: function isDrawableTile(tile) {
        var tileLayer = this.getLayer();
        var tileState = tile.getState();
        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
      }
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {!import("../../Tile.js").default} Tile.
       */

    }, {
      key: "getTile",
      value: function getTile(z, x, y, frameState) {
        var pixelRatio = frameState.pixelRatio;
        var projection = frameState.viewState.projection;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var tile = tileSource.getTile(z, x, y, pixelRatio, projection);

        if (tile.getState() == TileState.ERROR) {
          if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
            // Preloaded tiles for lower resolutions might have finished loading.
            this.newTiles_ = true;
          }
        }

        if (!this.isDrawableTile(tile)) {
          tile = tile.getInterimTile();
        }

        return tile;
      }
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray} Data at the pixel location.
       */

    }, {
      key: "getData",
      value: function getData(pixel) {
        var frameState = this.frameState;

        if (!frameState) {
          return null;
        }

        var layer = this.getLayer();
        var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
        var layerExtent = layer.getExtent();

        if (layerExtent) {
          if (!containsCoordinate(layerExtent, coordinate)) {
            return null;
          }
        }

        var pixelRatio = frameState.pixelRatio;
        var projection = frameState.viewState.projection;
        var viewState = frameState.viewState;
        var source = layer.getRenderSource();
        var tileGrid = source.getTileGridForProjection(viewState.projection);
        var tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);

        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
          var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
          var tile = source.getTile(z, tileCoord[1], tileCoord[2], pixelRatio, projection);

          if (!(tile instanceof ImageTile || tile instanceof ReprojTile) || tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {
            return null;
          }

          if (tile.getState() !== TileState.LOADED) {
            continue;
          }

          var tileOrigin = tileGrid.getOrigin(z);
          var tileSize = toSize(tileGrid.getTileSize(z));
          var tileResolution = tileGrid.getResolution(z);
          var col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));
          var row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));
          var gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));
          return this.getImageData(tile.getImage(), col + gutter, row + gutter);
        }

        return null;
      }
      /**
       * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */

    }, {
      key: "loadedTileCallback",
      value: function loadedTileCallback(tiles, zoom, tile) {
        if (this.isDrawableTile(tile)) {
          return _get(_getPrototypeOf(CanvasTileLayerRenderer.prototype), "loadedTileCallback", this).call(this, tiles, zoom, tile);
        }

        return false;
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */

    }, {
      key: "prepareFrame",
      value: function prepareFrame(frameState) {
        return !!this.getLayer().getSource();
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */

    }, {
      key: "renderFrame",
      value: function renderFrame(frameState, target) {
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var viewResolution = viewState.resolution;
        var viewCenter = viewState.center;
        var rotation = viewState.rotation;
        var pixelRatio = frameState.pixelRatio;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getSource();
        var sourceRevision = tileSource.getRevision();
        var tileGrid = tileSource.getTileGridForProjection(projection);
        var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
        var tileResolution = tileGrid.getResolution(z);
        var extent = frameState.extent;
        var resolution = frameState.viewState.resolution;
        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels

        var width = Math.round(getWidth(extent) / resolution * pixelRatio);
        var height = Math.round(getHeight(extent) / resolution * pixelRatio);
        var layerExtent = layerState.extent && fromUserExtent(layerState.extent);

        if (layerExtent) {
          extent = getIntersection(extent, fromUserExtent(layerState.extent));
        }

        var dx = tileResolution * width / 2 / tilePixelRatio;
        var dy = tileResolution * height / 2 / tilePixelRatio;
        var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        /**
         * @type {Object<number, Object<string, import("../../Tile.js").default>>}
         */

        var tilesToDrawByZ = {};
        tilesToDrawByZ[z] = {};
        var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
        var tmpExtent = this.tmpExtent;
        var tmpTileRange = this.tmpTileRange_;
        this.newTiles_ = false;
        var viewport = rotation ? getRotatedViewport(viewState.center, resolution, rotation, frameState.size) : undefined;

        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
            if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
              continue;
            }

            var tile = this.getTile(z, x, y, frameState);

            if (this.isDrawableTile(tile)) {
              var uid = getUid(this);

              if (tile.getState() == TileState.LOADED) {
                tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                var inTransition = tile.inTransition(uid);

                if (inTransition && layerState.opacity !== 1) {
                  // Skipping transition when layer is not fully opaque avoids visual artifacts.
                  tile.endTransition(uid);
                  inTransition = false;
                }

                if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile))) {
                  this.newTiles_ = true;
                }
              }

              if (tile.getAlpha(uid, frameState.time) === 1) {
                // don't look for alt tiles if alpha is 1
                continue;
              }
            }

            var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
            var covered = false;

            if (childTileRange) {
              covered = findLoadedTiles(z + 1, childTileRange);
            }

            if (!covered) {
              tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
            }
          }
        }

        var canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio; // set forward and inverse pixel transforms

        compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
        var canvasTransform = toString$3(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        var context = this.context;
        var canvas = context.canvas;
        makeInverse(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas

        compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);

        if (canvas.width != width || canvas.height != height) {
          canvas.width = width;
          canvas.height = height;
        } else if (!this.containerReused) {
          context.clearRect(0, 0, width, height);
        }

        if (layerExtent) {
          this.clipUnrotated(context, frameState, layerExtent);
        }

        if (!tileSource.getInterpolate()) {
          context.imageSmoothingEnabled = false;
        }

        this.preRender(context, frameState);
        this.renderedTiles.length = 0;
        /** @type {Array<number>} */

        var zs = Object.keys(tilesToDrawByZ).map(Number);
        zs.sort(numberSafeCompareFunction);
        var clips, clipZs, currentClip;

        if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
          zs = zs.reverse();
        } else {
          clips = [];
          clipZs = [];
        }

        for (var i = zs.length - 1; i >= 0; --i) {
          var currentZ = zs[i];
          var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
          var currentResolution = tileGrid.getResolution(currentZ);
          var currentScale = currentResolution / tileResolution;

          var _dx = currentTilePixelSize[0] * currentScale * canvasScale;

          var _dy = currentTilePixelSize[1] * currentScale * canvasScale;

          var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
          var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
          var origin = apply(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
          var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
          var tilesToDraw = tilesToDrawByZ[currentZ];

          for (var tileCoordKey in tilesToDraw) {
            var _tile =
            /** @type {import("../../ImageTile.js").default} */
            tilesToDraw[tileCoordKey];
            var tileCoord = _tile.tileCoord; // Calculate integer positions and sizes so that tiles align

            var xIndex = originTileCoord[1] - tileCoord[1];
            var nextX = Math.round(origin[0] - (xIndex - 1) * _dx);
            var yIndex = originTileCoord[2] - tileCoord[2];
            var nextY = Math.round(origin[1] - (yIndex - 1) * _dy);

            var _x = Math.round(origin[0] - xIndex * _dx);

            var _y = Math.round(origin[1] - yIndex * _dy);

            var w = nextX - _x;
            var h = nextY - _y;
            var transition = z === currentZ;

            var _inTransition = transition && _tile.getAlpha(getUid(this), frameState.time) !== 1;

            var contextSaved = false;

            if (!_inTransition) {
              if (clips) {
                // Clip mask for regions in this tile that already filled by a higher z tile
                currentClip = [_x, _y, _x + w, _y, _x + w, _y + h, _x, _y + h];

                for (var _i = 0, ii = clips.length; _i < ii; ++_i) {
                  if (z !== currentZ && currentZ < clipZs[_i]) {
                    var clip = clips[_i];

                    if (intersects$1([_x, _y, _x + w, _y + h], [clip[0], clip[3], clip[4], clip[7]])) {
                      if (!contextSaved) {
                        context.save();
                        contextSaved = true;
                      }

                      context.beginPath(); // counter-clockwise (outer ring) for current tile

                      context.moveTo(currentClip[0], currentClip[1]);
                      context.lineTo(currentClip[2], currentClip[3]);
                      context.lineTo(currentClip[4], currentClip[5]);
                      context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

                      context.moveTo(clip[6], clip[7]);
                      context.lineTo(clip[4], clip[5]);
                      context.lineTo(clip[2], clip[3]);
                      context.lineTo(clip[0], clip[1]);
                      context.clip();
                    }
                  }
                }

                clips.push(currentClip);
                clipZs.push(currentZ);
              } else {
                context.clearRect(_x, _y, w, h);
              }
            }

            this.drawTileImage(_tile, frameState, _x, _y, w, h, tileGutter, transition);

            if (clips && !_inTransition) {
              if (contextSaved) {
                context.restore();
              }

              this.renderedTiles.unshift(_tile);
            } else {
              this.renderedTiles.push(_tile);
            }

            this.updateUsedTiles(frameState.usedTiles, tileSource, _tile);
          }
        }

        this.renderedRevision = sourceRevision;
        this.renderedResolution = tileResolution;
        this.extentChanged = !this.renderedExtent_ || !equals$2(this.renderedExtent_, canvasExtent);
        this.renderedExtent_ = canvasExtent;
        this.renderedPixelRatio = pixelRatio;
        this.renderedProjection = projection;
        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
        this.scheduleExpireCache(frameState, tileSource);
        this.postRender(context, frameState);

        if (layerState.extent) {
          context.restore();
        }

        context.imageSmoothingEnabled = true;

        if (canvasTransform !== canvas.style.transform) {
          canvas.style.transform = canvasTransform;
        }

        return this.container;
      }
      /**
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       */

    }, {
      key: "drawTileImage",
      value: function drawTileImage(tile, frameState, x, y, w, h, gutter, transition) {
        var image = this.getTileImage(tile);

        if (!image) {
          return;
        }

        var uid = getUid(this);
        var layerState = frameState.layerStatesArray[frameState.layerIndex];
        var alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
        var alphaChanged = alpha !== this.context.globalAlpha;

        if (alphaChanged) {
          this.context.save();
          this.context.globalAlpha = alpha;
        }

        this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

        if (alphaChanged) {
          this.context.restore();
        }

        if (alpha !== layerState.opacity) {
          frameState.animate = true;
        } else if (transition) {
          tile.endTransition(uid);
        }
      }
      /**
       * @return {HTMLCanvasElement} Image
       */

    }, {
      key: "getImage",
      value: function getImage() {
        var context = this.context;
        return context ? context.canvas : null;
      }
      /**
       * Get the image from a tile.
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @protected
       */

    }, {
      key: "getTileImage",
      value: function getTileImage(tile) {
        return tile.getImage();
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @protected
       */

    }, {
      key: "scheduleExpireCache",
      value: function scheduleExpireCache(frameState, tileSource) {
        if (tileSource.canExpireCache()) {
          /**
           * @param {import("../../source/Tile.js").default} tileSource Tile source.
           * @param {import("../../Map.js").default} map Map.
           * @param {import("../../Map.js").FrameState} frameState Frame state.
           */
          var postRenderFunction = function (tileSource, map, frameState) {
            var tileSourceKey = getUid(tileSource);

            if (tileSourceKey in frameState.usedTiles) {
              tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
            }
          }.bind(null, tileSource);

          frameState.postRenderFunctions.push(
          /** @type {import("../../Map.js").PostRenderFunction} */
          postRenderFunction);
        }
      }
      /**
       * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import('../../Tile.js').default} tile Tile.
       * @protected
       */

    }, {
      key: "updateUsedTiles",
      value: function updateUsedTiles(usedTiles, tileSource, tile) {
        // FIXME should we use tilesToDrawByZ instead?
        var tileSourceKey = getUid(tileSource);

        if (!(tileSourceKey in usedTiles)) {
          usedTiles[tileSourceKey] = {};
        }

        usedTiles[tileSourceKey][tile.getKey()] = true;
      }
      /**
       * Manage tile pyramid.
       * This function performs a number of functions related to the tiles at the
       * current zoom and lower zoom levels:
       * - registers idle tiles in frameState.wantedTiles so that they are not
       *   discarded by the tile queue
       * - enqueues missing tiles
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../proj/Projection.js").default} projection Projection.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {number} currentZ Current Z.
       * @param {number} preload Load low resolution tiles up to `preload` levels.
       * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
       * @protected
       */

    }, {
      key: "manageTilePyramid",
      value: function manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
        var tileSourceKey = getUid(tileSource);

        if (!(tileSourceKey in frameState.wantedTiles)) {
          frameState.wantedTiles[tileSourceKey] = {};
        }

        var wantedTiles = frameState.wantedTiles[tileSourceKey];
        var tileQueue = frameState.tileQueue;
        var minZoom = tileGrid.getMinZoom();
        var rotation = frameState.viewState.rotation;
        var viewport = rotation ? getRotatedViewport(frameState.viewState.center, frameState.viewState.resolution, rotation, frameState.size) : undefined;
        var tileCount = 0;
        var tile, tileRange, tileResolution, x, y, z;

        for (z = minZoom; z <= currentZ; ++z) {
          tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
          tileResolution = tileGrid.getResolution(z);

          for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
              if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
                continue;
              }

              if (currentZ - z <= preload) {
                ++tileCount;
                tile = tileSource.getTile(z, x, y, pixelRatio, projection);

                if (tile.getState() == TileState.IDLE) {
                  wantedTiles[tile.getKey()] = true;

                  if (!tileQueue.isKeyQueued(tile.getKey())) {
                    tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
                  }
                }

                if (tileCallback !== undefined) {
                  tileCallback(tile);
                }
              } else {
                tileSource.useTile(z, x, y, projection);
              }
            }
          }
        }

        tileSource.updateCacheSize(tileCount, projection);
      }
    }]);

    return CanvasTileLayerRenderer;
  }(CanvasLayerRenderer);

  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @template {import("../source/Tile.js").default} TileSourceType
   * @extends BaseTileLayer<TileSourceType, CanvasTileLayerRenderer>
   * @api
   */

  var TileLayer = /*#__PURE__*/function (_BaseTileLayer) {
    _inherits(TileLayer, _BaseTileLayer);

    var _super = _createSuper(TileLayer);

    /**
     * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
     */
    function TileLayer(options) {
      _classCallCheck(this, TileLayer);

      return _super.call(this, options);
    }

    _createClass(TileLayer, [{
      key: "createRenderer",
      value: function createRenderer() {
        return new CanvasTileLayerRenderer(this);
      }
    }]);

    return TileLayer;
  }(BaseTileLayer);

  try {
    new ImageData(10, 10);
  } catch (_) {
  }

  /**
   * @module ol/style/Stroke
   */

  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
   * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
   * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
   * @property {number} [lineDashOffset=0] Line dash offset.
   * @property {number} [miterLimit=10] Miter limit.
   * @property {number} [width] Width.
   */

  /**
   * @classdesc
   * Set stroke style for vector features.
   * Note that the defaults given are the Canvas defaults, which will be used if
   * option is not defined. The `get` functions return whatever was entered in
   * the options; they will not return the default.
   * @api
   */
  var Stroke = /*#__PURE__*/function () {
    /**
     * @param {Options} [options] Options.
     */
    function Stroke(options) {
      _classCallCheck(this, Stroke);

      options = options || {};
      /**
       * @private
       * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
       */

      this.color_ = options.color !== undefined ? options.color : null;
      /**
       * @private
       * @type {CanvasLineCap|undefined}
       */

      this.lineCap_ = options.lineCap;
      /**
       * @private
       * @type {Array<number>|null}
       */

      this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
      /**
       * @private
       * @type {number|undefined}
       */

      this.lineDashOffset_ = options.lineDashOffset;
      /**
       * @private
       * @type {CanvasLineJoin|undefined}
       */

      this.lineJoin_ = options.lineJoin;
      /**
       * @private
       * @type {number|undefined}
       */

      this.miterLimit_ = options.miterLimit;
      /**
       * @private
       * @type {number|undefined}
       */

      this.width_ = options.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */


    _createClass(Stroke, [{
      key: "clone",
      value: function clone() {
        var color = this.getColor();
        return new Stroke({
          color: Array.isArray(color) ? color.slice() : color || undefined,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */

    }, {
      key: "getColor",
      value: function getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */

    }, {
      key: "getLineCap",
      value: function getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */

    }, {
      key: "getLineDash",
      value: function getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */

    }, {
      key: "getLineDashOffset",
      value: function getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */

    }, {
      key: "getLineJoin",
      value: function getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */

    }, {
      key: "getMiterLimit",
      value: function getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */

    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */

    }, {
      key: "setLineCap",
      value: function setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */

    }, {
      key: "setLineDash",
      value: function setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */

    }, {
      key: "setLineDashOffset",
      value: function setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */

    }, {
      key: "setLineJoin",
      value: function setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */

    }, {
      key: "setMiterLimit",
      value: function setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */

    }, {
      key: "setWidth",
      value: function setWidth(width) {
        this.width_ = width;
      }
    }]);

    return Stroke;
  }();

  /**
   * @type {Stroke}
   * @private
   * @const
   */

  new Stroke({
    color: 'rgba(0,0,0,0.2)'
  });

  /**
   * @module ol/webgl
   */
  /**
   * Constants taken from goog.webgl
   */

  /**
   * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as
   * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer
   * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).
   * @const
   * @type {number}
   * @api
   */

  var ARRAY_BUFFER = 0x8892;
  /**
   * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.
   * Index buffers are essentially lists of references to vertices defined in a vertex buffer
   * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.
   * @const
   * @type {number}
   * @api
   */

  var ELEMENT_ARRAY_BUFFER = 0x8893;
  /**
   * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
   * @const
   * @type {number}
   * @api
   */

  var STREAM_DRAW = 0x88e0;
  /**
   * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
   * @const
   * @type {number}
   * @api
   */

  var STATIC_DRAW = 0x88e4;
  /**
   * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.
   * @const
   * @type {number}
   * @api
   */

  var DYNAMIC_DRAW = 0x88e8;
  /**
   * @const
   * @type {number}
   */

  var UNSIGNED_BYTE = 0x1401;
  /**
   * @const
   * @type {number}
   */

  var UNSIGNED_SHORT = 0x1403;
  /**
   * @const
   * @type {number}
   */

  var UNSIGNED_INT = 0x1405;
  /**
   * @const
   * @type {number}
   */

  var FLOAT = 0x1406;
  /** end of goog.webgl constants
   */

  /**
   * @const
   * @type {Array<string>}
   */

  var CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];
  /**
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Object} [attributes] Attributes.
   * @return {WebGLRenderingContext} WebGL rendering context.
   */

  function getContext(canvas, attributes) {
    attributes = Object.assign({
      preserveDrawingBuffer: true,
      antialias: SAFARI_BUG_237906 ? false : true // https://bugs.webkit.org/show_bug.cgi?id=237906

    }, attributes);
    var ii = CONTEXT_IDS.length;

    for (var i = 0; i < ii; ++i) {
      try {
        var context = canvas.getContext(CONTEXT_IDS[i], attributes);

        if (context) {
          return (
            /** @type {!WebGLRenderingContext} */
            context
          );
        }
      } catch (e) {// pass
      }
    }

    return null;
  }

  /**
   * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`
   * or `DYNAMIC_DRAW`.
   * @enum {number}
   */

  var BufferUsage = {
    STATIC_DRAW: STATIC_DRAW,
    STREAM_DRAW: STREAM_DRAW,
    DYNAMIC_DRAW: DYNAMIC_DRAW
  };
  /**
   * @classdesc
   * Object used to store an array of data as well as usage information for that data.
   * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on
   * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.
   *
   * To populate the array, you can either use:
   * * A size using `#ofSize(buffer)`
   * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`
   * * A plain array using `#fromArray(array)`
   *
   * Note:
   * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)
   * for more info on buffer usage.
   * @api
   */

  var WebGLArrayBuffer = /*#__PURE__*/function () {
    /**
     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
     * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
     * Default is `DYNAMIC_DRAW`.
     */
    function WebGLArrayBuffer(type, usage) {
      _classCallCheck(this, WebGLArrayBuffer);

      /**
       * @private
       * @type {Float32Array|Uint32Array}
       */
      this.array = null;
      /**
       * @private
       * @type {number}
       */

      this.type = type;
      assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);
      /**
       * @private
       * @type {number}
       */

      this.usage = usage !== undefined ? usage : BufferUsage.STATIC_DRAW;
    }
    /**
     * Populates the buffer with an array of the given size (all values will be zeroes).
     * @param {number} size Array size
     */


    _createClass(WebGLArrayBuffer, [{
      key: "ofSize",
      value: function ofSize(size) {
        this.array = new (getArrayClassForType(this.type))(size);
      }
      /**
       * Populates the buffer with an array of the given size.
       * @param {Array<number>} array Numerical array
       */

    }, {
      key: "fromArray",
      value: function fromArray(array) {
        this.array = getArrayClassForType(this.type).from(array);
      }
      /**
       * Populates the buffer with a raw binary array buffer.
       * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
       * initialized for the same typed array class.
       */

    }, {
      key: "fromArrayBuffer",
      value: function fromArrayBuffer(buffer) {
        this.array = new (getArrayClassForType(this.type))(buffer);
      }
      /**
       * @return {number} Buffer type.
       */

    }, {
      key: "getType",
      value: function getType() {
        return this.type;
      }
      /**
       * Will return null if the buffer was not initialized
       * @return {Float32Array|Uint32Array} Array.
       */

    }, {
      key: "getArray",
      value: function getArray() {
        return this.array;
      }
      /**
       * @return {number} Usage.
       */

    }, {
      key: "getUsage",
      value: function getUsage() {
        return this.usage;
      }
      /**
       * Will return 0 if the buffer is not initialized
       * @return {number} Array size
       */

    }, {
      key: "getSize",
      value: function getSize() {
        return this.array ? this.array.length : 0;
      }
    }]);

    return WebGLArrayBuffer;
  }();
  /**
   * Returns a typed array constructor based on the given buffer type
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.
   */


  function getArrayClassForType(type) {
    switch (type) {
      case ARRAY_BUFFER:
        return Float32Array;

      case ELEMENT_ARRAY_BUFFER:
        return Uint32Array;

      default:
        return Float32Array;
    }
  }

  /**
   * @module ol/webgl/ContextEventType
   */

  /**
   * @enum {string}
   */
  var ContextEventType = {
    LOST: 'webglcontextlost',
    RESTORED: 'webglcontextrestored'
  };

  var DEFAULT_VERTEX_SHADER = "\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n";
  var DEFAULT_FRAGMENT_SHADER = "\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n";
  /**
   * @typedef {Object} Options
   * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.
   * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
   * the main canvas that will then be sampled up (useful for saving resource on blur steps).
   * @property {string} [vertexShader] Vertex shader source
   * @property {string} [fragmentShader] Fragment shader source
   * @property {Object<string,import("./Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
   */

  /**
   * @typedef {Object} UniformInternalDescription
   * @property {import("./Helper").UniformValue} value Value
   * @property {number} location Location
   * @property {WebGLTexture} [texture] Texture
   * @private
   */

  /**
   * @classdesc
   * This class is used to define Post Processing passes with custom shaders and uniforms.
   * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.
   *
   * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that
   * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).
   * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.
   *
   * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be
   * premultiplied.
   *
   * Default shaders are shown hereafter:
   *
   * * Vertex shader:
   *
   *   ```
   *   precision mediump float;
   *
   *   attribute vec2 a_position;
   *   varying vec2 v_texCoord;
   *   varying vec2 v_screenCoord;
   *
   *   uniform vec2 u_screenSize;
   *
   *   void main() {
   *     v_texCoord = a_position * 0.5 + 0.5;
   *     v_screenCoord = v_texCoord * u_screenSize;
   *     gl_Position = vec4(a_position, 0.0, 1.0);
   *   }
   *   ```
   *
   * * Fragment shader:
   *
   *   ```
   *   precision mediump float;
   *
   *   uniform sampler2D u_image;
   *   uniform float u_opacity;
   *
   *   varying vec2 v_texCoord;
   *
   *   void main() {
   *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
   *   }
   *   ```
   *
   * @api
   */

  var WebGLPostProcessingPass = /*#__PURE__*/function () {
    /**
     * @param {Options} options Options.
     */
    function WebGLPostProcessingPass(options) {
      _classCallCheck(this, WebGLPostProcessingPass);

      this.gl_ = options.webGlContext;
      var gl = this.gl_;
      this.scaleRatio_ = options.scaleRatio || 1;
      this.renderTargetTexture_ = gl.createTexture();
      this.renderTargetTextureSize_ = null;
      this.frameBuffer_ = gl.createFramebuffer(); // compile the program for the frame buffer
      // TODO: make compilation errors show up

      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);
      gl.compileShader(vertexShader);
      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);
      gl.compileShader(fragmentShader);
      this.renderTargetProgram_ = gl.createProgram();
      gl.attachShader(this.renderTargetProgram_, vertexShader);
      gl.attachShader(this.renderTargetProgram_, fragmentShader);
      gl.linkProgram(this.renderTargetProgram_); // bind the vertices buffer for the frame buffer

      this.renderTargetVerticesBuffer_ = gl.createBuffer();
      var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
      gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);
      this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');
      this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');
      this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');
      this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');
      /**
       * Holds info about custom uniforms used in the post processing pass
       * @type {Array<UniformInternalDescription>}
       * @private
       */

      this.uniforms_ = [];
      options.uniforms && Object.keys(options.uniforms).forEach(function (name) {
        this.uniforms_.push({
          value: options.uniforms[name],
          location: gl.getUniformLocation(this.renderTargetProgram_, name)
        });
      }.bind(this));
    }
    /**
     * Get the WebGL rendering context
     * @return {WebGLRenderingContext} The rendering context.
     * @api
     */


    _createClass(WebGLPostProcessingPass, [{
      key: "getGL",
      value: function getGL() {
        return this.gl_;
      }
      /**
       * Initialize the render target texture of the post process, make sure it is at the
       * right size and bind it as a render target for the next draw calls.
       * The last step to be initialized will be the one where the primitives are rendered.
       * @param {import("../Map.js").FrameState} frameState current frame state
       * @api
       */

    }, {
      key: "init",
      value: function init(frameState) {
        var gl = this.getGL();
        var textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_]; // rendering goes to my buffer

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());
        gl.viewport(0, 0, textureSize[0], textureSize[1]); // if size has changed: adjust canvas & render target texture

        if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {
          this.renderTargetTextureSize_ = textureSize; // create a new texture

          var level = 0;
          var internalFormat = gl.RGBA;
          var border = 0;
          var format = gl.RGBA;
          var type = gl.UNSIGNED_BYTE;
          var data = null;
          gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);
          gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // bind the texture to the framebuffer

          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);
        }
      }
      /**
       * Render to the next postprocessing pass (or to the canvas if final pass).
       * @param {import("../Map.js").FrameState} frameState current frame state
       * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
       * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
       * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
       * @api
       */

    }, {
      key: "apply",
      value: function apply(frameState, nextPass, preCompose, postCompose) {
        var gl = this.getGL();
        var size = frameState.size;
        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);

        if (!nextPass) {
          // clear the canvas if we are the first to render to it
          // and preserveDrawingBuffer is true
          var canvasId = getUid(gl.canvas);

          if (!frameState.renderTargets[canvasId]) {
            var attributes = gl.getContextAttributes();

            if (attributes && attributes.preserveDrawingBuffer) {
              gl.clearColor(0.0, 0.0, 0.0, 0.0);
              gl.clear(gl.COLOR_BUFFER_BIT);
            }

            frameState.renderTargets[canvasId] = true;
          }
        }

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);
        gl.useProgram(this.renderTargetProgram_);
        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);
        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);
        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);
        gl.uniform1i(this.renderTargetTextureLocation_, 0);
        var opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;
        gl.uniform1f(this.renderTargetOpacityLocation_, opacity);
        this.applyUniforms(frameState);

        if (preCompose) {
          preCompose(gl, frameState);
        }

        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (postCompose) {
          postCompose(gl, frameState);
        }
      }
      /**
       * @return {WebGLFramebuffer} Frame buffer
       * @api
       */

    }, {
      key: "getFrameBuffer",
      value: function getFrameBuffer() {
        return this.frameBuffer_;
      }
      /**
       * Sets the custom uniforms based on what was given in the constructor.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @private
       */

    }, {
      key: "applyUniforms",
      value: function applyUniforms(frameState) {
        var gl = this.getGL();
        var value;
        var textureSlot = 1;
        this.uniforms_.forEach(function (uniform) {
          value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

          if (value instanceof HTMLCanvasElement || value instanceof ImageData) {
            // create a texture & put data
            if (!uniform.texture) {
              uniform.texture = gl.createTexture();
            }

            gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
            gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            if (value instanceof ImageData) {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));
            } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
            } // fill texture slots


            gl.uniform1i(uniform.location, textureSlot++);
          } else if (Array.isArray(value)) {
            switch (value.length) {
              case 2:
                gl.uniform2f(uniform.location, value[0], value[1]);
                return;

              case 3:
                gl.uniform3f(uniform.location, value[0], value[1], value[2]);
                return;

              case 4:
                gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);
                return;

              default:
                return;
            }
          } else if (typeof value === 'number') {
            gl.uniform1f(uniform.location, value);
          }
        });
      }
    }]);

    return WebGLPostProcessingPass;
  }();

  /**
   * @module ol/vec/mat4
   */

  /**
   * @return {Array<number>} "4x4 matrix representing a 3D identity transform."
   */
  function create() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  /**
   * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.
   * @param {import("../transform.js").Transform} transform Transformation matrix.
   * @return {Array<number>} "2D transformation matrix as flattened 4x4 matrix."
   */

  function fromTransform(mat4, transform) {
    mat4[0] = transform[0];
    mat4[1] = transform[1];
    mat4[4] = transform[2];
    mat4[5] = transform[3];
    mat4[12] = transform[4];
    mat4[13] = transform[5];
    return mat4;
  }

  /**
   * Names of uniforms made available to all shaders.
   * Please note: changing these *will* break custom shaders!
   * @enum {string}
   */

  var DefaultUniform = {
    PROJECTION_MATRIX: 'u_projectionMatrix',
    OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',
    OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',
    TIME: 'u_time',
    ZOOM: 'u_zoom',
    RESOLUTION: 'u_resolution',
    SIZE_PX: 'u_sizePx',
    PIXEL_RATIO: 'u_pixelRatio'
  };
  /**
   * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`
   * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.
   * @enum {number}
   */

  var AttributeType = {
    UNSIGNED_BYTE: UNSIGNED_BYTE,
    UNSIGNED_SHORT: UNSIGNED_SHORT,
    UNSIGNED_INT: UNSIGNED_INT,
    FLOAT: FLOAT
  };
  /**
   * Description of an attribute in a buffer
   * @typedef {Object} AttributeDescription
   * @property {string} name Attribute name to use in shaders
   * @property {number} size Number of components per attributes
   * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is
   * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).
   * Default is `FLOAT`.
   */

  /**
   * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import("../transform").Transform} UniformLiteralValue
   */

  /**
   * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning
   * one of the previous types.
   * @typedef {UniformLiteralValue|function(import("../Map.js").FrameState):UniformLiteralValue} UniformValue
   */

  /**
   * @typedef {Object} PostProcessesOptions
   * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
   * the main canvas which will then be sampled up (useful for saving resource on blur steps).
   * @property {string} [vertexShader] Vertex shader source
   * @property {string} [fragmentShader] Fragment shader source
   * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step
   */

  /**
   * @typedef {Object} Options
   * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform
   * names in the provided or default shaders.
   * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
   * @property {string} [canvasCacheKey] The cache key for the canvas.
   */

  /**
   * @typedef {Object} UniformInternalDescription
   * @property {string} name Name
   * @property {UniformValue} [value] Value
   * @property {WebGLTexture} [texture] Texture
   * @private
   */

  /**
   * @typedef {Object} CanvasCacheItem
   * @property {HTMLCanvasElement} canvas Canvas element.
   * @property {number} users The count of users of this canvas.
   */

  /**
   * @type {Object<string,CanvasCacheItem>}
   */

  var canvasCache = {};
  /**
   * @param {string} key The cache key for the canvas.
   * @return {string} The shared cache key.
   */

  function getSharedCanvasCacheKey(key) {
    return 'shared/' + key;
  }

  var uniqueCanvasCacheKeyCount = 0;
  /**
   * @return {string} The unique cache key.
   */

  function getUniqueCanvasCacheKey() {
    var key = 'unique/' + uniqueCanvasCacheKeyCount;
    uniqueCanvasCacheKeyCount += 1;
    return key;
  }
  /**
   * @param {string} key The cache key for the canvas.
   * @return {HTMLCanvasElement} The canvas.
   */


  function getCanvas(key) {
    var cacheItem = canvasCache[key];

    if (!cacheItem) {
      var canvas = document.createElement('canvas');
      canvas.style.position = 'absolute';
      canvas.style.left = '0';
      cacheItem = {
        users: 0,
        canvas: canvas
      };
      canvasCache[key] = cacheItem;
    }

    cacheItem.users += 1;
    return cacheItem.canvas;
  }
  /**
   * @param {string} key The cache key for the canvas.
   */


  function releaseCanvas(key) {
    var cacheItem = canvasCache[key];

    if (!cacheItem) {
      return;
    }

    cacheItem.users -= 1;

    if (cacheItem.users > 0) {
      return;
    }

    var canvas = cacheItem.canvas;
    var gl = getContext(canvas);
    var extension = gl.getExtension('WEBGL_lose_context');

    if (extension) {
      extension.loseContext();
    }

    delete canvasCache[key];
  }
  /**
   * @classdesc
   * This class is intended to provide low-level functions related to WebGL rendering, so that accessing
   * directly the WebGL API should not be required anymore.
   *
   * Several operations are handled by the `WebGLHelper` class:
   *
   * ### Define custom shaders and uniforms
   *
   *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:
   *
   *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).
   *   Outputs are:
   *
   *   * `gl_Position`: position of the vertex in screen space
   *
   *   * Varyings usually prefixed with `v_` are passed on to the fragment shader
   *
   *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.
   *
   *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that
   *   can be changed at every frame and can be of type float, arrays of float or images.
   *
   *   Shaders must be compiled and assembled into a program like so:
   *   ```js
   *   // here we simply create two shaders and assemble them in a program which is then used
   *   // for subsequent rendering calls; note how a frameState is required to set up a program,
   *   // as several default uniforms are computed from it (projection matrix, zoom level, etc.)
   *   const vertexShader = new WebGLVertex(VERTEX_SHADER);
   *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);
   *   const program = this.context.getProgram(fragmentShader, vertexShader);
   *   helper.useProgram(this.program, frameState);
   *   ```
   *
   *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.
   *   You can also change their value along the way like so:
   *   ```js
   *   helper.setUniformFloatValue('u_value', valueAsNumber);
   *   ```
   *
   * ### Defining post processing passes
   *
   *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas
   *   while applying special effects in screen space.
   *   Typical uses are: blurring, color manipulation, depth of field, filtering...
   *
   *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.
   *   A post process step accepts the following options:
   *
   *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.
   *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.
   *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.
   *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.
   *
   *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.
   *
   * ### Binding WebGL buffers and flushing data into them
   *
   *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.
   *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.
   *   This is done using {@link bindBuffer}.
   *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using
   *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.
   *
   *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}
   *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).
   *
   *   Examples below:
   *   ```js
   *   // at initialization phase
   *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
   *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);
   *
   *   // when array values have changed
   *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);
   *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
   *
   *   // at rendering phase
   *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);
   *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);
   *   ```
   *
   * ### Specifying attributes
   *
   *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).
   *   Attributes are used to specify these uses. Specify the attribute names with
   *   {@link module:ol/webgl/Helper~WebGLHelper#enableAttributes} (see code snippet below).
   *
   *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.
   *   ```js
   *   // here we indicate that the data array has the following structure:
   *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]
   *   helper.enableAttributes([
   *     {
   *        name: 'a_position',
   *        size: 2
   *     },
   *     {
   *       name: 'a_offset',
   *       size: 2
   *     },
   *     {
   *       name: 'a_texCoord',
   *       size: 2
   *     }
   *   ])
   *   ```
   *
   * ### Rendering primitives
   *
   *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.
   *   ```js
   *   // frame preparation step
   *   helper.prepareDraw(frameState);
   *
   *   // call this for every data array that has to be rendered on screen
   *   helper.drawElements(0, this.indicesBuffer.getArray().length);
   *
   *   // finalize the rendering by applying post processes
   *   helper.finalizeDraw(frameState);
   *   ```
   *
   * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.
   */


  var WebGLHelper = /*#__PURE__*/function (_Disposable) {
    _inherits(WebGLHelper, _Disposable);

    var _super = _createSuper(WebGLHelper);

    /**
     * @param {Options} [options] Options.
     */
    function WebGLHelper(options) {
      var _this;

      _classCallCheck(this, WebGLHelper);

      _this = _super.call(this);
      options = options || {};
      /** @private */

      _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_assertThisInitialized(_this));
      /** @private */

      _this.boundHandleWebGLContextRestored_ = _this.handleWebGLContextRestored.bind(_assertThisInitialized(_this));
      /**
       * @private
       * @type {string}
       */

      _this.canvasCacheKey_ = options.canvasCacheKey ? getSharedCanvasCacheKey(options.canvasCacheKey) : getUniqueCanvasCacheKey();
      /**
       * @private
       * @type {HTMLCanvasElement}
       */

      _this.canvas_ = getCanvas(_this.canvasCacheKey_);
      /**
       * @private
       * @type {WebGLRenderingContext}
       */

      _this.gl_ = getContext(_this.canvas_);
      /**
       * @private
       * @type {!Object<string, BufferCacheEntry>}
       */

      _this.bufferCache_ = {};
      /**
       * @private
       * @type {Object<string, Object>}
       */

      _this.extensionCache_ = {};
      /**
       * @private
       * @type {WebGLProgram}
       */

      _this.currentProgram_ = null;

      _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);

      _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);
      /**
       * @private
       * @type {import("../transform.js").Transform}
       */


      _this.offsetRotateMatrix_ = create$1();
      /**
       * @private
       * @type {import("../transform.js").Transform}
       */

      _this.offsetScaleMatrix_ = create$1();
      /**
       * @private
       * @type {Array<number>}
       */

      _this.tmpMat4_ = create();
      /**
       * @private
       * @type {Object<string, WebGLUniformLocation>}
       */

      _this.uniformLocations_ = {};
      /**
       * @private
       * @type {Object<string, number>}
       */

      _this.attribLocations_ = {};
      /**
       * Holds info about custom uniforms used in the post processing pass.
       * If the uniform is a texture, the WebGL Texture object will be stored here.
       * @type {Array<UniformInternalDescription>}
       * @private
       */

      _this.uniforms_ = [];

      if (options.uniforms) {
        _this.setUniforms(options.uniforms);
      }

      var gl = _this.getGL();
      /**
       * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the
       * options. If no post process was given, a default one is used (so as not to have to make an exception to
       * the frame buffer logic).
       * @type {Array<WebGLPostProcessingPass>}
       * @private
       */


      _this.postProcessPasses_ = options.postProcesses ? options.postProcesses.map(function (options) {
        return new WebGLPostProcessingPass({
          webGlContext: gl,
          scaleRatio: options.scaleRatio,
          vertexShader: options.vertexShader,
          fragmentShader: options.fragmentShader,
          uniforms: options.uniforms
        });
      }) : [new WebGLPostProcessingPass({
        webGlContext: gl
      })];
      /**
       * @type {string|null}
       * @private
       */

      _this.shaderCompileErrors_ = null;
      /**
       * @type {number}
       * @private
       */

      _this.startTime_ = Date.now();
      return _this;
    }
    /**
     * @param {Object<string, UniformValue>} uniforms Uniform definitions.
     */


    _createClass(WebGLHelper, [{
      key: "setUniforms",
      value: function setUniforms(uniforms) {
        this.uniforms_ = [];

        for (var name in uniforms) {
          this.uniforms_.push({
            name: name,
            value: uniforms[name]
          });
        }

        this.uniformLocations_ = {};
      }
      /**
       * @param {string} canvasCacheKey The canvas cache key.
       * @return {boolean} The provided key matches the one this helper was constructed with.
       */

    }, {
      key: "canvasCacheKeyMatches",
      value: function canvasCacheKeyMatches(canvasCacheKey) {
        return this.canvasCacheKey_ === getSharedCanvasCacheKey(canvasCacheKey);
      }
      /**
       * Get a WebGL extension.  If the extension is not supported, null is returned.
       * Extensions are cached after they are enabled for the first time.
       * @param {string} name The extension name.
       * @return {Object|null} The extension or null if not supported.
       */

    }, {
      key: "getExtension",
      value: function getExtension(name) {
        if (name in this.extensionCache_) {
          return this.extensionCache_[name];
        }

        var extension = this.gl_.getExtension(name);
        this.extensionCache_[name] = extension;
        return extension;
      }
      /**
       * Just bind the buffer if it's in the cache. Otherwise create
       * the WebGL buffer, bind it, populate it, and add an entry to
       * the cache.
       * @param {import("./Buffer").default} buffer Buffer.
       */

    }, {
      key: "bindBuffer",
      value: function bindBuffer(buffer) {
        var gl = this.getGL();
        var bufferKey = getUid(buffer);
        var bufferCache = this.bufferCache_[bufferKey];

        if (!bufferCache) {
          var webGlBuffer = gl.createBuffer();
          bufferCache = {
            buffer: buffer,
            webGlBuffer: webGlBuffer
          };
          this.bufferCache_[bufferKey] = bufferCache;
        }

        gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);
      }
      /**
       * Update the data contained in the buffer array; this is required for the
       * new data to be rendered
       * @param {import("./Buffer").default} buffer Buffer.
       */

    }, {
      key: "flushBufferData",
      value: function flushBufferData(buffer) {
        var gl = this.getGL();
        this.bindBuffer(buffer);
        gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());
      }
      /**
       * @param {import("./Buffer.js").default} buf Buffer.
       */

    }, {
      key: "deleteBuffer",
      value: function deleteBuffer(buf) {
        var gl = this.getGL();
        var bufferKey = getUid(buf);
        var bufferCacheEntry = this.bufferCache_[bufferKey];

        if (bufferCacheEntry && !gl.isContextLost()) {
          gl.deleteBuffer(bufferCacheEntry.webGlBuffer);
        }

        delete this.bufferCache_[bufferKey];
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);
        this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);
        releaseCanvas(this.canvasCacheKey_);
        delete this.gl_;
        delete this.canvas_;
      }
      /**
       * Clear the buffer & set the viewport to draw.
       * Post process passes will be initialized here, the first one being bound as a render target for
       * subsequent draw calls.
       * @param {import("../Map.js").FrameState} frameState current frame state
       * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
       */

    }, {
      key: "prepareDraw",
      value: function prepareDraw(frameState, disableAlphaBlend) {
        var gl = this.getGL();
        var canvas = this.getCanvas();
        var size = frameState.size;
        var pixelRatio = frameState.pixelRatio;
        canvas.width = size[0] * pixelRatio;
        canvas.height = size[1] * pixelRatio;
        canvas.style.width = size[0] + 'px';
        canvas.style.height = size[1] + 'px'; // loop backwards in post processes list

        for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {
          this.postProcessPasses_[i].init(frameState);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
      }
      /**
       * Clear the render target & bind it for future draw operations.
       * This is similar to `prepareDraw`, only post processes will not be applied.
       * Note: the whole viewport will be drawn to the render target, regardless of its size.
       * @param {import("../Map.js").FrameState} frameState current frame state
       * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
       * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
       */

    }, {
      key: "prepareDrawToRenderTarget",
      value: function prepareDrawToRenderTarget(frameState, renderTarget, disableAlphaBlend) {
        var gl = this.getGL();
        var size = renderTarget.getSize();
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());
        gl.viewport(0, 0, size[0], size[1]);
        gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);
      }
      /**
       * Execute a draw call based on the currently bound program, texture, buffers, attributes.
       * @param {number} start Start index.
       * @param {number} end End index.
       */

    }, {
      key: "drawElements",
      value: function drawElements(start, end) {
        var gl = this.getGL();
        this.getExtension('OES_element_index_uint');
        var elementType = gl.UNSIGNED_INT;
        var elementSize = 4;
        var numItems = end - start;
        var offsetInBytes = start * elementSize;
        gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);
      }
      /**
       * Apply the successive post process passes which will eventually render to the actual canvas.
       * @param {import("../Map.js").FrameState} frameState current frame state
       * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
       * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
       */

    }, {
      key: "finalizeDraw",
      value: function finalizeDraw(frameState, preCompose, postCompose) {
        // apply post processes using the next one as target
        for (var i = 0, ii = this.postProcessPasses_.length; i < ii; i++) {
          if (i === ii - 1) {
            this.postProcessPasses_[i].apply(frameState, null, preCompose, postCompose);
          } else {
            this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1]);
          }
        }
      }
      /**
       * @return {HTMLCanvasElement} Canvas.
       */

    }, {
      key: "getCanvas",
      value: function getCanvas() {
        return this.canvas_;
      }
      /**
       * Get the WebGL rendering context
       * @return {WebGLRenderingContext} The rendering context.
       */

    }, {
      key: "getGL",
      value: function getGL() {
        return this.gl_;
      }
      /**
       * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "applyFrameState",
      value: function applyFrameState(frameState) {
        var size = frameState.size;
        var rotation = frameState.viewState.rotation;
        var pixelRatio = frameState.pixelRatio;
        var offsetScaleMatrix = reset(this.offsetScaleMatrix_);
        scale$3(offsetScaleMatrix, 2 / size[0], 2 / size[1]);
        var offsetRotateMatrix = reset(this.offsetRotateMatrix_);

        if (rotation !== 0) {
          rotate$2(offsetRotateMatrix, -rotation);
        }

        this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));
        this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));
        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);
        this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);
        this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);
        this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, pixelRatio);
        this.setUniformFloatVec2(DefaultUniform.SIZE_PX, [size[0], size[1]]);
      }
      /**
       * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "applyUniforms",
      value: function applyUniforms(frameState) {
        var gl = this.getGL();
        var value;
        var textureSlot = 0;
        this.uniforms_.forEach(function (uniform) {
          value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value; // apply value based on type

          if (value instanceof HTMLCanvasElement || value instanceof HTMLImageElement || value instanceof ImageData) {
            // create a texture & put data
            if (!uniform.texture) {
              uniform.prevValue = undefined;
              uniform.texture = gl.createTexture();
            }

            gl.activeTexture(gl["TEXTURE".concat(textureSlot)]);
            gl.bindTexture(gl.TEXTURE_2D, uniform.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            var imageReady = !(value instanceof HTMLImageElement) ||
            /** @type {HTMLImageElement} */
            value.complete;

            if (imageReady && uniform.prevValue !== value) {
              uniform.prevValue = value;
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);
            } // fill texture slots by increasing index


            gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);
          } else if (Array.isArray(value) && value.length === 6) {
            this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));
          } else if (Array.isArray(value) && value.length <= 4) {
            switch (value.length) {
              case 2:
                gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);
                return;

              case 3:
                gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);
                return;

              case 4:
                gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);
                return;

              default:
                return;
            }
          } else if (typeof value === 'number') {
            gl.uniform1f(this.getUniformLocation(uniform.name), value);
          }
        }.bind(this));
      }
      /**
       * Set up a program for use. The program will be set as the current one. Then, the uniforms used
       * in the program will be set based on the current frame state and the helper configuration.
       * @param {WebGLProgram} program Program.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */

    }, {
      key: "useProgram",
      value: function useProgram(program, frameState) {
        var gl = this.getGL();
        gl.useProgram(program);
        this.currentProgram_ = program;
        this.uniformLocations_ = {};
        this.attribLocations_ = {};
        this.applyFrameState(frameState);
        this.applyUniforms(frameState);
      }
      /**
       * Will attempt to compile a vertex or fragment shader based on source
       * On error, the shader will be returned but
       * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
       * Use `gl.getShaderInfoLog(shader)` to have details
       * @param {string} source Shader source
       * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
       * @return {WebGLShader} Shader object
       */

    }, {
      key: "compileShader",
      value: function compileShader(source, type) {
        var gl = this.getGL();
        var shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }
      /**
       * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
       * @param {string} fragmentShaderSource Fragment shader source.
       * @param {string} vertexShaderSource Vertex shader source.
       * @return {WebGLProgram} Program
       */

    }, {
      key: "getProgram",
      value: function getProgram(fragmentShaderSource, vertexShaderSource) {
        var gl = this.getGL();
        var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
        var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        var program = gl.createProgram();
        gl.attachShader(program, fragmentShader);
        gl.attachShader(program, vertexShader);
        gl.linkProgram(program);

        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
          var message = "Fragment shader compliation failed: ".concat(gl.getShaderInfoLog(fragmentShader));
          throw new Error(message);
        }

        gl.deleteShader(fragmentShader);

        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
          var _message = "Vertex shader compilation failed: ".concat(gl.getShaderInfoLog(vertexShader));

          throw new Error(_message);
        }

        gl.deleteShader(vertexShader);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          var _message2 = "GL program linking failed: ".concat(gl.getShaderInfoLog(vertexShader));

          throw new Error(_message2);
        }

        return program;
      }
      /**
       * Will get the location from the shader or the cache
       * @param {string} name Uniform name
       * @return {WebGLUniformLocation} uniformLocation
       */

    }, {
      key: "getUniformLocation",
      value: function getUniformLocation(name) {
        if (this.uniformLocations_[name] === undefined) {
          this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);
        }

        return this.uniformLocations_[name];
      }
      /**
       * Will get the location from the shader or the cache
       * @param {string} name Attribute name
       * @return {number} attribLocation
       */

    }, {
      key: "getAttributeLocation",
      value: function getAttributeLocation(name) {
        if (this.attribLocations_[name] === undefined) {
          this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);
        }

        return this.attribLocations_[name];
      }
      /**
       * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.
       * The resulting transform can be used to convert world space coordinates to view coordinates.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {import("../transform").Transform} transform Transform to update.
       * @return {import("../transform").Transform} The updated transform object.
       */

    }, {
      key: "makeProjectionTransform",
      value: function makeProjectionTransform(frameState, transform) {
        var size = frameState.size;
        var rotation = frameState.viewState.rotation;
        var resolution = frameState.viewState.resolution;
        var center = frameState.viewState.center;
        reset(transform);
        compose(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);
        return transform;
      }
      /**
       * Give a value for a standard float uniform
       * @param {string} uniform Uniform name
       * @param {number} value Value
       */

    }, {
      key: "setUniformFloatValue",
      value: function setUniformFloatValue(uniform, value) {
        this.getGL().uniform1f(this.getUniformLocation(uniform), value);
      }
      /**
       * Give a value for a vec2 uniform
       * @param {string} uniform Uniform name
       * @param {Array<number>} value Array of length 4.
       */

    }, {
      key: "setUniformFloatVec2",
      value: function setUniformFloatVec2(uniform, value) {
        this.getGL().uniform2fv(this.getUniformLocation(uniform), value);
      }
      /**
       * Give a value for a vec4 uniform
       * @param {string} uniform Uniform name
       * @param {Array<number>} value Array of length 4.
       */

    }, {
      key: "setUniformFloatVec4",
      value: function setUniformFloatVec4(uniform, value) {
        this.getGL().uniform4fv(this.getUniformLocation(uniform), value);
      }
      /**
       * Give a value for a standard matrix4 uniform
       * @param {string} uniform Uniform name
       * @param {Array<number>} value Matrix value
       */

    }, {
      key: "setUniformMatrixValue",
      value: function setUniformMatrixValue(uniform, value) {
        this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);
      }
      /**
       * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
       * internally.
       * @param {string} attribName Attribute name
       * @param {number} size Number of components per attributes
       * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
       * @param {number} stride Stride in bytes (0 means attribs are packed)
       * @param {number} offset Offset in bytes
       * @private
       */

    }, {
      key: "enableAttributeArray_",
      value: function enableAttributeArray_(attribName, size, type, stride, offset) {
        var location = this.getAttributeLocation(attribName); // the attribute has not been found in the shaders; do not enable it

        if (location < 0) {
          return;
        }

        this.getGL().enableVertexAttribArray(location);
        this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);
      }
      /**
       * Will enable the following attributes to be read from the currently bound buffer,
       * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
       * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
       * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
       */

    }, {
      key: "enableAttributes",
      value: function enableAttributes(attributes) {
        var stride = computeAttributesStride(attributes);
        var offset = 0;

        for (var i = 0; i < attributes.length; i++) {
          var attr = attributes[i];
          this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);
          offset += attr.size * getByteSizeFromType(attr.type);
        }
      }
      /**
       * WebGL context was lost
       * @private
       */

    }, {
      key: "handleWebGLContextLost",
      value: function handleWebGLContextLost() {
        clear(this.bufferCache_);
        this.currentProgram_ = null;
      }
      /**
       * WebGL context was restored
       * @private
       */

    }, {
      key: "handleWebGLContextRestored",
      value: function handleWebGLContextRestored() {}
      /**
       * Will create or reuse a given webgl texture and apply the given size. If no image data
       * specified, the texture will be empty, otherwise image data will be used and the `size`
       * parameter will be ignored.
       * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
       * @param {Array<number>} size Expected size of the texture
       * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
       * @param {WebGLTexture} [texture] Existing texture to reuse
       * @return {WebGLTexture} The generated texture
       */

    }, {
      key: "createTexture",
      value: function createTexture(size, data, texture) {
        var gl = this.getGL();
        texture = texture || gl.createTexture(); // set params & size

        var level = 0;
        var internalFormat = gl.RGBA;
        var border = 0;
        var format = gl.RGBA;
        var type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, texture);

        if (data) {
          gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, data);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);
        }

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        return texture;
      }
    }]);

    return WebGLHelper;
  }(Disposable);
  /**
   * Compute a stride in bytes based on a list of attributes
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes
   * @return {number} Stride, ie amount of values for each vertex in the vertex buffer
   */


  function computeAttributesStride(attributes) {
    var stride = 0;

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes[i];
      stride += attr.size * getByteSizeFromType(attr.type);
    }

    return stride;
  }
  /**
   * Computes the size in byte of an attribute type.
   * @param {AttributeType} type Attribute type
   * @return {number} The size in bytes
   */

  function getByteSizeFromType(type) {
    switch (type) {
      case AttributeType.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;

      case AttributeType.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;

      case AttributeType.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;

      case AttributeType.FLOAT:
      default:
        return Float32Array.BYTES_PER_ELEMENT;
    }
  }

  /**
   * @typedef {Object} PostProcessesOptions
   * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than
   * the main canvas that will then be sampled up (useful for saving resource on blur steps).
   * @property {string} [vertexShader] Vertex shader source
   * @property {string} [fragmentShader] Fragment shader source
   * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process step
   */

  /**
   * @typedef {Object} Options
   * @property {Object<string,import("../../webgl/Helper").UniformValue>} [uniforms] Uniform definitions for the post process steps
   * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions
   */

  /**
   * @classdesc
   * Base WebGL renderer class.
   * Holds all logic related to data manipulation & some common rendering logic
   * @template {import("../../layer/Layer.js").default} LayerType
   * @extends {LayerRenderer<LayerType>}
   */

  var WebGLLayerRenderer = /*#__PURE__*/function (_LayerRenderer) {
    _inherits(WebGLLayerRenderer, _LayerRenderer);

    var _super = _createSuper(WebGLLayerRenderer);

    /**
     * @param {LayerType} layer Layer.
     * @param {Options} [options] Options.
     */
    function WebGLLayerRenderer(layer, options) {
      var _this;

      _classCallCheck(this, WebGLLayerRenderer);

      _this = _super.call(this, layer);
      options = options || {};
      /**
       * The transform for viewport CSS pixels to rendered pixels.  This transform is only
       * set before dispatching rendering events.
       * @private
       * @type {import("../../transform.js").Transform}
       */

      _this.inversePixelTransform_ = create$1();
      /**
       * @private
       * @type {CanvasRenderingContext2D}
       */

      _this.pixelContext_ = null;
      /**
       * @private
       */

      _this.postProcesses_ = options.postProcesses;
      /**
       * @private
       */

      _this.uniforms_ = options.uniforms;
      /**
       * @type {WebGLHelper}
       * @protected
       */

      _this.helper;
      layer.addChangeListener(LayerProperty.MAP, _this.removeHelper.bind(_assertThisInitialized(_this)));
      _this.dispatchPreComposeEvent = _this.dispatchPreComposeEvent.bind(_assertThisInitialized(_this));
      _this.dispatchPostComposeEvent = _this.dispatchPostComposeEvent.bind(_assertThisInitialized(_this));
      return _this;
    }
    /**
     * @param {WebGLRenderingContext} context The WebGL rendering context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */


    _createClass(WebGLLayerRenderer, [{
      key: "dispatchPreComposeEvent",
      value: function dispatchPreComposeEvent(context, frameState) {
        var layer = this.getLayer();

        if (layer.hasListener(RenderEventType.PRECOMPOSE)) {
          var event = new RenderEvent(RenderEventType.PRECOMPOSE, undefined, frameState, context);
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {WebGLRenderingContext} context The WebGL rendering context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "dispatchPostComposeEvent",
      value: function dispatchPostComposeEvent(context, frameState) {
        var layer = this.getLayer();

        if (layer.hasListener(RenderEventType.POSTCOMPOSE)) {
          var event = new RenderEvent(RenderEventType.POSTCOMPOSE, undefined, frameState, context);
          layer.dispatchEvent(event);
        }
      }
      /**
       * Reset options (only handles uniforms).
       * @param {Options} options Options.
       */

    }, {
      key: "reset",
      value: function reset(options) {
        this.uniforms_ = options.uniforms;

        if (this.helper) {
          this.helper.setUniforms(this.uniforms_);
        }
      }
      /**
       * @protected
       */

    }, {
      key: "removeHelper",
      value: function removeHelper() {
        if (this.helper) {
          this.helper.dispose();
          delete this.helper;
        }
      }
      /**
       * Determine whether renderFrame should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */

    }, {
      key: "prepareFrame",
      value: function prepareFrame(frameState) {
        if (this.getLayer().getRenderSource()) {
          var incrementGroup = true;
          var groupNumber = -1;
          var className;

          for (var i = 0, ii = frameState.layerStatesArray.length; i < ii; i++) {
            var layer = frameState.layerStatesArray[i].layer;
            var renderer = layer.getRenderer();

            if (!(renderer instanceof WebGLLayerRenderer)) {
              incrementGroup = true;
              continue;
            }

            var layerClassName = layer.getClassName();

            if (incrementGroup || layerClassName !== className) {
              groupNumber += 1;
              incrementGroup = false;
            }

            className = layerClassName;

            if (renderer === this) {
              break;
            }
          }

          var canvasCacheKey = 'map/' + frameState.mapId + '/group/' + groupNumber;

          if (!this.helper || !this.helper.canvasCacheKeyMatches(canvasCacheKey)) {
            this.removeHelper();
            this.helper = new WebGLHelper({
              postProcesses: this.postProcesses_,
              uniforms: this.uniforms_,
              canvasCacheKey: canvasCacheKey
            });

            if (className) {
              this.helper.getCanvas().className = className;
            }

            this.afterHelperCreated();
          }
        }

        return this.prepareFrameInternal(frameState);
      }
      /**
       * @protected
       */

    }, {
      key: "afterHelperCreated",
      value: function afterHelperCreated() {}
      /**
       * Determine whether renderFrame should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       * @protected
       */

    }, {
      key: "prepareFrameInternal",
      value: function prepareFrameInternal(frameState) {
        return true;
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        this.removeHelper();

        _get(_getPrototypeOf(WebGLLayerRenderer.prototype), "disposeInternal", this).call(this);
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {WebGLRenderingContext} context The rendering context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */

    }, {
      key: "dispatchRenderEvent_",
      value: function dispatchRenderEvent_(type, context, frameState) {
        var layer = this.getLayer();

        if (layer.hasListener(type)) {
          compose(this.inversePixelTransform_, 0, 0, frameState.pixelRatio, -frameState.pixelRatio, 0, 0, -frameState.size[1]);
          var event = new RenderEvent(type, this.inversePixelTransform_, frameState, context);
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {WebGLRenderingContext} context The rendering context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "preRender",
      value: function preRender(context, frameState) {
        this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
      }
      /**
       * @param {WebGLRenderingContext} context The rendering context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */

    }, {
      key: "postRender",
      value: function postRender(context, frameState) {
        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
      }
    }]);

    return WebGLLayerRenderer;
  }(LayerRenderer);

  var earcut$1 = {exports: {}};

  earcut$1.exports = earcut;

  earcut$1.exports["default"] = earcut;

  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  } // create a circular doubly linked list from polygon points in the specified winding order


  function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    } else {
      for (i = end - dim; i >= start; i -= dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    }

    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }

    return last;
  } // eliminate colinear or duplicate points


  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start,
        again;

    do {
      again = false;

      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);

    return end;
  } // main ear slicing loop which triangulates a polygon (given as a linked list)


  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return; // interlink polygon nodes in z-order

    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear,
        prev,
        next; // iterate through ears, slicing them one by one

    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;

      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        // cut off the triangle
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear); // skipping the next vertex leads to less sliver triangles

        ear = next.next;
        stop = next.next;
        continue;
      }

      ear = next; // if we looped through the whole remaining polygon and can't find any more ears

      if (ear === stop) {
        // try filtering points and slicing again
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }

        break;
      }
    }
  } // check whether a polygon node forms a valid ear with adjacent nodes


  function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear

    var ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;

    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }

    return true;
  }

  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x,
        bx = b.x,
        cx = c.x,
        ay = a.y,
        by = b.y,
        cy = c.y; // triangle bbox; min & max are calculated like this for speed

    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
        y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
        x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
        y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy; // z-order range for the current triangle bbox;

    var minZ = zOrder(x0, y0, minX, minY, invSize),
        maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ,
        n = ear.nextZ; // look for points inside the triangle in both directions

    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    } // look for remaining points in decreasing z-order


    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    } // look for remaining points in increasing z-order


    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    return true;
  } // go through all polygon nodes and cure small local self-intersections


  function cureLocalIntersections(start, triangles, dim) {
    var p = start;

    do {
      var a = p.prev,
          b = p.next.next;

      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0); // remove two nodes involved

        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }

      p = p.next;
    } while (p !== start);

    return filterPoints(p);
  } // try splitting polygon into two and triangulate them independently


  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;

    do {
      var b = a.next.next;

      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          // split the polygon in two by the diagonal
          var c = splitPolygon(a, b); // filter colinear points around the cuts

          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next); // run earcut on each half

          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }

        b = b.next;
      }

      a = a.next;
    } while (a !== start);
  } // link every hole into the outer loop, producing a single-ring polygon without holes


  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i,
        len,
        start,
        end,
        list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }

    queue.sort(compareX); // process holes from left to right

    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }

    return outerNode;
  }

  function compareX(a, b) {
    return a.x - b.x;
  } // find a bridge between vertices that connects hole with an outer ring and and link it


  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);

    if (!bridge) {
      return outerNode;
    }

    var bridgeReverse = splitPolygon(bridge, hole); // filter collinear points around the cuts

    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  } // David Eberly's algorithm for finding a bridge between hole and outer polygon


  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m; // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point

    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
        }
      }

      p = p.next;
    } while (p !== outerNode);

    if (!m) return null; // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;
    p = m;

    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }

      p = p.next;
    } while (p !== stop);

    return m;
  } // whether sector in vertex m contains sector in vertex p in the same coordinates


  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  } // interlink polygon nodes in z-order


  function indexCurve(start, minX, minY, invSize) {
    var p = start;

    do {
      if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  } // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


  function sortLinked(list) {
    var i,
        p,
        q,
        e,
        tail,
        numMerges,
        pSize,
        qSize,
        inSize = 1;

    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;

      while (p) {
        numMerges++;
        q = p;
        pSize = 0;

        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }

        qSize = inSize;

        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }

          if (tail) tail.nextZ = e;else list = e;
          e.prevZ = tail;
          tail = e;
        }

        p = q;
      }

      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);

    return list;
  } // z-order of a point given coords and inverse of the longer side of data bbox


  function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
  } // find the leftmost node of a polygon ring


  function getLeftmost(start) {
    var p = start,
        leftmost = start;

    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);

    return leftmost;
  } // check if a point lies within a convex triangle


  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  } // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
    locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
    area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  } // signed area of a triangle


  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  } // check if two points are equal


  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  } // check if two segments intersect


  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
  } // for collinear points p, q, r, check if point q lies on segment pr


  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }

  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  } // check if a polygon diagonal intersects any polygon segments


  function intersectsPolygon(a, b) {
    var p = a;

    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);

    return false;
  } // check if a polygon diagonal is locally inside the polygon


  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  } // check if the middle point of a polygon diagonal is inside the polygon


  function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
      p = p.next;
    } while (p !== a);

    return inside;
  } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring


  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  } // create a node and optionally link it with previous one (in a circular doubly linked list)


  function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }

    return p;
  }

  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }

  function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i; // vertex coordinates

    this.x = x;
    this.y = y; // previous and next vertex nodes in a polygon ring

    this.prev = null;
    this.next = null; // z-order curve value

    this.z = 0; // previous and next nodes in z-order

    this.prevZ = null;
    this.nextZ = null; // indicates whether this is a steiner point

    this.steiner = false;
  } // return a percentage difference between the polygon area and its triangulation area;
  // used to verify correctness of triangulation


  earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));

    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }

    var trianglesArea = 0;

    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };

  function signedArea(data, start, end, dim) {
    var sum = 0;

    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }

    return sum;
  } // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts


  earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {
      vertices: [],
      holes: [],
      dimensions: dim
    },
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) {
          result.vertices.push(data[i][j][d]);
        }
      }

      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }

    return result;
  };

  typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

  var csscolorparser = {};
  var parseCSSColor_1; // (c) Dean McNamee <dean@gmail.com>, 2012.
  //
  // https://github.com/deanm/css-color-parser-js
  //
  // Permission is hereby granted, free of charge, to any person obtaining a copy
  // of this software and associated documentation files (the "Software"), to
  // deal in the Software without restriction, including without limitation the
  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
  // sell copies of the Software, and to permit persons to whom the Software is
  // furnished to do so, subject to the following conditions:
  //
  // The above copyright notice and this permission notice shall be included in
  // all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  // IN THE SOFTWARE.
  // http://www.w3.org/TR/css3-color/

  var kCSSColorTable = {
    'transparent': [0, 0, 0, 0],
    'aliceblue': [240, 248, 255, 1],
    'antiquewhite': [250, 235, 215, 1],
    'aqua': [0, 255, 255, 1],
    'aquamarine': [127, 255, 212, 1],
    'azure': [240, 255, 255, 1],
    'beige': [245, 245, 220, 1],
    'bisque': [255, 228, 196, 1],
    'black': [0, 0, 0, 1],
    'blanchedalmond': [255, 235, 205, 1],
    'blue': [0, 0, 255, 1],
    'blueviolet': [138, 43, 226, 1],
    'brown': [165, 42, 42, 1],
    'burlywood': [222, 184, 135, 1],
    'cadetblue': [95, 158, 160, 1],
    'chartreuse': [127, 255, 0, 1],
    'chocolate': [210, 105, 30, 1],
    'coral': [255, 127, 80, 1],
    'cornflowerblue': [100, 149, 237, 1],
    'cornsilk': [255, 248, 220, 1],
    'crimson': [220, 20, 60, 1],
    'cyan': [0, 255, 255, 1],
    'darkblue': [0, 0, 139, 1],
    'darkcyan': [0, 139, 139, 1],
    'darkgoldenrod': [184, 134, 11, 1],
    'darkgray': [169, 169, 169, 1],
    'darkgreen': [0, 100, 0, 1],
    'darkgrey': [169, 169, 169, 1],
    'darkkhaki': [189, 183, 107, 1],
    'darkmagenta': [139, 0, 139, 1],
    'darkolivegreen': [85, 107, 47, 1],
    'darkorange': [255, 140, 0, 1],
    'darkorchid': [153, 50, 204, 1],
    'darkred': [139, 0, 0, 1],
    'darksalmon': [233, 150, 122, 1],
    'darkseagreen': [143, 188, 143, 1],
    'darkslateblue': [72, 61, 139, 1],
    'darkslategray': [47, 79, 79, 1],
    'darkslategrey': [47, 79, 79, 1],
    'darkturquoise': [0, 206, 209, 1],
    'darkviolet': [148, 0, 211, 1],
    'deeppink': [255, 20, 147, 1],
    'deepskyblue': [0, 191, 255, 1],
    'dimgray': [105, 105, 105, 1],
    'dimgrey': [105, 105, 105, 1],
    'dodgerblue': [30, 144, 255, 1],
    'firebrick': [178, 34, 34, 1],
    'floralwhite': [255, 250, 240, 1],
    'forestgreen': [34, 139, 34, 1],
    'fuchsia': [255, 0, 255, 1],
    'gainsboro': [220, 220, 220, 1],
    'ghostwhite': [248, 248, 255, 1],
    'gold': [255, 215, 0, 1],
    'goldenrod': [218, 165, 32, 1],
    'gray': [128, 128, 128, 1],
    'green': [0, 128, 0, 1],
    'greenyellow': [173, 255, 47, 1],
    'grey': [128, 128, 128, 1],
    'honeydew': [240, 255, 240, 1],
    'hotpink': [255, 105, 180, 1],
    'indianred': [205, 92, 92, 1],
    'indigo': [75, 0, 130, 1],
    'ivory': [255, 255, 240, 1],
    'khaki': [240, 230, 140, 1],
    'lavender': [230, 230, 250, 1],
    'lavenderblush': [255, 240, 245, 1],
    'lawngreen': [124, 252, 0, 1],
    'lemonchiffon': [255, 250, 205, 1],
    'lightblue': [173, 216, 230, 1],
    'lightcoral': [240, 128, 128, 1],
    'lightcyan': [224, 255, 255, 1],
    'lightgoldenrodyellow': [250, 250, 210, 1],
    'lightgray': [211, 211, 211, 1],
    'lightgreen': [144, 238, 144, 1],
    'lightgrey': [211, 211, 211, 1],
    'lightpink': [255, 182, 193, 1],
    'lightsalmon': [255, 160, 122, 1],
    'lightseagreen': [32, 178, 170, 1],
    'lightskyblue': [135, 206, 250, 1],
    'lightslategray': [119, 136, 153, 1],
    'lightslategrey': [119, 136, 153, 1],
    'lightsteelblue': [176, 196, 222, 1],
    'lightyellow': [255, 255, 224, 1],
    'lime': [0, 255, 0, 1],
    'limegreen': [50, 205, 50, 1],
    'linen': [250, 240, 230, 1],
    'magenta': [255, 0, 255, 1],
    'maroon': [128, 0, 0, 1],
    'mediumaquamarine': [102, 205, 170, 1],
    'mediumblue': [0, 0, 205, 1],
    'mediumorchid': [186, 85, 211, 1],
    'mediumpurple': [147, 112, 219, 1],
    'mediumseagreen': [60, 179, 113, 1],
    'mediumslateblue': [123, 104, 238, 1],
    'mediumspringgreen': [0, 250, 154, 1],
    'mediumturquoise': [72, 209, 204, 1],
    'mediumvioletred': [199, 21, 133, 1],
    'midnightblue': [25, 25, 112, 1],
    'mintcream': [245, 255, 250, 1],
    'mistyrose': [255, 228, 225, 1],
    'moccasin': [255, 228, 181, 1],
    'navajowhite': [255, 222, 173, 1],
    'navy': [0, 0, 128, 1],
    'oldlace': [253, 245, 230, 1],
    'olive': [128, 128, 0, 1],
    'olivedrab': [107, 142, 35, 1],
    'orange': [255, 165, 0, 1],
    'orangered': [255, 69, 0, 1],
    'orchid': [218, 112, 214, 1],
    'palegoldenrod': [238, 232, 170, 1],
    'palegreen': [152, 251, 152, 1],
    'paleturquoise': [175, 238, 238, 1],
    'palevioletred': [219, 112, 147, 1],
    'papayawhip': [255, 239, 213, 1],
    'peachpuff': [255, 218, 185, 1],
    'peru': [205, 133, 63, 1],
    'pink': [255, 192, 203, 1],
    'plum': [221, 160, 221, 1],
    'powderblue': [176, 224, 230, 1],
    'purple': [128, 0, 128, 1],
    'rebeccapurple': [102, 51, 153, 1],
    'red': [255, 0, 0, 1],
    'rosybrown': [188, 143, 143, 1],
    'royalblue': [65, 105, 225, 1],
    'saddlebrown': [139, 69, 19, 1],
    'salmon': [250, 128, 114, 1],
    'sandybrown': [244, 164, 96, 1],
    'seagreen': [46, 139, 87, 1],
    'seashell': [255, 245, 238, 1],
    'sienna': [160, 82, 45, 1],
    'silver': [192, 192, 192, 1],
    'skyblue': [135, 206, 235, 1],
    'slateblue': [106, 90, 205, 1],
    'slategray': [112, 128, 144, 1],
    'slategrey': [112, 128, 144, 1],
    'snow': [255, 250, 250, 1],
    'springgreen': [0, 255, 127, 1],
    'steelblue': [70, 130, 180, 1],
    'tan': [210, 180, 140, 1],
    'teal': [0, 128, 128, 1],
    'thistle': [216, 191, 216, 1],
    'tomato': [255, 99, 71, 1],
    'turquoise': [64, 224, 208, 1],
    'violet': [238, 130, 238, 1],
    'wheat': [245, 222, 179, 1],
    'white': [255, 255, 255, 1],
    'whitesmoke': [245, 245, 245, 1],
    'yellow': [255, 255, 0, 1],
    'yellowgreen': [154, 205, 50, 1]
  };

  function clamp_css_byte(i) {
    // Clamp to integer 0 .. 255.
    i = Math.round(i); // Seems to be what Chrome does (vs truncation).

    return i < 0 ? 0 : i > 255 ? 255 : i;
  }

  function clamp_css_float(f) {
    // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
  }

  function parse_css_int(str) {
    // int or percentage.
    if (str[str.length - 1] === '%') {
      return clamp_css_byte(parseFloat(str) / 100 * 255);
    }

    return clamp_css_byte(parseInt(str));
  }

  function parse_css_float(str) {
    // float or percentage.
    if (str[str.length - 1] === '%') {
      return clamp_css_float(parseFloat(str) / 100);
    }

    return clamp_css_float(parseFloat(str));
  }

  function css_hue_to_rgb(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }

    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }

    if (h * 2 < 1) {
      return m2;
    }

    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }

    return m1;
  }

  function parseCSSColor(css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.

    if (str in kCSSColorTable) {
      return kCSSColorTable[str].slice();
    } // dup.
    // #abc and #abc123 syntax.


    if (str[0] === '#') {
      if (str.length === 4) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 4095)) {
          return null;
        } // Covers NaN.


        return [(iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1];
      } else if (str.length === 7) {
        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.

        if (!(iv >= 0 && iv <= 16777215)) {
          return null;
        } // Covers NaN.


        return [(iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1];
      }

      return null;
    }

    var op = str.indexOf('('),
        ep = str.indexOf(')');

    if (op !== -1 && ep + 1 === str.length) {
      var fname = str.substr(0, op);
      var params = str.substr(op + 1, ep - (op + 1)).split(',');
      var alpha = 1; // To allow case fallthrough.

      switch (fname) {
        case 'rgba':
          if (params.length !== 4) {
            return null;
          }

          alpha = parse_css_float(params.pop());
        // Fall through.

        case 'rgb':
          if (params.length !== 3) {
            return null;
          }

          return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];

        case 'hsla':
          if (params.length !== 4) {
            return null;
          }

          alpha = parse_css_float(params.pop());
        // Fall through.

        case 'hsl':
          if (params.length !== 3) {
            return null;
          }

          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1
          // NOTE(deanm): According to the CSS spec s/l should only be
          // percentages, but we don't bother and let float or percentage.

          var s = parse_css_float(params[1]);
          var l = parse_css_float(params[2]);
          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          var m1 = l * 2 - m2;
          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];

        default:
          return null;
      }
    }

    return null;
  }

  try {
    parseCSSColor_1 = csscolorparser.parseCSSColor = parseCSSColor;
  } catch (e) {} //      

  /**
   * An RGBA color value. Create instances from color strings using the static
   * method `Color.parse`. The constructor accepts RGB channel values in the range
   * `[0, 1]`, premultiplied by A.
   *
   * @param {number} r The red channel.
   * @param {number} g The green channel.
   * @param {number} b The blue channel.
   * @param {number} a The alpha channel.
   * @private
   */


  var Color = function Color(r, g, b, a) {
    if (a === void 0) a = 1;
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  };
  /**
   * Parses valid CSS color strings and returns a `Color` instance.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */


  Color.parse = function parse(input) {
    if (!input) {
      return undefined;
    }

    if (input instanceof Color) {
      return input;
    }

    if (typeof input !== 'string') {
      return undefined;
    }

    var rgba = parseCSSColor_1(input);

    if (!rgba) {
      return undefined;
    }

    return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
  };
  /**
   * Returns an RGBA string representing the color value.
   *
   * @returns An RGBA string.
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */


  Color.prototype.toString = function toString() {
    var ref = this.toArray();
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    return "rgba(" + Math.round(r) + "," + Math.round(g) + "," + Math.round(b) + "," + a + ")";
  };
  /**
   * Returns an RGBA array of values representing the color, unpremultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 255].
   */


  Color.prototype.toArray = function toArray() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];
  };
  /**
   * Returns a RGBA array of float values representing the color, unpremultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 1].
   */


  Color.prototype.toArray01 = function toArray01() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return a === 0 ? [0, 0, 0, 0] : [r / a, g / a, b / a, a];
  };
  /**
   * Returns an RGBA array of values representing the color, premultiplied by A.
   *
   * @returns An array of RGBA color values in the range [0, 1].
   */


  Color.prototype.toArray01PremultipliedAlpha = function toArray01PremultipliedAlpha() {
    var ref = this;
    var r = ref.r;
    var g = ref.g;
    var b = ref.b;
    var a = ref.a;
    return [r, g, b, a];
  };

  Color.black = new Color(0, 0, 0, 1);
  Color.white = new Color(1, 1, 1, 1);
  Color.transparent = new Color(0, 0, 0, 0);
  Color.red = new Color(1, 0, 0, 1);
  Color.blue = new Color(0, 0, 1, 1);


  var ParsingError = /*@__PURE__*/function (Error) {
    function ParsingError(key, message) {
      Error.call(this, message);
      this.message = message;
      this.key = key;
    }

    if (Error) ParsingError.__proto__ = Error;
    ParsingError.prototype = Object.create(Error && Error.prototype);
    ParsingError.prototype.constructor = ParsingError;
    return ParsingError;
  }(Error); //      

  /**
   * Tracks `let` bindings during expression parsing.
   * @private
   */


  var Scope = function Scope(parent, bindings) {
    if (bindings === void 0) bindings = [];
    this.parent = parent;
    this.bindings = {};

    for (var i = 0, list = bindings; i < list.length; i += 1) {
      var ref = list[i];
      var name = ref[0];
      var expression = ref[1];
      this.bindings[name] = expression;
    }
  };

  Scope.prototype.concat = function concat(bindings) {
    return new Scope(this, bindings);
  };

  Scope.prototype.get = function get(name) {
    if (this.bindings[name]) {
      return this.bindings[name];
    }

    if (this.parent) {
      return this.parent.get(name);
    }

    throw new Error(name + " not found in scope.");
  };

  Scope.prototype.has = function has(name) {
    if (this.bindings[name]) {
      return true;
    }

    return this.parent ? this.parent.has(name) : false;
  }; //      


  var NullType = {
    kind: 'null'
  };
  var NumberType = {
    kind: 'number'
  };
  var StringType = {
    kind: 'string'
  };
  var BooleanType = {
    kind: 'boolean'
  };
  var ColorType = {
    kind: 'color'
  };
  var ObjectType = {
    kind: 'object'
  };
  var ValueType = {
    kind: 'value'
  };
  var ErrorType = {
    kind: 'error'
  };
  var CollatorType = {
    kind: 'collator'
  };
  var FormattedType = {
    kind: 'formatted'
  };
  var ResolvedImageType = {
    kind: 'resolvedImage'
  };

  function array$1(itemType, N) {
    return {
      kind: 'array',
      itemType: itemType,
      N: N
    };
  }

  function toString$1(type) {
    if (type.kind === 'array') {
      var itemType = toString$1(type.itemType);
      return typeof type.N === 'number' ? "array<" + itemType + ", " + type.N + ">" : type.itemType.kind === 'value' ? 'array' : "array<" + itemType + ">";
    } else {
      return type.kind;
    }
  }

  var valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array$1(ValueType), ResolvedImageType];
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message.
   * @private
   */

  function checkSubtype(expected, t) {
    if (t.kind === 'error') {
      // Error is a subtype of every type
      return null;
    } else if (expected.kind === 'array') {
      if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
        return null;
      }
    } else if (expected.kind === t.kind) {
      return null;
    } else if (expected.kind === 'value') {
      for (var i = 0, list = valueMemberTypes; i < list.length; i += 1) {
        var memberType = list[i];

        if (!checkSubtype(memberType, t)) {
          return null;
        }
      }
    }

    return "Expected " + toString$1(expected) + " but found " + toString$1(t) + " instead.";
  }

  function isValidType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
      return t.kind === provided.kind;
    });
  }

  function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(function (t) {
      if (t === 'null') {
        return provided === null;
      } else if (t === 'array') {
        return Array.isArray(provided);
      } else if (t === 'object') {
        return provided && !Array.isArray(provided) && _typeof(provided) === 'object';
      } else {
        return t === _typeof(provided);
      }
    });
  } //      
  // Flow type declarations for Intl cribbed from
  // https://github.com/facebook/flow/issues/1270


  var Collator = function Collator(caseSensitive, diacriticSensitive, locale) {
    if (caseSensitive) {
      this.sensitivity = diacriticSensitive ? 'variant' : 'case';
    } else {
      this.sensitivity = diacriticSensitive ? 'accent' : 'base';
    }

    this.locale = locale;
    this.collator = new Intl.Collator(this.locale ? this.locale : [], {
      sensitivity: this.sensitivity,
      usage: 'search'
    });
  };

  Collator.prototype.compare = function compare(lhs, rhs) {
    return this.collator.compare(lhs, rhs);
  };

  Collator.prototype.resolvedLocale = function resolvedLocale() {
    // We create a Collator without "usage: search" because we don't want
    // the search options encoded in our result (e.g. "en-u-co-search")
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }; //      


  var FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {
    // combine characters so that diacritic marks are not separate code points
    this.text = text.normalize ? text.normalize() : text;
    this.image = image;
    this.scale = scale;
    this.fontStack = fontStack;
    this.textColor = textColor;
  };

  var Formatted = function Formatted(sections) {
    this.sections = sections;
  };

  Formatted.fromString = function fromString(unformatted) {
    return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
  };

  Formatted.prototype.isEmpty = function isEmpty() {
    if (this.sections.length === 0) {
      return true;
    }

    return !this.sections.some(function (section) {
      return section.text.length !== 0 || section.image && section.image.name.length !== 0;
    });
  };

  Formatted.factory = function factory(text) {
    if (text instanceof Formatted) {
      return text;
    } else {
      return Formatted.fromString(text);
    }
  };

  Formatted.prototype.toString = function toString() {
    if (this.sections.length === 0) {
      return '';
    }

    return this.sections.map(function (section) {
      return section.text;
    }).join('');
  };

  Formatted.prototype.serialize = function serialize() {
    var serialized = ['format'];

    for (var i = 0, list = this.sections; i < list.length; i += 1) {
      var section = list[i];

      if (section.image) {
        serialized.push(['image', section.image.name]);
        continue;
      }

      serialized.push(section.text);
      var options = {};

      if (section.fontStack) {
        options['text-font'] = ['literal', section.fontStack.split(',')];
      }

      if (section.scale) {
        options['font-scale'] = section.scale;
      }

      if (section.textColor) {
        options['text-color'] = ['rgba'].concat(section.textColor.toArray());
      }

      serialized.push(options);
    }

    return serialized;
  }; //      


  var ResolvedImage = function ResolvedImage(options) {
    this.name = options.name;
    this.available = options.available;
  };

  ResolvedImage.prototype.toString = function toString() {
    return this.name;
  };

  ResolvedImage.fromString = function fromString(name) {
    if (!name) {
      return null;
    } // treat empty values as no image


    return new ResolvedImage({
      name: name,
      available: false
    });
  };

  ResolvedImage.prototype.serialize = function serialize() {
    return ['image', this.name];
  };

  function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
      var value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];
      return "Invalid rgba value [" + value.join(', ') + "]: 'r', 'g', and 'b' must be between 0 and 255.";
    }

    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
      return "Invalid rgba value [" + [r, g, b, a].join(', ') + "]: 'a' must be between 0 and 1.";
    }

    return null;
  }

  function isValue(mixed) {
    if (mixed === null) {
      return true;
    } else if (typeof mixed === 'string') {
      return true;
    } else if (typeof mixed === 'boolean') {
      return true;
    } else if (typeof mixed === 'number') {
      return true;
    } else if (mixed instanceof Color) {
      return true;
    } else if (mixed instanceof Collator) {
      return true;
    } else if (mixed instanceof Formatted) {
      return true;
    } else if (mixed instanceof ResolvedImage) {
      return true;
    } else if (Array.isArray(mixed)) {
      for (var i = 0, list = mixed; i < list.length; i += 1) {
        var item = list[i];

        if (!isValue(item)) {
          return false;
        }
      }

      return true;
    } else if (_typeof(mixed) === 'object') {
      for (var key in mixed) {
        if (!isValue(mixed[key])) {
          return false;
        }
      }

      return true;
    } else {
      return false;
    }
  }

  function typeOf(value) {
    if (value === null) {
      return NullType;
    } else if (typeof value === 'string') {
      return StringType;
    } else if (typeof value === 'boolean') {
      return BooleanType;
    } else if (typeof value === 'number') {
      return NumberType;
    } else if (value instanceof Color) {
      return ColorType;
    } else if (value instanceof Collator) {
      return CollatorType;
    } else if (value instanceof Formatted) {
      return FormattedType;
    } else if (value instanceof ResolvedImage) {
      return ResolvedImageType;
    } else if (Array.isArray(value)) {
      var length = value.length;
      var itemType;

      for (var i = 0, list = value; i < list.length; i += 1) {
        var item = list[i];
        var t = typeOf(item);

        if (!itemType) {
          itemType = t;
        } else if (itemType === t) {
          continue;
        } else {
          itemType = ValueType;
          break;
        }
      }

      return array$1(itemType || ValueType, length);
    } else {
      return ObjectType;
    }
  }

  function toString(value) {
    var type = _typeof(value);

    if (value === null) {
      return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
      return String(value);
    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {
      return value.toString();
    } else {
      return JSON.stringify(value);
    }
  }

  var Literal = function Literal(type, value) {
    this.type = type;
    this.value = value;
  };

  Literal.parse = function parse(args, context) {
    if (args.length !== 2) {
      return context.error("'literal' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
    }

    if (!isValue(args[1])) {
      return context.error("invalid value");
    }

    var value = args[1];
    var type = typeOf(value); // special case: infer the item type if possible for zero-length arrays

    var expected = context.expectedType;

    if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
      type = expected;
    }

    return new Literal(type, value);
  };

  Literal.prototype.evaluate = function evaluate() {
    return this.value;
  };

  Literal.prototype.eachChild = function eachChild() {};

  Literal.prototype.outputDefined = function outputDefined() {
    return true;
  };

  Literal.prototype.serialize = function serialize() {
    if (this.type.kind === 'array' || this.type.kind === 'object') {
      return ['literal', this.value];
    } else if (this.value instanceof Color) {
      // Constant-folding can generate Literal expressions that you
      // couldn't actually generate with a "literal" expression,
      // so we have to implement an equivalent serialization here
      return ['rgba'].concat(this.value.toArray());
    } else if (this.value instanceof Formatted) {
      // Same as Color
      return this.value.serialize();
    } else {
      return this.value;
    }
  }; //      


  var RuntimeError = function RuntimeError(message) {
    this.name = 'ExpressionEvaluationError';
    this.message = message;
  };

  RuntimeError.prototype.toJSON = function toJSON() {
    return this.message;
  };

  var types$2 = {
    string: StringType,
    number: NumberType,
    "boolean": BooleanType,
    object: ObjectType
  };

  var Assertion = function Assertion(type, args) {
    this.type = type;
    this.args = args;
  };

  Assertion.parse = function parse(args, context) {
    if (args.length < 2) {
      return context.error("Expected at least one argument.");
    }

    var i = 1;
    var type;
    var name = args[0];

    if (name === 'array') {
      var itemType;

      if (args.length > 2) {
        var type$1 = args[1];

        if (typeof type$1 !== 'string' || !(type$1 in types$2) || type$1 === 'object') {
          return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
        }

        itemType = types$2[type$1];
        i++;
      } else {
        itemType = ValueType;
      }

      var N;

      if (args.length > 3) {
        if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
          return context.error('The length argument to "array" must be a positive integer literal', 2);
        }

        N = args[2];
        i++;
      }

      type = array$1(itemType, N);
    } else {
      type = types$2[name];
    }

    var parsed = [];

    for (; i < args.length; i++) {
      var input = context.parse(args[i], i, ValueType);

      if (!input) {
        return null;
      }

      parsed.push(input);
    }

    return new Assertion(type, parsed);
  };

  Assertion.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0; i < this.args.length; i++) {
      var value = this.args[i].evaluate(ctx);
      var error = checkSubtype(this.type, typeOf(value));

      if (!error) {
        return value;
      } else if (i === this.args.length - 1) {
        throw new RuntimeError("Expected value to be of type " + toString$1(this.type) + ", but found " + toString$1(typeOf(value)) + " instead.");
      }
    }

    return null;
  };

  Assertion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
  };

  Assertion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
      return arg.outputDefined();
    });
  };

  Assertion.prototype.serialize = function serialize() {
    var type = this.type;
    var serialized = [type.kind];

    if (type.kind === 'array') {
      var itemType = type.itemType;

      if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
        serialized.push(itemType.kind);
        var N = type.N;

        if (typeof N === 'number' || this.args.length > 1) {
          serialized.push(N);
        }
      }
    }

    return serialized.concat(this.args.map(function (arg) {
      return arg.serialize();
    }));
  }; //      


  var FormatExpression = function FormatExpression(sections) {
    this.type = FormattedType;
    this.sections = sections;
  };

  FormatExpression.parse = function parse(args, context) {
    if (args.length < 2) {
      return context.error("Expected at least one argument.");
    }

    var firstArg = args[1];

    if (!Array.isArray(firstArg) && _typeof(firstArg) === 'object') {
      return context.error("First argument must be an image or text section.");
    }

    var sections = [];
    var nextTokenMayBeObject = false;

    for (var i = 1; i <= args.length - 1; ++i) {
      var arg = args[i];

      if (nextTokenMayBeObject && _typeof(arg) === 'object' && !Array.isArray(arg)) {
        nextTokenMayBeObject = false;
        var scale = null;

        if (arg['font-scale']) {
          scale = context.parse(arg['font-scale'], 1, NumberType);

          if (!scale) {
            return null;
          }
        }

        var font = null;

        if (arg['text-font']) {
          font = context.parse(arg['text-font'], 1, array$1(StringType));

          if (!font) {
            return null;
          }
        }

        var textColor = null;

        if (arg['text-color']) {
          textColor = context.parse(arg['text-color'], 1, ColorType);

          if (!textColor) {
            return null;
          }
        }

        var lastExpression = sections[sections.length - 1];
        lastExpression.scale = scale;
        lastExpression.font = font;
        lastExpression.textColor = textColor;
      } else {
        var content = context.parse(args[i], 1, ValueType);

        if (!content) {
          return null;
        }

        var kind = content.type.kind;

        if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage') {
          return context.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        }

        nextTokenMayBeObject = true;
        sections.push({
          content: content,
          scale: null,
          font: null,
          textColor: null
        });
      }
    }

    return new FormatExpression(sections);
  };

  FormatExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluateSection = function evaluateSection(section) {
      var evaluatedContent = section.content.evaluate(ctx);

      if (typeOf(evaluatedContent) === ResolvedImageType) {
        return new FormattedSection('', evaluatedContent, null, null, null);
      }

      return new FormattedSection(toString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
    };

    return new Formatted(this.sections.map(evaluateSection));
  };

  FormatExpression.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.sections; i < list.length; i += 1) {
      var section = list[i];
      fn(section.content);

      if (section.scale) {
        fn(section.scale);
      }

      if (section.font) {
        fn(section.font);
      }

      if (section.textColor) {
        fn(section.textColor);
      }
    }
  };

  FormatExpression.prototype.outputDefined = function outputDefined() {
    // Technically the combinatoric set of all children
    // Usually, this.text will be undefined anyway
    return false;
  };

  FormatExpression.prototype.serialize = function serialize() {
    var serialized = ['format'];

    for (var i = 0, list = this.sections; i < list.length; i += 1) {
      var section = list[i];
      serialized.push(section.content.serialize());
      var options = {};

      if (section.scale) {
        options['font-scale'] = section.scale.serialize();
      }

      if (section.font) {
        options['text-font'] = section.font.serialize();
      }

      if (section.textColor) {
        options['text-color'] = section.textColor.serialize();
      }

      serialized.push(options);
    }

    return serialized;
  }; //      


  var ImageExpression = function ImageExpression(input) {
    this.type = ResolvedImageType;
    this.input = input;
  };

  ImageExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
      return context.error("Expected two arguments.");
    }

    var name = context.parse(args[1], 1, StringType);

    if (!name) {
      return context.error("No image name provided.");
    }

    return new ImageExpression(name);
  };

  ImageExpression.prototype.evaluate = function evaluate(ctx) {
    var evaluatedImageName = this.input.evaluate(ctx);
    var value = ResolvedImage.fromString(evaluatedImageName);

    if (value && ctx.availableImages) {
      value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
    }

    return value;
  };

  ImageExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
  };

  ImageExpression.prototype.outputDefined = function outputDefined() {
    // The output of image is determined by the list of available images in the evaluation context
    return false;
  };

  ImageExpression.prototype.serialize = function serialize() {
    return ['image', this.input.serialize()];
  };

  var types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
  };
  /**
   * Special form for error-coalescing coercion expressions "to-number",
   * "to-color".  Since these coercions can fail at runtime, they accept multiple
   * arguments, only evaluating one at a time until one succeeds.
   *
   * @private
   */

  var Coercion = function Coercion(type, args) {
    this.type = type;
    this.args = args;
  };

  Coercion.parse = function parse(args, context) {
    if (args.length < 2) {
      return context.error("Expected at least one argument.");
    }

    var name = args[0];

    if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2) {
      return context.error("Expected one argument.");
    }

    var type = types$1[name];
    var parsed = [];

    for (var i = 1; i < args.length; i++) {
      var input = context.parse(args[i], i, ValueType);

      if (!input) {
        return null;
      }

      parsed.push(input);
    }

    return new Coercion(type, parsed);
  };

  Coercion.prototype.evaluate = function evaluate(ctx) {
    if (this.type.kind === 'boolean') {
      return Boolean(this.args[0].evaluate(ctx));
    } else if (this.type.kind === 'color') {
      var input;
      var error;

      for (var i = 0, list = this.args; i < list.length; i += 1) {
        var arg = list[i];
        input = arg.evaluate(ctx);
        error = null;

        if (input instanceof Color) {
          return input;
        } else if (typeof input === 'string') {
          var c = ctx.parseColor(input);

          if (c) {
            return c;
          }
        } else if (Array.isArray(input)) {
          if (input.length < 3 || input.length > 4) {
            error = "Invalid rbga value " + JSON.stringify(input) + ": expected an array containing either three or four numeric values.";
          } else {
            error = validateRGBA(input[0], input[1], input[2], input[3]);
          }

          if (!error) {
            return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
          }
        }
      }

      throw new RuntimeError(error || "Could not parse color from value '" + (typeof input === 'string' ? input : String(JSON.stringify(input))) + "'");
    } else if (this.type.kind === 'number') {
      var value = null;

      for (var i$1 = 0, list$1 = this.args; i$1 < list$1.length; i$1 += 1) {
        var arg$1 = list$1[i$1];
        value = arg$1.evaluate(ctx);

        if (value === null) {
          return 0;
        }

        var num = Number(value);

        if (isNaN(num)) {
          continue;
        }

        return num;
      }

      throw new RuntimeError("Could not convert " + JSON.stringify(value) + " to number.");
    } else if (this.type.kind === 'formatted') {
      // There is no explicit 'to-formatted' but this coercion can be implicitly
      // created by properties that expect the 'formatted' type.
      return Formatted.fromString(toString(this.args[0].evaluate(ctx)));
    } else if (this.type.kind === 'resolvedImage') {
      return ResolvedImage.fromString(toString(this.args[0].evaluate(ctx)));
    } else {
      return toString(this.args[0].evaluate(ctx));
    }
  };

  Coercion.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
  };

  Coercion.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
      return arg.outputDefined();
    });
  };

  Coercion.prototype.serialize = function serialize() {
    if (this.type.kind === 'formatted') {
      return new FormatExpression([{
        content: this.args[0],
        scale: null,
        font: null,
        textColor: null
      }]).serialize();
    }

    if (this.type.kind === 'resolvedImage') {
      return new ImageExpression(this.args[0]).serialize();
    }

    var serialized = ["to-" + this.type.kind];
    this.eachChild(function (child) {
      serialized.push(child.serialize());
    });
    return serialized;
  }; //      


  var geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];

  var EvaluationContext = function EvaluationContext() {
    this.globals = null;
    this.feature = null;
    this.featureState = null;
    this.formattedSection = null;
    this._parseColorCache = {};
    this.availableImages = null;
    this.canonical = null;
    this.featureTileCoord = null;
    this.featureDistanceData = null;
  };

  EvaluationContext.prototype.id = function id() {
    return this.feature && 'id' in this.feature && this.feature.id ? this.feature.id : null;
  };

  EvaluationContext.prototype.geometryType = function geometryType() {
    return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
  };

  EvaluationContext.prototype.geometry = function geometry() {
    return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
  };

  EvaluationContext.prototype.canonicalID = function canonicalID() {
    return this.canonical;
  };

  EvaluationContext.prototype.properties = function properties() {
    return this.feature && this.feature.properties || {};
  };

  EvaluationContext.prototype.distanceFromCenter = function distanceFromCenter() {
    if (this.featureTileCoord && this.featureDistanceData) {
      var c = this.featureDistanceData.center;
      var scale = this.featureDistanceData.scale;
      var ref = this.featureTileCoord;
      var x = ref.x;
      var y = ref.y; // Calculate the distance vector `d` (left handed)

      var dX = x * scale - c[0];
      var dY = y * scale - c[1]; // The bearing vector `b` (left handed)

      var bX = this.featureDistanceData.bearing[0];
      var bY = this.featureDistanceData.bearing[1]; // Distance is calculated as `dot(d, v)`

      var dist = bX * dX + bY * dY;
      return dist;
    }

    return 0;
  };

  EvaluationContext.prototype.parseColor = function parseColor(input) {
    var cached = this._parseColorCache[input];

    if (!cached) {
      cached = this._parseColorCache[input] = Color.parse(input);
    }

    return cached;
  }; //      


  var CompoundExpression = function CompoundExpression(name, type, evaluate, args) {
    this.name = name;
    this.type = type;
    this._evaluate = evaluate;
    this.args = args;
  };

  CompoundExpression.prototype.evaluate = function evaluate(ctx) {
    return this._evaluate(ctx, this.args);
  };

  CompoundExpression.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
  };

  CompoundExpression.prototype.outputDefined = function outputDefined() {
    return false;
  };

  CompoundExpression.prototype.serialize = function serialize() {
    return [this.name].concat(this.args.map(function (arg) {
      return arg.serialize();
    }));
  };

  CompoundExpression.parse = function parse(args, context) {
    var ref$1;
    var op = args[0];
    var definition = CompoundExpression.definitions[op];

    if (!definition) {
      return context.error("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]].", 0);
    } // Now check argument types against each signature


    var type = Array.isArray(definition) ? definition[0] : definition.type;
    var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;
    var overloads = availableOverloads.filter(function (ref) {
      var signature = ref[0];
      return !Array.isArray(signature) || // varags
      signature.length === args.length - 1;
    } // correct param count
    );
    var signatureContext = null;

    for (var i$3 = 0, list = overloads; i$3 < list.length; i$3 += 1) {
      // Use a fresh context for each attempted signature so that, if
      // we eventually succeed, we haven't polluted `context.errors`.
      var ref = list[i$3];
      var params = ref[0];
      var evaluate = ref[1];
      signatureContext = new ParsingContext(context.registry, context.path, null, context.scope); // First parse all the args, potentially coercing to the
      // types expected by this overload.

      var parsedArgs = [];
      var argParseFailed = false;

      for (var i = 1; i < args.length; i++) {
        var arg = args[i];
        var expectedType = Array.isArray(params) ? params[i - 1] : params.type;
        var parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);

        if (!parsed) {
          argParseFailed = true;
          break;
        }

        parsedArgs.push(parsed);
      }

      if (argParseFailed) {
        // Couldn't coerce args of this overload to expected type, move
        // on to next one.
        continue;
      }

      if (Array.isArray(params)) {
        if (params.length !== parsedArgs.length) {
          signatureContext.error("Expected " + params.length + " arguments, but found " + parsedArgs.length + " instead.");
          continue;
        }
      }

      for (var i$1 = 0; i$1 < parsedArgs.length; i$1++) {
        var expected = Array.isArray(params) ? params[i$1] : params.type;
        var arg$1 = parsedArgs[i$1];
        signatureContext.concat(i$1 + 1).checkSubtype(expected, arg$1.type);
      }

      if (signatureContext.errors.length === 0) {
        return new CompoundExpression(op, type, evaluate, parsedArgs);
      }
    }

    if (overloads.length === 1) {
      (ref$1 = context.errors).push.apply(ref$1, signatureContext.errors);
    } else {
      var expected$1 = overloads.length ? overloads : availableOverloads;
      var signatures = expected$1.map(function (ref) {
        var params = ref[0];
        return stringifySignature(params);
      }).join(' | ');
      var actualTypes = []; // For error message, re-parse arguments without trying to
      // apply any coercions

      for (var i$2 = 1; i$2 < args.length; i$2++) {
        var parsed$1 = context.parse(args[i$2], 1 + actualTypes.length);

        if (!parsed$1) {
          return null;
        }

        actualTypes.push(toString$1(parsed$1.type));
      }

      context.error("Expected arguments of type " + signatures + ", but found (" + actualTypes.join(', ') + ") instead.");
    }

    return null;
  };

  CompoundExpression.register = function register(registry, definitions) {
    CompoundExpression.definitions = definitions;

    for (var name in definitions) {
      registry[name] = CompoundExpression;
    }
  };

  function stringifySignature(signature) {
    if (Array.isArray(signature)) {
      return "(" + signature.map(toString$1).join(', ') + ")";
    } else {
      return "(" + toString$1(signature.type) + "...)";
    }
  } //      


  var CollatorExpression = function CollatorExpression(caseSensitive, diacriticSensitive, locale) {
    this.type = CollatorType;
    this.locale = locale;
    this.caseSensitive = caseSensitive;
    this.diacriticSensitive = diacriticSensitive;
  };

  CollatorExpression.parse = function parse(args, context) {
    if (args.length !== 2) {
      return context.error("Expected one argument.");
    }

    var options = args[1];

    if (_typeof(options) !== 'object' || Array.isArray(options)) {
      return context.error("Collator options argument must be an object.");
    }

    var caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);

    if (!caseSensitive) {
      return null;
    }

    var diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);

    if (!diacriticSensitive) {
      return null;
    }

    var locale = null;

    if (options['locale']) {
      locale = context.parse(options['locale'], 1, StringType);

      if (!locale) {
        return null;
      }
    }

    return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
  };

  CollatorExpression.prototype.evaluate = function evaluate(ctx) {
    return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
  };

  CollatorExpression.prototype.eachChild = function eachChild(fn) {
    fn(this.caseSensitive);
    fn(this.diacriticSensitive);

    if (this.locale) {
      fn(this.locale);
    }
  };

  CollatorExpression.prototype.outputDefined = function outputDefined() {
    // Technically the set of possible outputs is the combinatoric set of Collators produced
    // by all possible outputs of locale/caseSensitive/diacriticSensitive
    // But for the primary use of Collators in comparison operators, we ignore the Collator's
    // possible outputs anyway, so we can get away with leaving this false for now.
    return false;
  };

  CollatorExpression.prototype.serialize = function serialize() {
    var options = {};
    options['case-sensitive'] = this.caseSensitive.serialize();
    options['diacritic-sensitive'] = this.diacriticSensitive.serialize();

    if (this.locale) {
      options['locale'] = this.locale.serialize();
    }

    return ['collator', options];
  }; //      
  // minX, minY, maxX, maxY


  var EXTENT = 8192;

  function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
  }

  function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
  }

  function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
  }

  function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0]) {
      return false;
    }

    if (bbox1[2] >= bbox2[2]) {
      return false;
    }

    if (bbox1[1] <= bbox2[1]) {
      return false;
    }

    if (bbox1[3] >= bbox2[3]) {
      return false;
    }

    return true;
  }

  function getTileCoordinates(p, canonical) {
    var x = mercatorXfromLng(p[0]);
    var y = mercatorYfromLat(p[1]);
    var tilesAtZoom = Math.pow(2, canonical.z);
    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];
  }

  function onBoundary(p, p1, p2) {
    var x1 = p[0] - p1[0];
    var y1 = p[1] - p1[1];
    var x2 = p[0] - p2[0];
    var y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
  }

  function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
  } // ray casting algorithm for detecting if point is in polygon


  function pointWithinPolygon(point, rings) {
    var inside = false;

    for (var i = 0, len = rings.length; i < len; i++) {
      var ring = rings[i];

      for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {
        if (onBoundary(point, ring[j], ring[j + 1])) {
          return false;
        }

        if (rayIntersect(point, ring[j], ring[j + 1])) {
          inside = !inside;
        }
      }
    }

    return inside;
  }

  function pointWithinPolygons(point, polygons) {
    for (var i = 0; i < polygons.length; i++) {
      if (pointWithinPolygon(point, polygons[i])) {
        return true;
      }
    }

    return false;
  }

  function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
  } // check if p1 and p2 are in different sides of line segment q1->q2


  function twoSided(p1, p2, q1, q2) {
    // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)
    var x1 = p1[0] - q1[0];
    var y1 = p1[1] - q1[1];
    var x2 = p2[0] - q1[0];
    var y2 = p2[1] - q1[1];
    var x3 = q2[0] - q1[0];
    var y3 = q2[1] - q1[1];
    var det1 = x1 * y3 - x3 * y1;
    var det2 = x2 * y3 - x3 * y2;

    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) {
      return true;
    }

    return false;
  } // a, b are end points for line segment1, c and d are end points for line segment2


  function lineIntersectLine(a, b, c, d) {
    // check if two segments are parallel or not
    // precondition is end point a, b is inside polygon, if line a->b is
    // parallel to polygon edge c->d, then a->b won't intersect with c->d
    var vectorP = [b[0] - a[0], b[1] - a[1]];
    var vectorQ = [d[0] - c[0], d[1] - c[1]];

    if (perp(vectorQ, vectorP) === 0) {
      return false;
    } // If lines are intersecting with each other, the relative location should be:
    // a and b lie in different sides of segment c->d
    // c and d lie in different sides of segment a->b


    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) {
      return true;
    }

    return false;
  }

  function lineIntersectPolygon(p1, p2, polygon) {
    for (var i = 0, list = polygon; i < list.length; i += 1) {
      // loop through every edge of the ring
      var ring = list[i];

      for (var j = 0; j < ring.length - 1; ++j) {
        if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
          return true;
        }
      }
    }

    return false;
  }

  function lineStringWithinPolygon(line, polygon) {
    // First, check if geometry points of line segments are all inside polygon
    for (var i = 0; i < line.length; ++i) {
      if (!pointWithinPolygon(line[i], polygon)) {
        return false;
      }
    } // Second, check if there is line segment intersecting polygon edge


    for (var i$1 = 0; i$1 < line.length - 1; ++i$1) {
      if (lineIntersectPolygon(line[i$1], line[i$1 + 1], polygon)) {
        return false;
      }
    }

    return true;
  }

  function lineStringWithinPolygons(line, polygons) {
    for (var i = 0; i < polygons.length; i++) {
      if (lineStringWithinPolygon(line, polygons[i])) {
        return true;
      }
    }

    return false;
  }

  function getTilePolygon(coordinates, bbox, canonical) {
    var polygon = [];

    for (var i = 0; i < coordinates.length; i++) {
      var ring = [];

      for (var j = 0; j < coordinates[i].length; j++) {
        var coord = getTileCoordinates(coordinates[i][j], canonical);
        updateBBox(bbox, coord);
        ring.push(coord);
      }

      polygon.push(ring);
    }

    return polygon;
  }

  function getTilePolygons(coordinates, bbox, canonical) {
    var polygons = [];

    for (var i = 0; i < coordinates.length; i++) {
      var polygon = getTilePolygon(coordinates[i], bbox, canonical);
      polygons.push(polygon);
    }

    return polygons;
  }

  function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
      var halfWorldSize = worldSize * 0.5;
      var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;

      if (shift === 0) {
        shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
      }

      p[0] += shift;
    }

    updateBBox(bbox, p);
  }

  function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
  }

  function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tilePoints = [];

    if (!geometry) {
      return tilePoints;
    }

    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
      var points = list$1[i$1];

      for (var i = 0, list = points; i < list.length; i += 1) {
        var point = list[i];
        var p = [point.x + shifts[0], point.y + shifts[1]];
        updatePoint(p, pointBBox, polyBBox, worldSize);
        tilePoints.push(p);
      }
    }

    return tilePoints;
  }

  function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    var worldSize = Math.pow(2, canonical.z) * EXTENT;
    var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];
    var tileLines = [];

    if (!geometry) {
      return tileLines;
    }

    for (var i$1 = 0, list$1 = geometry; i$1 < list$1.length; i$1 += 1) {
      var line = list$1[i$1];
      var tileLine = [];

      for (var i = 0, list = line; i < list.length; i += 1) {
        var point = list[i];
        var p = [point.x + shifts[0], point.y + shifts[1]];
        updateBBox(lineBBox, p);
        tileLine.push(p);
      }

      tileLines.push(tileLine);
    }

    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
      resetBBox(lineBBox);

      for (var i$3 = 0, list$3 = tileLines; i$3 < list$3.length; i$3 += 1) {
        var line$1 = list$3[i$3];

        for (var i$2 = 0, list$2 = line$1; i$2 < list$2.length; i$2 += 1) {
          var p$1 = list$2[i$2];
          updatePoint(p$1, lineBBox, polyBBox, worldSize);
        }
      }
    }

    return tileLines;
  }

  function pointsWithinPolygons(ctx, polygonGeometry) {
    var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();

    if (!canonical) {
      return false;
    }

    if (polygonGeometry.type === 'Polygon') {
      var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
      var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);

      if (!boxWithinBox(pointBBox, polyBBox)) {
        return false;
      }

      for (var i = 0, list = tilePoints; i < list.length; i += 1) {
        var point = list[i];

        if (!pointWithinPolygon(point, tilePolygon)) {
          return false;
        }
      }
    }

    if (polygonGeometry.type === 'MultiPolygon') {
      var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
      var tilePoints$1 = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);

      if (!boxWithinBox(pointBBox, polyBBox)) {
        return false;
      }

      for (var i$1 = 0, list$1 = tilePoints$1; i$1 < list$1.length; i$1 += 1) {
        var point$1 = list$1[i$1];

        if (!pointWithinPolygons(point$1, tilePolygons)) {
          return false;
        }
      }
    }

    return true;
  }

  function linesWithinPolygons(ctx, polygonGeometry) {
    var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];
    var canonical = ctx.canonicalID();

    if (!canonical) {
      return false;
    }

    if (polygonGeometry.type === 'Polygon') {
      var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
      var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);

      if (!boxWithinBox(lineBBox, polyBBox)) {
        return false;
      }

      for (var i = 0, list = tileLines; i < list.length; i += 1) {
        var line = list[i];

        if (!lineStringWithinPolygon(line, tilePolygon)) {
          return false;
        }
      }
    }

    if (polygonGeometry.type === 'MultiPolygon') {
      var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
      var tileLines$1 = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);

      if (!boxWithinBox(lineBBox, polyBBox)) {
        return false;
      }

      for (var i$1 = 0, list$1 = tileLines$1; i$1 < list$1.length; i$1 += 1) {
        var line$1 = list$1[i$1];

        if (!lineStringWithinPolygons(line$1, tilePolygons)) {
          return false;
        }
      }
    }

    return true;
  }

  var Within = function Within(geojson, geometries) {
    this.type = BooleanType;
    this.geojson = geojson;
    this.geometries = geometries;
  };

  Within.parse = function parse(args, context) {
    if (args.length !== 2) {
      return context.error("'within' expression requires exactly one argument, but found " + (args.length - 1) + " instead.");
    }

    if (isValue(args[1])) {
      var geojson = args[1];

      if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; ++i) {
          var type = geojson.features[i].geometry.type;

          if (type === 'Polygon' || type === 'MultiPolygon') {
            return new Within(geojson, geojson.features[i].geometry);
          }
        }
      } else if (geojson.type === 'Feature') {
        var type$1 = geojson.geometry.type;

        if (type$1 === 'Polygon' || type$1 === 'MultiPolygon') {
          return new Within(geojson, geojson.geometry);
        }
      } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
        return new Within(geojson, geojson);
      }
    }

    return context.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  };

  Within.prototype.evaluate = function evaluate(ctx) {
    if (ctx.geometry() != null && ctx.canonicalID() != null) {
      if (ctx.geometryType() === 'Point') {
        return pointsWithinPolygons(ctx, this.geometries);
      } else if (ctx.geometryType() === 'LineString') {
        return linesWithinPolygons(ctx, this.geometries);
      }
    }

    return false;
  };

  Within.prototype.eachChild = function eachChild() {};

  Within.prototype.outputDefined = function outputDefined() {
    return true;
  };

  Within.prototype.serialize = function serialize() {
    return ['within', this.geojson];
  }; //      


  function isFeatureConstant(e) {
    if (e instanceof CompoundExpression) {
      if (e.name === 'get' && e.args.length === 1) {
        return false;
      } else if (e.name === 'feature-state') {
        return false;
      } else if (e.name === 'has' && e.args.length === 1) {
        return false;
      } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
        return false;
      } else if (/^filter-/.test(e.name)) {
        return false;
      }
    }

    if (e instanceof Within) {
      return false;
    }

    var result = true;
    e.eachChild(function (arg) {
      if (result && !isFeatureConstant(arg)) {
        result = false;
      }
    });
    return result;
  }

  function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {
      return false;
    }

    var result = true;
    e.eachChild(function (arg) {
      if (result && !isGlobalPropertyConstant(arg, properties)) {
        result = false;
      }
    });
    return result;
  } //      


  var Var = function Var(name, boundExpression) {
    this.type = boundExpression.type;
    this.name = name;
    this.boundExpression = boundExpression;
  };

  Var.parse = function parse(args, context) {
    if (args.length !== 2 || typeof args[1] !== 'string') {
      return context.error("'var' expression requires exactly one string literal argument.");
    }

    var name = args[1];

    if (!context.scope.has(name)) {
      return context.error("Unknown variable \"" + name + "\". Make sure \"" + name + "\" has been bound in an enclosing \"let\" expression before using it.", 1);
    }

    return new Var(name, context.scope.get(name));
  };

  Var.prototype.evaluate = function evaluate(ctx) {
    return this.boundExpression.evaluate(ctx);
  };

  Var.prototype.eachChild = function eachChild() {};

  Var.prototype.outputDefined = function outputDefined() {
    return false;
  };

  Var.prototype.serialize = function serialize() {
    return ['var', this.name];
  }; //      

  /**
   * State associated parsing at a given point in an expression tree.
   * @private
   */


  var ParsingContext = function ParsingContext(registry, path, expectedType, scope, errors) {
    if (path === void 0) path = [];
    if (scope === void 0) scope = new Scope();
    if (errors === void 0) errors = [];
    this.registry = registry;
    this.path = path;
    this.key = path.map(function (part) {
      return "[" + part + "]";
    }).join('');
    this.scope = scope;
    this.errors = errors;
    this.expectedType = expectedType;
  };
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */


  ParsingContext.prototype.parse = function parse(expr, index, expectedType, bindings, options) {
    if (options === void 0) options = {};

    if (index) {
      return this.concat(index, expectedType, bindings)._parse(expr, options);
    }

    return this._parse(expr, options);
  };

  ParsingContext.prototype._parse = function _parse(expr, options) {
    if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
      expr = ['literal', expr];
    }

    function annotate(parsed, type, typeAnnotation) {
      if (typeAnnotation === 'assert') {
        return new Assertion(type, [parsed]);
      } else if (typeAnnotation === 'coerce') {
        return new Coercion(type, [parsed]);
      } else {
        return parsed;
      }
    }

    if (Array.isArray(expr)) {
      if (expr.length === 0) {
        return this.error("Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].");
      }

      var op = expr[0];

      if (typeof op !== 'string') {
        this.error("Expression name must be a string, but found " + _typeof(op) + " instead. If you wanted a literal array, use [\"literal\", [...]].", 0);
        return null;
      }

      var Expr = this.registry[op];

      if (Expr) {
        var parsed = Expr.parse(expr, this);

        if (!parsed) {
          return null;
        }

        if (this.expectedType) {
          var expected = this.expectedType;
          var actual = parsed.type; // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.
          // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.
          // Otherwise, we do static type-checking.
          //
          // These behaviors are overridable for:
          //   * The "coalesce" operator, which needs to omit type annotations.
          //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.
          //

          if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
            parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
          } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
            parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
          } else if (this.checkSubtype(expected, actual)) {
            return null;
          }
        } // If an expression's arguments are all literals, we can evaluate
        // it immediately and replace it with a literal value in the
        // parsed/compiled result. Expressions that expect an image should
        // not be resolved here so we can later get the available images.


        if (!(parsed instanceof Literal) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
          var ec = new EvaluationContext();

          try {
            parsed = new Literal(parsed.type, parsed.evaluate(ec));
          } catch (e) {
            this.error(e.message);
            return null;
          }
        }

        return parsed;
      }

      return this.error("Unknown expression \"" + op + "\". If you wanted a literal array, use [\"literal\", [...]].", 0);
    } else if (typeof expr === 'undefined') {
      return this.error("'undefined' value invalid. Use null instead.");
    } else if (_typeof(expr) === 'object') {
      return this.error("Bare objects invalid. Use [\"literal\", {...}] instead.");
    } else {
      return this.error("Expected an array, but found " + _typeof(expr) + " instead.");
    }
  };
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */


  ParsingContext.prototype.concat = function concat(index, expectedType, bindings) {
    var path = typeof index === 'number' ? this.path.concat(index) : this.path;
    var scope = bindings ? this.scope.concat(bindings) : this.scope;
    return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
  };
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */


  ParsingContext.prototype.error = function error(error$1) {
    var keys = [],
        len = arguments.length - 1;

    while (len-- > 0) {
      keys[len] = arguments[len + 1];
    }

    var key = "" + this.key + keys.map(function (k) {
      return "[" + k + "]";
    }).join('');
    this.errors.push(new ParsingError(key, error$1));
  };
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   */


  ParsingContext.prototype.checkSubtype = function checkSubtype$1(expected, t) {
    var error = checkSubtype(expected, t);

    if (error) {
      this.error(error);
    }

    return error;
  };

  function isConstant(expression) {
    if (expression instanceof Var) {
      return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression && expression.name === 'error') {
      return false;
    } else if (expression instanceof CollatorExpression) {
      // Although the results of a Collator expression with fixed arguments
      // generally shouldn't change between executions, we can't serialize them
      // as constant expressions because results change based on environment.
      return false;
    } else if (expression instanceof Within) {
      return false;
    }

    var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;
    var childrenConstant = true;
    expression.eachChild(function (child) {
      // We can _almost_ assume that if `expressions` children are constant,
      // they would already have been evaluated to Literal values when they
      // were parsed.  Type annotations are the exception, because they might
      // have been inferred and added after a child was parsed.
      // So we recurse into isConstant() for the children of type annotations,
      // but otherwise simply check whether they are Literals.
      if (isTypeAnnotation) {
        childrenConstant = childrenConstant && isConstant(child);
      } else {
        childrenConstant = childrenConstant && child instanceof Literal;
      }
    });

    if (!childrenConstant) {
      return false;
    }

    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'sky-radial-progress', 'accumulated', 'is-supported-script', 'pitch', 'distance-from-center']);
  } //      

  /**
   * Returns the index of the last stop <= input, or 0 if it doesn't exist.
   * @private
   */


  function findStopLessThanOrEqualTo(stops, input) {
    var lastIndex = stops.length - 1;
    var lowerIndex = 0;
    var upperIndex = lastIndex;
    var currentIndex = 0;
    var currentValue, nextValue;

    while (lowerIndex <= upperIndex) {
      currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
      currentValue = stops[currentIndex];
      nextValue = stops[currentIndex + 1];

      if (currentValue <= input) {
        if (currentIndex === lastIndex || input < nextValue) {
          // Search complete
          return currentIndex;
        }

        lowerIndex = currentIndex + 1;
      } else if (currentValue > input) {
        upperIndex = currentIndex - 1;
      } else {
        throw new RuntimeError('Input is not a number.');
      }
    }

    return 0;
  } //      


  var Step = function Step(type, input, stops) {
    this.type = type;
    this.input = input;
    this.labels = [];
    this.outputs = [];

    for (var i = 0, list = stops; i < list.length; i += 1) {
      var ref = list[i];
      var label = ref[0];
      var expression = ref[1];
      this.labels.push(label);
      this.outputs.push(expression);
    }
  };

  Step.parse = function parse(args, context) {
    if (args.length - 1 < 4) {
      return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    }

    if ((args.length - 1) % 2 !== 0) {
      return context.error("Expected an even number of arguments.");
    }

    var input = context.parse(args[1], 1, NumberType);

    if (!input) {
      return null;
    }

    var stops = [];
    var outputType = null;

    if (context.expectedType && context.expectedType.kind !== 'value') {
      outputType = context.expectedType;
    }

    for (var i = 1; i < args.length; i += 2) {
      var label = i === 1 ? -Infinity : args[i];
      var value = args[i + 1];
      var labelKey = i;
      var valueKey = i + 1;

      if (typeof label !== 'number') {
        return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
      }

      if (stops.length && stops[stops.length - 1][0] >= label) {
        return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
      }

      var parsed = context.parse(value, valueKey, outputType);

      if (!parsed) {
        return null;
      }

      outputType = outputType || parsed.type;
      stops.push([label, parsed]);
    }

    return new Step(outputType, input, stops);
  };

  Step.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;

    if (labels.length === 1) {
      return outputs[0].evaluate(ctx);
    }

    var value = this.input.evaluate(ctx);

    if (value <= labels[0]) {
      return outputs[0].evaluate(ctx);
    }

    var stopCount = labels.length;

    if (value >= labels[stopCount - 1]) {
      return outputs[stopCount - 1].evaluate(ctx);
    }

    var index = findStopLessThanOrEqualTo(labels, value);
    return outputs[index].evaluate(ctx);
  };

  Step.prototype.eachChild = function eachChild(fn) {
    fn(this.input);

    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
      var expression = list[i];
      fn(expression);
    }
  };

  Step.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
      return out.outputDefined();
    });
  };

  Step.prototype.serialize = function serialize() {
    var serialized = ['step', this.input.serialize()];

    for (var i = 0; i < this.labels.length; i++) {
      if (i > 0) {
        serialized.push(this.labels[i]);
      }

      serialized.push(this.outputs[i].serialize());
    }

    return serialized;
  };
  /*
   * Copyright (C) 2008 Apple Inc. All Rights Reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
   * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * Ported from Webkit
   * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
   */


  var unitbezier = UnitBezier;

  function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
  }

  UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
  };

  UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
  };

  UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
  };

  UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined') {
      epsilon = 0.000001;
    }

    var t0, t1, t2, x2, i; // First try a few iterations of Newton's method -- normally very fast.

    for (t2 = x, i = 0; i < 8; i++) {
      x2 = this.sampleCurveX(t2) - x;

      if (Math.abs(x2) < epsilon) {
        return t2;
      }

      var d2 = this.sampleCurveDerivativeX(t2);

      if (Math.abs(d2) < 0.000001) {
        break;
      }

      t2 = t2 - x2 / d2;
    } // Fall back to the bisection method for reliability.


    t0 = 0;
    t1 = 1;
    t2 = x;

    if (t2 < t0) {
      return t0;
    }

    if (t2 > t1) {
      return t1;
    }

    while (t0 < t1) {
      x2 = this.sampleCurveX(t2);

      if (Math.abs(x2 - x) < epsilon) {
        return t2;
      }

      if (x > x2) {
        t0 = t2;
      } else {
        t1 = t2;
      }

      t2 = (t1 - t0) * 0.5 + t0;
    } // Failure.


    return t2;
  };

  UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
  }; //      


  function number(a, b, t) {
    return a * (1 - t) + b * t;
  }

  function color(from, to, t) {
    return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
  }

  function array(from, to, t) {
    return from.map(function (d, i) {
      return number(d, to[i], t);
    });
  }

  var interpolate = /*#__PURE__*/Object.freeze({
    __proto__: null,
    number: number,
    color: color,
    array: array
  }); //      
  // Constants

  var Xn = 0.95047,
      // D65 standard referent
  Yn = 1,
      Zn = 1.08883,
      t0 = 4 / 29,
      t1 = 6 / 29,
      t2 = 3 * t1 * t1,
      t3 = t1 * t1 * t1,
      deg2rad$1 = Math.PI / 180,
      rad2deg = 180 / Math.PI; // Utilities

  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
  }

  function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
  }

  function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
  }

  function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
  } // LAB


  function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor.r),
        a = rgb2xyz(rgbColor.g),
        l = rgb2xyz(rgbColor.b),
        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),
        z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
      l: 116 * y - 16,
      a: 500 * (x - y),
      b: 200 * (y - z),
      alpha: rgbColor.a
    };
  }

  function labToRgb(labColor) {
    var y = (labColor.l + 16) / 116,
        x = isNaN(labColor.a) ? y : y + labColor.a / 500,
        z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
  }

  function interpolateLab(from, to, t) {
    return {
      l: number(from.l, to.l, t),
      a: number(from.a, to.a, t),
      b: number(from.b, to.b, t),
      alpha: number(from.alpha, to.alpha, t)
    };
  } // HCL


  function rgbToHcl(rgbColor) {
    var ref = rgbToLab(rgbColor);
    var l = ref.l;
    var a = ref.a;
    var b = ref.b;
    var h = Math.atan2(b, a) * rad2deg;
    return {
      h: h < 0 ? h + 360 : h,
      c: Math.sqrt(a * a + b * b),
      l: l,
      alpha: rgbColor.a
    };
  }

  function hclToRgb(hclColor) {
    var h = hclColor.h * deg2rad$1,
        c = hclColor.c,
        l = hclColor.l;
    return labToRgb({
      l: l,
      a: Math.cos(h) * c,
      b: Math.sin(h) * c,
      alpha: hclColor.alpha
    });
  }

  function interpolateHue(a, b, t) {
    var d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
  }

  function interpolateHcl(from, to, t) {
    return {
      h: interpolateHue(from.h, to.h, t),
      c: number(from.c, to.c, t),
      l: number(from.l, to.l, t),
      alpha: number(from.alpha, to.alpha, t)
    };
  }

  var lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
  };
  var hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
  }; //      

  var Interpolate = function Interpolate(type, operator, interpolation, input, stops) {
    this.type = type;
    this.operator = operator;
    this.interpolation = interpolation;
    this.input = input;
    this.labels = [];
    this.outputs = [];

    for (var i = 0, list = stops; i < list.length; i += 1) {
      var ref = list[i];
      var label = ref[0];
      var expression = ref[1];
      this.labels.push(label);
      this.outputs.push(expression);
    }
  };

  Interpolate.interpolationFactor = function interpolationFactor(interpolation, input, lower, upper) {
    var t = 0;

    if (interpolation.name === 'exponential') {
      t = exponentialInterpolation(input, interpolation.base, lower, upper);
    } else if (interpolation.name === 'linear') {
      t = exponentialInterpolation(input, 1, lower, upper);
    } else if (interpolation.name === 'cubic-bezier') {
      var c = interpolation.controlPoints;
      var ub = new unitbezier(c[0], c[1], c[2], c[3]);
      t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
    }

    return t;
  };

  Interpolate.parse = function parse(args, context) {
    var operator = args[0];
    var interpolation = args[1];
    var input = args[2];
    var rest = args.slice(3);

    if (!Array.isArray(interpolation) || interpolation.length === 0) {
      return context.error("Expected an interpolation type expression.", 1);
    }

    if (interpolation[0] === 'linear') {
      interpolation = {
        name: 'linear'
      };
    } else if (interpolation[0] === 'exponential') {
      var base = interpolation[1];

      if (typeof base !== 'number') {
        return context.error("Exponential interpolation requires a numeric base.", 1, 1);
      }

      interpolation = {
        name: 'exponential',
        base: base
      };
    } else if (interpolation[0] === 'cubic-bezier') {
      var controlPoints = interpolation.slice(1);

      if (controlPoints.length !== 4 || controlPoints.some(function (t) {
        return typeof t !== 'number' || t < 0 || t > 1;
      })) {
        return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
      }

      interpolation = {
        name: 'cubic-bezier',
        controlPoints: controlPoints
      };
    } else {
      return context.error("Unknown interpolation type " + String(interpolation[0]), 1, 0);
    }

    if (args.length - 1 < 4) {
      return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    }

    if ((args.length - 1) % 2 !== 0) {
      return context.error("Expected an even number of arguments.");
    }

    input = context.parse(input, 2, NumberType);

    if (!input) {
      return null;
    }

    var stops = [];
    var outputType = null;

    if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
      outputType = ColorType;
    } else if (context.expectedType && context.expectedType.kind !== 'value') {
      outputType = context.expectedType;
    }

    for (var i = 0; i < rest.length; i += 2) {
      var label = rest[i];
      var value = rest[i + 1];
      var labelKey = i + 3;
      var valueKey = i + 4;

      if (typeof label !== 'number') {
        return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
      }

      if (stops.length && stops[stops.length - 1][0] >= label) {
        return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
      }

      var parsed = context.parse(value, valueKey, outputType);

      if (!parsed) {
        return null;
      }

      outputType = outputType || parsed.type;
      stops.push([label, parsed]);
    }

    if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
      return context.error("Type " + toString$1(outputType) + " is not interpolatable.");
    }

    return new Interpolate(outputType, operator, interpolation, input, stops);
  };

  Interpolate.prototype.evaluate = function evaluate(ctx) {
    var labels = this.labels;
    var outputs = this.outputs;

    if (labels.length === 1) {
      return outputs[0].evaluate(ctx);
    }

    var value = this.input.evaluate(ctx);

    if (value <= labels[0]) {
      return outputs[0].evaluate(ctx);
    }

    var stopCount = labels.length;

    if (value >= labels[stopCount - 1]) {
      return outputs[stopCount - 1].evaluate(ctx);
    }

    var index = findStopLessThanOrEqualTo(labels, value);
    var lower = labels[index];
    var upper = labels[index + 1];
    var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
    var outputLower = outputs[index].evaluate(ctx);
    var outputUpper = outputs[index + 1].evaluate(ctx);

    if (this.operator === 'interpolate') {
      return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t); // eslint-disable-line import/namespace
    } else if (this.operator === 'interpolate-hcl') {
      return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
    } else {
      return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
    }
  };

  Interpolate.prototype.eachChild = function eachChild(fn) {
    fn(this.input);

    for (var i = 0, list = this.outputs; i < list.length; i += 1) {
      var expression = list[i];
      fn(expression);
    }
  };

  Interpolate.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
      return out.outputDefined();
    });
  };

  Interpolate.prototype.serialize = function serialize() {
    var interpolation;

    if (this.interpolation.name === 'linear') {
      interpolation = ['linear'];
    } else if (this.interpolation.name === 'exponential') {
      if (this.interpolation.base === 1) {
        interpolation = ['linear'];
      } else {
        interpolation = ['exponential', this.interpolation.base];
      }
    } else {
      interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
    }

    var serialized = [this.operator, interpolation, this.input.serialize()];

    for (var i = 0; i < this.labels.length; i++) {
      serialized.push(this.labels[i], this.outputs[i].serialize());
    }

    return serialized;
  };
  /**
   * Returns a ratio that can be used to interpolate between exponential function
   * stops.
   * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,
   * and `a` and `b` are constants affording sufficient degrees of freedom to fit
   * the function to the given stops.
   *
   * Here's a bit of algebra that lets us compute `f(x)` directly from the stop
   * values without explicitly solving for `a` and `b`:
   *
   * First stop value: `f(x0) = y0 = a * base^x0 + b`
   * Second stop value: `f(x1) = y1 = a * base^x1 + b`
   * => `y1 - y0 = a(base^x1 - base^x0)`
   * => `a = (y1 - y0)/(base^x1 - base^x0)`
   *
   * Desired value: `f(x) = y = a * base^x + b`
   * => `f(x) = y0 + a * (base^x - base^x0)`
   *
   * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a
   * little algebra:
   * ```
   * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)
   *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)
   * ```
   *
   * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have
   * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as
   * an interpolation factor between the two stops' output values.
   *
   * (Note: a slightly different form for `ratio`,
   * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer
   * expensive `Math.pow()` operations.)
   *
   * @private
  */


  function exponentialInterpolation(input, base, lowerValue, upperValue) {
    var difference = upperValue - lowerValue;
    var progress = input - lowerValue;

    if (difference === 0) {
      return 0;
    } else if (base === 1) {
      return progress / difference;
    } else {
      return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
  }

  var Coalesce = function Coalesce(type, args) {
    this.type = type;
    this.args = args;
  };

  Coalesce.parse = function parse(args, context) {
    if (args.length < 2) {
      return context.error('Expectected at least one argument.');
    }

    var outputType = null;
    var expectedType = context.expectedType;

    if (expectedType && expectedType.kind !== 'value') {
      outputType = expectedType;
    }

    var parsedArgs = [];

    for (var i = 0, list = args.slice(1); i < list.length; i += 1) {
      var arg = list[i];
      var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {
        typeAnnotation: 'omit'
      });

      if (!parsed) {
        return null;
      }

      outputType = outputType || parsed.type;
      parsedArgs.push(parsed);
    } // Above, we parse arguments without inferred type annotation so that
    // they don't produce a runtime error for `null` input, which would
    // preempt the desired null-coalescing behavior.
    // Thus, if any of our arguments would have needed an annotation, we
    // need to wrap the enclosing coalesce expression with it instead.


    var needsAnnotation = expectedType && parsedArgs.some(function (arg) {
      return checkSubtype(expectedType, arg.type);
    });
    return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
  };

  Coalesce.prototype.evaluate = function evaluate(ctx) {
    var result = null;
    var argCount = 0;
    var firstImage;

    for (var i = 0, list = this.args; i < list.length; i += 1) {
      var arg = list[i];
      argCount++;
      result = arg.evaluate(ctx); // we need to keep track of the first requested image in a coalesce statement
      // if coalesce can't find a valid image, we return the first image so styleimagemissing can fire

      if (result && result instanceof ResolvedImage && !result.available) {
        // set to first image
        if (!firstImage) {
          firstImage = result;
        }

        result = null; // if we reach the end, return the first image

        if (argCount === this.args.length) {
          return firstImage;
        }
      }

      if (result !== null) {
        break;
      }
    }

    return result;
  };

  Coalesce.prototype.eachChild = function eachChild(fn) {
    this.args.forEach(fn);
  };

  Coalesce.prototype.outputDefined = function outputDefined() {
    return this.args.every(function (arg) {
      return arg.outputDefined();
    });
  };

  Coalesce.prototype.serialize = function serialize() {
    var serialized = ['coalesce'];
    this.eachChild(function (child) {
      serialized.push(child.serialize());
    });
    return serialized;
  }; //      


  var Let = function Let(bindings, result) {
    this.type = result.type;
    this.bindings = [].concat(bindings);
    this.result = result;
  };

  Let.prototype.evaluate = function evaluate(ctx) {
    return this.result.evaluate(ctx);
  };

  Let.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
      var binding = list[i];
      fn(binding[1]);
    }

    fn(this.result);
  };

  Let.parse = function parse(args, context) {
    if (args.length < 4) {
      return context.error("Expected at least 3 arguments, but found " + (args.length - 1) + " instead.");
    }

    var bindings = [];

    for (var i = 1; i < args.length - 1; i += 2) {
      var name = args[i];

      if (typeof name !== 'string') {
        return context.error("Expected string, but found " + _typeof(name) + " instead.", i);
      }

      if (/[^a-zA-Z0-9_]/.test(name)) {
        return context.error("Variable names must contain only alphanumeric characters or '_'.", i);
      }

      var value = context.parse(args[i + 1], i + 1);

      if (!value) {
        return null;
      }

      bindings.push([name, value]);
    }

    var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);

    if (!result) {
      return null;
    }

    return new Let(bindings, result);
  };

  Let.prototype.outputDefined = function outputDefined() {
    return this.result.outputDefined();
  };

  Let.prototype.serialize = function serialize() {
    var serialized = ['let'];

    for (var i = 0, list = this.bindings; i < list.length; i += 1) {
      var ref = list[i];
      var name = ref[0];
      var expr = ref[1];
      serialized.push(name, expr.serialize());
    }

    serialized.push(this.result.serialize());
    return serialized;
  }; //      


  var At = function At(type, index, input) {
    this.type = type;
    this.index = index;
    this.input = input;
  };

  At.parse = function parse(args, context) {
    if (args.length !== 3) {
      return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
    }

    var index = context.parse(args[1], 1, NumberType);
    var input = context.parse(args[2], 2, array$1(context.expectedType || ValueType));

    if (!index || !input) {
      return null;
    }

    var t = input.type;
    return new At(t.itemType, index, input);
  };

  At.prototype.evaluate = function evaluate(ctx) {
    var index = this.index.evaluate(ctx);
    var array = this.input.evaluate(ctx);

    if (index < 0) {
      throw new RuntimeError("Array index out of bounds: " + index + " < 0.");
    }

    if (index >= array.length) {
      throw new RuntimeError("Array index out of bounds: " + index + " > " + (array.length - 1) + ".");
    }

    if (index !== Math.floor(index)) {
      throw new RuntimeError("Array index must be an integer, but found " + index + " instead.");
    }

    return array[index];
  };

  At.prototype.eachChild = function eachChild(fn) {
    fn(this.index);
    fn(this.input);
  };

  At.prototype.outputDefined = function outputDefined() {
    return false;
  };

  At.prototype.serialize = function serialize() {
    return ['at', this.index.serialize(), this.input.serialize()];
  }; //      


  var In = function In(needle, haystack) {
    this.type = BooleanType;
    this.needle = needle;
    this.haystack = haystack;
  };

  In.parse = function parse(args, context) {
    if (args.length !== 3) {
      return context.error("Expected 2 arguments, but found " + (args.length - 1) + " instead.");
    }

    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);

    if (!needle || !haystack) {
      return null;
    }

    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
      return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(needle.type) + " instead");
    }

    return new In(needle, haystack);
  };

  In.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);

    if (haystack == null) {
      return false;
    }

    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
      throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(typeOf(needle)) + " instead.");
    }

    if (!isValidNativeType(haystack, ['string', 'array'])) {
      throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString$1(typeOf(haystack)) + " instead.");
    }

    return haystack.indexOf(needle) >= 0;
  };

  In.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);
  };

  In.prototype.outputDefined = function outputDefined() {
    return true;
  };

  In.prototype.serialize = function serialize() {
    return ['in', this.needle.serialize(), this.haystack.serialize()];
  }; //      


  var IndexOf = function IndexOf(needle, haystack, fromIndex) {
    this.type = NumberType;
    this.needle = needle;
    this.haystack = haystack;
    this.fromIndex = fromIndex;
  };

  IndexOf.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
      return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
    }

    var needle = context.parse(args[1], 1, ValueType);
    var haystack = context.parse(args[2], 2, ValueType);

    if (!needle || !haystack) {
      return null;
    }

    if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {
      return context.error("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(needle.type) + " instead");
    }

    if (args.length === 4) {
      var fromIndex = context.parse(args[3], 3, NumberType);

      if (!fromIndex) {
        return null;
      }

      return new IndexOf(needle, haystack, fromIndex);
    } else {
      return new IndexOf(needle, haystack);
    }
  };

  IndexOf.prototype.evaluate = function evaluate(ctx) {
    var needle = this.needle.evaluate(ctx);
    var haystack = this.haystack.evaluate(ctx);

    if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {
      throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found " + toString$1(typeOf(needle)) + " instead.");
    }

    if (!isValidNativeType(haystack, ['string', 'array'])) {
      throw new RuntimeError("Expected second argument to be of type array or string, but found " + toString$1(typeOf(haystack)) + " instead.");
    }

    if (this.fromIndex) {
      var fromIndex = this.fromIndex.evaluate(ctx);
      return haystack.indexOf(needle, fromIndex);
    }

    return haystack.indexOf(needle);
  };

  IndexOf.prototype.eachChild = function eachChild(fn) {
    fn(this.needle);
    fn(this.haystack);

    if (this.fromIndex) {
      fn(this.fromIndex);
    }
  };

  IndexOf.prototype.outputDefined = function outputDefined() {
    return false;
  };

  IndexOf.prototype.serialize = function serialize() {
    if (this.fromIndex != null && this.fromIndex !== undefined) {
      var fromIndex = this.fromIndex.serialize();
      return ['index-of', this.needle.serialize(), this.haystack.serialize(), fromIndex];
    }

    return ['index-of', this.needle.serialize(), this.haystack.serialize()];
  }; // Map input label values to output expression index


  var Match = function Match(inputType, outputType, input, cases, outputs, otherwise) {
    this.inputType = inputType;
    this.type = outputType;
    this.input = input;
    this.cases = cases;
    this.outputs = outputs;
    this.otherwise = otherwise;
  };

  Match.parse = function parse(args, context) {
    if (args.length < 5) {
      return context.error("Expected at least 4 arguments, but found only " + (args.length - 1) + ".");
    }

    if (args.length % 2 !== 1) {
      return context.error("Expected an even number of arguments.");
    }

    var inputType;
    var outputType;

    if (context.expectedType && context.expectedType.kind !== 'value') {
      outputType = context.expectedType;
    }

    var cases = {};
    var outputs = [];

    for (var i = 2; i < args.length - 1; i += 2) {
      var labels = args[i];
      var value = args[i + 1];

      if (!Array.isArray(labels)) {
        labels = [labels];
      }

      var labelContext = context.concat(i);

      if (labels.length === 0) {
        return labelContext.error('Expected at least one branch label.');
      }

      for (var i$1 = 0, list = labels; i$1 < list.length; i$1 += 1) {
        var label = list[i$1];

        if (typeof label !== 'number' && typeof label !== 'string') {
          return labelContext.error("Branch labels must be numbers or strings.");
        } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
          return labelContext.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
        } else if (typeof label === 'number' && Math.floor(label) !== label) {
          return labelContext.error("Numeric branch labels must be integer values.");
        } else if (!inputType) {
          inputType = typeOf(label);
        } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
          return null;
        }

        if (typeof cases[String(label)] !== 'undefined') {
          return labelContext.error('Branch labels must be unique.');
        }

        cases[String(label)] = outputs.length;
      }

      var result = context.parse(value, i, outputType);

      if (!result) {
        return null;
      }

      outputType = outputType || result.type;
      outputs.push(result);
    }

    var input = context.parse(args[1], 1, ValueType);

    if (!input) {
      return null;
    }

    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);

    if (!otherwise) {
      return null;
    }

    if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
      return null;
    }

    return new Match(inputType, outputType, input, cases, outputs, otherwise);
  };

  Match.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
    return output.evaluate(ctx);
  };

  Match.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    this.outputs.forEach(fn);
    fn(this.otherwise);
  };

  Match.prototype.outputDefined = function outputDefined() {
    return this.outputs.every(function (out) {
      return out.outputDefined();
    }) && this.otherwise.outputDefined();
  };

  Match.prototype.serialize = function serialize() {
    var this$1$1 = this;
    var serialized = ['match', this.input.serialize()]; // Sort so serialization has an arbitrary defined order, even though
    // branch order doesn't affect evaluation

    var sortedLabels = Object.keys(this.cases).sort(); // Group branches by unique match expression to support condensed
    // serializations of the form [case1, case2, ...] -> matchExpression

    var groupedByOutput = [];
    var outputLookup = {}; // lookup index into groupedByOutput for a given output expression

    for (var i = 0, list = sortedLabels; i < list.length; i += 1) {
      var label = list[i];
      var outputIndex = outputLookup[this.cases[label]];

      if (outputIndex === undefined) {
        // First time seeing this output, add it to the end of the grouped list
        outputLookup[this.cases[label]] = groupedByOutput.length;
        groupedByOutput.push([this.cases[label], [label]]);
      } else {
        // We've seen this expression before, add the label to that output's group
        groupedByOutput[outputIndex][1].push(label);
      }
    }

    var coerceLabel = function coerceLabel(label) {
      return this$1$1.inputType.kind === 'number' ? Number(label) : label;
    };

    for (var i$1 = 0, list$1 = groupedByOutput; i$1 < list$1.length; i$1 += 1) {
      var ref = list$1[i$1];
      var outputIndex = ref[0];
      var labels = ref[1];

      if (labels.length === 1) {
        // Only a single label matches this output expression
        serialized.push(coerceLabel(labels[0]));
      } else {
        // Array of literal labels pointing to this output expression
        serialized.push(labels.map(coerceLabel));
      }

      serialized.push(this.outputs[outputIndex$1].serialize());
    }

    serialized.push(this.otherwise.serialize());
    return serialized;
  };

  var Case = function Case(type, branches, otherwise) {
    this.type = type;
    this.branches = branches;
    this.otherwise = otherwise;
  };

  Case.parse = function parse(args, context) {
    if (args.length < 4) {
      return context.error("Expected at least 3 arguments, but found only " + (args.length - 1) + ".");
    }

    if (args.length % 2 !== 0) {
      return context.error("Expected an odd number of arguments.");
    }

    var outputType;

    if (context.expectedType && context.expectedType.kind !== 'value') {
      outputType = context.expectedType;
    }

    var branches = [];

    for (var i = 1; i < args.length - 1; i += 2) {
      var test = context.parse(args[i], i, BooleanType);

      if (!test) {
        return null;
      }

      var result = context.parse(args[i + 1], i + 1, outputType);

      if (!result) {
        return null;
      }

      branches.push([test, result]);
      outputType = outputType || result.type;
    }

    var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);

    if (!otherwise) {
      return null;
    }

    return new Case(outputType, branches, otherwise);
  };

  Case.prototype.evaluate = function evaluate(ctx) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
      var ref = list[i];
      var test = ref[0];
      var expression = ref[1];

      if (test.evaluate(ctx)) {
        return expression.evaluate(ctx);
      }
    }

    return this.otherwise.evaluate(ctx);
  };

  Case.prototype.eachChild = function eachChild(fn) {
    for (var i = 0, list = this.branches; i < list.length; i += 1) {
      var ref = list[i];
      var test = ref[0];
      var expression = ref[1];
      fn(test);
      fn(expression);
    }

    fn(this.otherwise);
  };

  Case.prototype.outputDefined = function outputDefined() {
    return this.branches.every(function (ref) {
      ref[0];
      var out = ref[1];
      return out.outputDefined();
    }) && this.otherwise.outputDefined();
  };

  Case.prototype.serialize = function serialize() {
    var serialized = ['case'];
    this.eachChild(function (child) {
      serialized.push(child.serialize());
    });
    return serialized;
  }; //      


  var Slice = function Slice(type, input, beginIndex, endIndex) {
    this.type = type;
    this.input = input;
    this.beginIndex = beginIndex;
    this.endIndex = endIndex;
  };

  Slice.parse = function parse(args, context) {
    if (args.length <= 2 || args.length >= 5) {
      return context.error("Expected 3 or 4 arguments, but found " + (args.length - 1) + " instead.");
    }

    var input = context.parse(args[1], 1, ValueType);
    var beginIndex = context.parse(args[2], 2, NumberType);

    if (!input || !beginIndex) {
      return null;
    }

    if (!isValidType(input.type, [array$1(ValueType), StringType, ValueType])) {
      return context.error("Expected first argument to be of type array or string, but found " + toString$1(input.type) + " instead");
    }

    if (args.length === 4) {
      var endIndex = context.parse(args[3], 3, NumberType);

      if (!endIndex) {
        return null;
      }

      return new Slice(input.type, input, beginIndex, endIndex);
    } else {
      return new Slice(input.type, input, beginIndex);
    }
  };

  Slice.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);
    var beginIndex = this.beginIndex.evaluate(ctx);

    if (!isValidNativeType(input, ['string', 'array'])) {
      throw new RuntimeError("Expected first argument to be of type array or string, but found " + toString$1(typeOf(input)) + " instead.");
    }

    if (this.endIndex) {
      var endIndex = this.endIndex.evaluate(ctx);
      return input.slice(beginIndex, endIndex);
    }

    return input.slice(beginIndex);
  };

  Slice.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
    fn(this.beginIndex);

    if (this.endIndex) {
      fn(this.endIndex);
    }
  };

  Slice.prototype.outputDefined = function outputDefined() {
    return false;
  };

  Slice.prototype.serialize = function serialize() {
    if (this.endIndex != null && this.endIndex !== undefined) {
      var endIndex = this.endIndex.serialize();
      return ['slice', this.input.serialize(), this.beginIndex.serialize(), endIndex];
    }

    return ['slice', this.input.serialize(), this.beginIndex.serialize()];
  }; //      


  function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
      // equality operator
      return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
      // ordering operator
      return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
  }

  function eq(ctx, a, b) {
    return a === b;
  }

  function neq(ctx, a, b) {
    return a !== b;
  }

  function lt(ctx, a, b) {
    return a < b;
  }

  function gt(ctx, a, b) {
    return a > b;
  }

  function lteq(ctx, a, b) {
    return a <= b;
  }

  function gteq(ctx, a, b) {
    return a >= b;
  }

  function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
  }

  function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
  }

  function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
  }

  function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
  }

  function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
  }

  function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
  }
  /**
   * Special form for comparison operators, implementing the signatures:
   * - (T, T, ?Collator) => boolean
   * - (T, value, ?Collator) => boolean
   * - (value, T, ?Collator) => boolean
   *
   * For inequalities, T must be either value, string, or number. For ==/!=, it
   * can also be boolean or null.
   *
   * Equality semantics are equivalent to Javascript's strict equality (===/!==)
   * -- i.e., when the arguments' types don't match, == evaluates to false, != to
   * true.
   *
   * When types don't match in an ordering comparison, a runtime error is thrown.
   *
   * @private
   */


  function makeComparison(op, compareBasic, compareWithCollator) {
    var isOrderComparison = op !== '==' && op !== '!=';
    return /*@__PURE__*/function () {
      function Comparison(lhs, rhs, collator) {
        this.type = BooleanType;
        this.lhs = lhs;
        this.rhs = rhs;
        this.collator = collator;
        this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
      }

      Comparison.parse = function parse(args, context) {
        if (args.length !== 3 && args.length !== 4) {
          return context.error("Expected two or three arguments.");
        }

        var op = args[0];
        var lhs = context.parse(args[1], 1, ValueType);

        if (!lhs) {
          return null;
        }

        if (!isComparableType(op, lhs.type)) {
          return context.concat(1).error("\"" + op + "\" comparisons are not supported for type '" + toString$1(lhs.type) + "'.");
        }

        var rhs = context.parse(args[2], 2, ValueType);

        if (!rhs) {
          return null;
        }

        if (!isComparableType(op, rhs.type)) {
          return context.concat(2).error("\"" + op + "\" comparisons are not supported for type '" + toString$1(rhs.type) + "'.");
        }

        if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
          return context.error("Cannot compare types '" + toString$1(lhs.type) + "' and '" + toString$1(rhs.type) + "'.");
        }

        if (isOrderComparison) {
          // typing rules specific to less/greater than operators
          if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
            // (value, T)
            lhs = new Assertion(rhs.type, [lhs]);
          } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
            // (T, value)
            rhs = new Assertion(lhs.type, [rhs]);
          }
        }

        var collator = null;

        if (args.length === 4) {
          if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
            return context.error("Cannot use collator to compare non-string types.");
          }

          collator = context.parse(args[3], 3, CollatorType);

          if (!collator) {
            return null;
          }
        }

        return new Comparison(lhs, rhs, collator);
      };

      Comparison.prototype.evaluate = function evaluate(ctx) {
        var lhs = this.lhs.evaluate(ctx);
        var rhs = this.rhs.evaluate(ctx);

        if (isOrderComparison && this.hasUntypedArgument) {
          var lt = typeOf(lhs);
          var rt = typeOf(rhs); // check that type is string or number, and equal

          if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
            throw new RuntimeError("Expected arguments for \"" + op + "\" to be (string, string) or (number, number), but found (" + lt.kind + ", " + rt.kind + ") instead.");
          }
        }

        if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
          var lt$1 = typeOf(lhs);
          var rt$1 = typeOf(rhs);

          if (lt$1.kind !== 'string' || rt$1.kind !== 'string') {
            return compareBasic(ctx, lhs, rhs);
          }
        }

        return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
      };

      Comparison.prototype.eachChild = function eachChild(fn) {
        fn(this.lhs);
        fn(this.rhs);

        if (this.collator) {
          fn(this.collator);
        }
      };

      Comparison.prototype.outputDefined = function outputDefined() {
        return true;
      };

      Comparison.prototype.serialize = function serialize() {
        var serialized = [op];
        this.eachChild(function (child) {
          serialized.push(child.serialize());
        });
        return serialized;
      };

      return Comparison;
    }();
  }

  var Equals = makeComparison('==', eq, eqCollate);
  var NotEquals = makeComparison('!=', neq, neqCollate);
  var LessThan = makeComparison('<', lt, ltCollate);
  var GreaterThan = makeComparison('>', gt, gtCollate);
  var LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
  var GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate); //      

  var NumberFormat = function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {
    this.type = StringType;
    this.number = number;
    this.locale = locale;
    this.currency = currency;
    this.minFractionDigits = minFractionDigits;
    this.maxFractionDigits = maxFractionDigits;
  };

  NumberFormat.parse = function parse(args, context) {
    if (args.length !== 3) {
      return context.error("Expected two arguments.");
    }

    var number = context.parse(args[1], 1, NumberType);

    if (!number) {
      return null;
    }

    var options = args[2];

    if (_typeof(options) !== 'object' || Array.isArray(options)) {
      return context.error("NumberFormat options argument must be an object.");
    }

    var locale = null;

    if (options['locale']) {
      locale = context.parse(options['locale'], 1, StringType);

      if (!locale) {
        return null;
      }
    }

    var currency = null;

    if (options['currency']) {
      currency = context.parse(options['currency'], 1, StringType);

      if (!currency) {
        return null;
      }
    }

    var minFractionDigits = null;

    if (options['min-fraction-digits']) {
      minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);

      if (!minFractionDigits) {
        return null;
      }
    }

    var maxFractionDigits = null;

    if (options['max-fraction-digits']) {
      maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);

      if (!maxFractionDigits) {
        return null;
      }
    }

    return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);
  };

  NumberFormat.prototype.evaluate = function evaluate(ctx) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
      style: this.currency ? 'currency' : 'decimal',
      currency: this.currency ? this.currency.evaluate(ctx) : undefined,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
    }).format(this.number.evaluate(ctx));
  };

  NumberFormat.prototype.eachChild = function eachChild(fn) {
    fn(this.number);

    if (this.locale) {
      fn(this.locale);
    }

    if (this.currency) {
      fn(this.currency);
    }

    if (this.minFractionDigits) {
      fn(this.minFractionDigits);
    }

    if (this.maxFractionDigits) {
      fn(this.maxFractionDigits);
    }
  };

  NumberFormat.prototype.outputDefined = function outputDefined() {
    return false;
  };

  NumberFormat.prototype.serialize = function serialize() {
    var options = {};

    if (this.locale) {
      options['locale'] = this.locale.serialize();
    }

    if (this.currency) {
      options['currency'] = this.currency.serialize();
    }

    if (this.minFractionDigits) {
      options['min-fraction-digits'] = this.minFractionDigits.serialize();
    }

    if (this.maxFractionDigits) {
      options['max-fraction-digits'] = this.maxFractionDigits.serialize();
    }

    return ['number-format', this.number.serialize(), options];
  }; //      


  var Length = function Length(input) {
    this.type = NumberType;
    this.input = input;
  };

  Length.parse = function parse(args, context) {
    if (args.length !== 2) {
      return context.error("Expected 1 argument, but found " + (args.length - 1) + " instead.");
    }

    var input = context.parse(args[1], 1);

    if (!input) {
      return null;
    }

    if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value') {
      return context.error("Expected argument of type string or array, but found " + toString$1(input.type) + " instead.");
    }

    return new Length(input);
  };

  Length.prototype.evaluate = function evaluate(ctx) {
    var input = this.input.evaluate(ctx);

    if (typeof input === 'string') {
      return input.length;
    } else if (Array.isArray(input)) {
      return input.length;
    } else {
      throw new RuntimeError("Expected value to be of type string or array, but found " + toString$1(typeOf(input)) + " instead.");
    }
  };

  Length.prototype.eachChild = function eachChild(fn) {
    fn(this.input);
  };

  Length.prototype.outputDefined = function outputDefined() {
    return false;
  };

  Length.prototype.serialize = function serialize() {
    var serialized = ['length'];
    this.eachChild(function (child) {
      serialized.push(child.serialize());
    });
    return serialized;
  }; //      


  var expressions = {
    // special forms
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion,
    'at': At,
    'boolean': Assertion,
    'case': Case,
    'coalesce': Coalesce,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In,
    'index-of': IndexOf,
    'interpolate': Interpolate,
    'interpolate-hcl': Interpolate,
    'interpolate-lab': Interpolate,
    'length': Length,
    'let': Let,
    'literal': Literal,
    'match': Match,
    'number': Assertion,
    'number-format': NumberFormat,
    'object': Assertion,
    'slice': Slice,
    'step': Step,
    'string': Assertion,
    'to-boolean': Coercion,
    'to-color': Coercion,
    'to-number': Coercion,
    'to-string': Coercion,
    'var': Var,
    'within': Within
  };

  function rgba(ctx, ref) {
    var r = ref[0];
    var g = ref[1];
    var b = ref[2];
    var a = ref[3];
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    var alpha = a ? a.evaluate(ctx) : 1;
    var error = validateRGBA(r, g, b, alpha);

    if (error) {
      throw new RuntimeError(error);
    }

    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
  }

  function has(key, obj) {
    return key in obj;
  }

  function get(key, obj) {
    var v = obj[key];
    return typeof v === 'undefined' ? null : v;
  }

  function binarySearch(v, a, i, j) {
    while (i <= j) {
      var m = i + j >> 1;

      if (a[m] === v) {
        return true;
      }

      if (a[m] > v) {
        j = m - 1;
      } else {
        i = m + 1;
      }
    }

    return false;
  }

  function varargs(type) {
    return {
      type: type
    };
  }

  CompoundExpression.register(expressions, {
    'error': [ErrorType, [StringType], function (ctx, ref) {
      var v = ref[0];
      throw new RuntimeError(v.evaluate(ctx));
    }],
    'typeof': [StringType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      return toString$1(typeOf(v.evaluate(ctx)));
    }],
    'to-rgba': [array$1(NumberType, 4), [ColorType], function (ctx, ref) {
      var v = ref[0];
      return v.evaluate(ctx).toArray();
    }],
    'rgb': [ColorType, [NumberType, NumberType, NumberType], rgba],
    'rgba': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],
    'has': {
      type: BooleanType,
      overloads: [[[StringType], function (ctx, ref) {
        var key = ref[0];
        return has(key.evaluate(ctx), ctx.properties());
      }], [[StringType, ObjectType], function (ctx, ref) {
        var key = ref[0];
        var obj = ref[1];
        return has(key.evaluate(ctx), obj.evaluate(ctx));
      }]]
    },
    'get': {
      type: ValueType,
      overloads: [[[StringType], function (ctx, ref) {
        var key = ref[0];
        return get(key.evaluate(ctx), ctx.properties());
      }], [[StringType, ObjectType], function (ctx, ref) {
        var key = ref[0];
        var obj = ref[1];
        return get(key.evaluate(ctx), obj.evaluate(ctx));
      }]]
    },
    'feature-state': [ValueType, [StringType], function (ctx, ref) {
      var key = ref[0];
      return get(key.evaluate(ctx), ctx.featureState || {});
    }],
    'properties': [ObjectType, [], function (ctx) {
      return ctx.properties();
    }],
    'geometry-type': [StringType, [], function (ctx) {
      return ctx.geometryType();
    }],
    'id': [ValueType, [], function (ctx) {
      return ctx.id();
    }],
    'zoom': [NumberType, [], function (ctx) {
      return ctx.globals.zoom;
    }],
    'pitch': [NumberType, [], function (ctx) {
      return ctx.globals.pitch || 0;
    }],
    'distance-from-center': [NumberType, [], function (ctx) {
      return ctx.distanceFromCenter();
    }],
    'heatmap-density': [NumberType, [], function (ctx) {
      return ctx.globals.heatmapDensity || 0;
    }],
    'line-progress': [NumberType, [], function (ctx) {
      return ctx.globals.lineProgress || 0;
    }],
    'sky-radial-progress': [NumberType, [], function (ctx) {
      return ctx.globals.skyRadialProgress || 0;
    }],
    'accumulated': [ValueType, [], function (ctx) {
      return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;
    }],
    '+': [NumberType, varargs(NumberType), function (ctx, args) {
      var result = 0;

      for (var i = 0, list = args; i < list.length; i += 1) {
        var arg = list[i];
        result += arg.evaluate(ctx);
      }

      return result;
    }],
    '*': [NumberType, varargs(NumberType), function (ctx, args) {
      var result = 1;

      for (var i = 0, list = args; i < list.length; i += 1) {
        var arg = list[i];
        result *= arg.evaluate(ctx);
      }

      return result;
    }],
    '-': {
      type: NumberType,
      overloads: [[[NumberType, NumberType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) - b.evaluate(ctx);
      }], [[NumberType], function (ctx, ref) {
        var a = ref[0];
        return -a.evaluate(ctx);
      }]]
    },
    '/': [NumberType, [NumberType, NumberType], function (ctx, ref) {
      var a = ref[0];
      var b = ref[1];
      return a.evaluate(ctx) / b.evaluate(ctx);
    }],
    '%': [NumberType, [NumberType, NumberType], function (ctx, ref) {
      var a = ref[0];
      var b = ref[1];
      return a.evaluate(ctx) % b.evaluate(ctx);
    }],
    'ln2': [NumberType, [], function () {
      return Math.LN2;
    }],
    'pi': [NumberType, [], function () {
      return Math.PI;
    }],
    'e': [NumberType, [], function () {
      return Math.E;
    }],
    '^': [NumberType, [NumberType, NumberType], function (ctx, ref) {
      var b = ref[0];
      var e = ref[1];
      return Math.pow(b.evaluate(ctx), e.evaluate(ctx));
    }],
    'sqrt': [NumberType, [NumberType], function (ctx, ref) {
      var x = ref[0];
      return Math.sqrt(x.evaluate(ctx));
    }],
    'log10': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.log(n.evaluate(ctx)) / Math.LN10;
    }],
    'ln': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.log(n.evaluate(ctx));
    }],
    'log2': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.log(n.evaluate(ctx)) / Math.LN2;
    }],
    'sin': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.sin(n.evaluate(ctx));
    }],
    'cos': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.cos(n.evaluate(ctx));
    }],
    'tan': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.tan(n.evaluate(ctx));
    }],
    'asin': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.asin(n.evaluate(ctx));
    }],
    'acos': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.acos(n.evaluate(ctx));
    }],
    'atan': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.atan(n.evaluate(ctx));
    }],
    'min': [NumberType, varargs(NumberType), function (ctx, args) {
      return Math.min.apply(Math, args.map(function (arg) {
        return arg.evaluate(ctx);
      }));
    }],
    'max': [NumberType, varargs(NumberType), function (ctx, args) {
      return Math.max.apply(Math, args.map(function (arg) {
        return arg.evaluate(ctx);
      }));
    }],
    'abs': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.abs(n.evaluate(ctx));
    }],
    'round': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      var v = n.evaluate(ctx); // Javascript's Math.round() rounds towards +Infinity for halfway
      // values, even when they're negative. It's more common to round
      // away from 0 (e.g., this is what python and C++ do)

      return v < 0 ? -Math.round(-v) : Math.round(v);
    }],
    'floor': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.floor(n.evaluate(ctx));
    }],
    'ceil': [NumberType, [NumberType], function (ctx, ref) {
      var n = ref[0];
      return Math.ceil(n.evaluate(ctx));
    }],
    'filter-==': [BooleanType, [StringType, ValueType], function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      return ctx.properties()[k.value] === v.value;
    }],
    'filter-id-==': [BooleanType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      return ctx.id() === v.value;
    }],
    'filter-type-==': [BooleanType, [StringType], function (ctx, ref) {
      var v = ref[0];
      return ctx.geometryType() === v.value;
    }],
    'filter-<': [BooleanType, [StringType, ValueType], function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      var a = ctx.properties()[k.value];
      var b = v.value;
      return _typeof(a) === _typeof(b) && a < b;
    }],
    'filter-id-<': [BooleanType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      var a = ctx.id();
      var b = v.value;
      return _typeof(a) === _typeof(b) && a < b;
    }],
    'filter->': [BooleanType, [StringType, ValueType], function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      var a = ctx.properties()[k.value];
      var b = v.value;
      return _typeof(a) === _typeof(b) && a > b;
    }],
    'filter-id->': [BooleanType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      var a = ctx.id();
      var b = v.value;
      return _typeof(a) === _typeof(b) && a > b;
    }],
    'filter-<=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      var a = ctx.properties()[k.value];
      var b = v.value;
      return _typeof(a) === _typeof(b) && a <= b;
    }],
    'filter-id-<=': [BooleanType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      var a = ctx.id();
      var b = v.value;
      return _typeof(a) === _typeof(b) && a <= b;
    }],
    'filter->=': [BooleanType, [StringType, ValueType], function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      var a = ctx.properties()[k.value];
      var b = v.value;
      return _typeof(a) === _typeof(b) && a >= b;
    }],
    'filter-id->=': [BooleanType, [ValueType], function (ctx, ref) {
      var v = ref[0];
      var a = ctx.id();
      var b = v.value;
      return _typeof(a) === _typeof(b) && a >= b;
    }],
    'filter-has': [BooleanType, [ValueType], function (ctx, ref) {
      var k = ref[0];
      return k.value in ctx.properties();
    }],
    'filter-has-id': [BooleanType, [], function (ctx) {
      return ctx.id() !== null && ctx.id() !== undefined;
    }],
    'filter-type-in': [BooleanType, [array$1(StringType)], function (ctx, ref) {
      var v = ref[0];
      return v.value.indexOf(ctx.geometryType()) >= 0;
    }],
    'filter-id-in': [BooleanType, [array$1(ValueType)], function (ctx, ref) {
      var v = ref[0];
      return v.value.indexOf(ctx.id()) >= 0;
    }],
    'filter-in-small': [BooleanType, [StringType, array$1(ValueType)], // assumes v is an array literal
    function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      return v.value.indexOf(ctx.properties()[k.value]) >= 0;
    }],
    'filter-in-large': [BooleanType, [StringType, array$1(ValueType)], // assumes v is a array literal with values sorted in ascending order and of a single type
    function (ctx, ref) {
      var k = ref[0];
      var v = ref[1];
      return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);
    }],
    'all': {
      type: BooleanType,
      overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) && b.evaluate(ctx);
      }], [varargs(BooleanType), function (ctx, args) {
        for (var i = 0, list = args; i < list.length; i += 1) {
          var arg = list[i];

          if (!arg.evaluate(ctx)) {
            return false;
          }
        }

        return true;
      }]]
    },
    'any': {
      type: BooleanType,
      overloads: [[[BooleanType, BooleanType], function (ctx, ref) {
        var a = ref[0];
        var b = ref[1];
        return a.evaluate(ctx) || b.evaluate(ctx);
      }], [varargs(BooleanType), function (ctx, args) {
        for (var i = 0, list = args; i < list.length; i += 1) {
          var arg = list[i];

          if (arg.evaluate(ctx)) {
            return true;
          }
        }

        return false;
      }]]
    },
    '!': [BooleanType, [BooleanType], function (ctx, ref) {
      var b = ref[0];
      return !b.evaluate(ctx);
    }],
    'is-supported-script': [BooleanType, [StringType], // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    function (ctx, ref) {
      var s = ref[0];
      var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;

      if (isSupportedScript) {
        return isSupportedScript(s.evaluate(ctx));
      }

      return true;
    }],
    'upcase': [StringType, [StringType], function (ctx, ref) {
      var s = ref[0];
      return s.evaluate(ctx).toUpperCase();
    }],
    'downcase': [StringType, [StringType], function (ctx, ref) {
      var s = ref[0];
      return s.evaluate(ctx).toLowerCase();
    }],
    'concat': [StringType, varargs(ValueType), function (ctx, args) {
      return args.map(function (arg) {
        return toString(arg.evaluate(ctx));
      }).join('');
    }],
    'resolved-locale': [StringType, [CollatorType], function (ctx, ref) {
      var collator = ref[0];
      return collator.evaluate(ctx).resolvedLocale();
    }]
  }); //      
  /**
  * @typedef {import("./apply.js").Options} Options
  * @typedef {import('./apply.js').ResourceType} ResourceType
  * @private
  */


  Array(256).join("\u200A");

  new GeoJSON();

  /**
   * @module ol/webgl/PaletteTexture
   */
  var PaletteTexture = /*#__PURE__*/function () {
    /**
     * @param {string} name The name of the texture.
     * @param {Uint8Array} data The texture data.
     */
    function PaletteTexture(name, data) {
      _classCallCheck(this, PaletteTexture);

      this.name = name;
      this.data = data;
      /**
       * @type {WebGLTexture}
       * @private
       */

      this.texture_ = null;
    }
    /**
     * @param {WebGLRenderingContext} gl Rendering context.
     * @return {WebGLTexture} The texture.
     */


    _createClass(PaletteTexture, [{
      key: "getTexture",
      value: function getTexture(gl) {
        if (!this.texture_) {
          var texture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.data.length / 4, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, this.data);
          this.texture_ = texture;
        }

        return this.texture_;
      }
    }]);

    return PaletteTexture;
  }();

  /**
   * @param {WebGLRenderingContext} gl The WebGL context.
   * @param {WebGLTexture} texture The texture.
   * @param {boolean} interpolate Interpolate when resampling.
   */

  function bindAndConfigure(gl, texture, interpolate) {
    var resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);
  }
  /**
   * @param {WebGLRenderingContext} gl The WebGL context.
   * @param {WebGLTexture} texture The texture.
   * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image The image.
   * @param {boolean} interpolate Interpolate when resampling.
   */


  function uploadImageTexture(gl, texture, image, interpolate) {
    bindAndConfigure(gl, texture, interpolate);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  }
  /**
   * @param {import("./Helper.js").default} helper The WebGL helper.
   * @param {WebGLTexture} texture The texture.
   * @param {import("../DataTile.js").Data} data The pixel data.
   * @param {import("../size.js").Size} size The pixel size.
   * @param {number} bandCount The band count.
   * @param {boolean} interpolate Interpolate when resampling.
   */


  function uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {
    var gl = helper.getGL();
    var textureType;
    var canInterpolate;

    if (data instanceof Float32Array) {
      textureType = gl.FLOAT;
      helper.getExtension('OES_texture_float');
      var extension = helper.getExtension('OES_texture_float_linear');
      canInterpolate = extension !== null;
    } else {
      textureType = gl.UNSIGNED_BYTE;
      canInterpolate = true;
    }

    bindAndConfigure(gl, texture, interpolate && canInterpolate);
    var bytesPerRow = data.byteLength / size[1];
    var unpackAlignment = 1;

    if (bytesPerRow % 8 === 0) {
      unpackAlignment = 8;
    } else if (bytesPerRow % 4 === 0) {
      unpackAlignment = 4;
    } else if (bytesPerRow % 2 === 0) {
      unpackAlignment = 2;
    }

    var format;

    switch (bandCount) {
      case 1:
        {
          format = gl.LUMINANCE;
          break;
        }

      case 2:
        {
          format = gl.LUMINANCE_ALPHA;
          break;
        }

      case 3:
        {
          format = gl.RGB;
          break;
        }

      case 4:
        {
          format = gl.RGBA;
          break;
        }

      default:
        {
          throw new Error("Unsupported number of bands: ".concat(bandCount));
        }
    }

    var oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);
    gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);
  }
  /**
   * @type {CanvasRenderingContext2D}
   */


  var pixelContext = null;

  function createPixelContext() {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    pixelContext = canvas.getContext('2d');
  }
  /**
   * @typedef {import("../DataTile.js").default|ImageTile|ReprojTile} TileType
   */

  /**
   * @typedef {Object} Options
   * @property {TileType} tile The tile.
   * @property {import("../tilegrid/TileGrid.js").default} grid Tile grid.
   * @property {import("../webgl/Helper.js").default} helper WebGL helper.
   * @property {number} [gutter=0] The size in pixels of the gutter around image tiles to ignore.
   */


  var TileTexture = /*#__PURE__*/function (_EventTarget) {
    _inherits(TileTexture, _EventTarget);

    var _super = _createSuper(TileTexture);

    /**
     * @param {Options} options The tile texture options.
     */
    function TileTexture(options) {
      var _this;

      _classCallCheck(this, TileTexture);

      _this = _super.call(this);
      /**
       * @type {TileType}
       */

      _this.tile;
      /**
       * @type {Array<WebGLTexture>}
       */

      _this.textures = [];
      _this.handleTileChange_ = _this.handleTileChange_.bind(_assertThisInitialized(_this));
      /**
       * @type {import("../size.js").Size}
       * @private
       */

      _this.renderSize_ = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));
      /**
       * @type {number}
       * @private
       */

      _this.gutter_ = options.gutter || 0;
      /**
       * @type {number}
       */

      _this.bandCount = NaN;
      /**
       * @type {import("../webgl/Helper.js").default}
       * @private
       */

      _this.helper_ = options.helper;
      var coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);
      coords.fromArray([0, // P0
      1, 1, // P1
      1, 1, // P2
      0, 0, // P3
      0]);

      _this.helper_.flushBufferData(coords);
      /**
       * @type {WebGLArrayBuffer}
       */


      _this.coords = coords;

      _this.setTile(options.tile);

      return _this;
    }
    /**
     * @param {TileType} tile Tile.
     */


    _createClass(TileTexture, [{
      key: "setTile",
      value: function setTile(tile) {
        if (tile !== this.tile) {
          if (this.tile) {
            this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
          }

          this.tile = tile;
          this.textures.length = 0;
          this.loaded = tile.getState() === TileState.LOADED;

          if (this.loaded) {
            this.uploadTile_();
          } else {
            if (tile instanceof ImageTile) {
              var image = tile.getImage();

              if (image instanceof Image && !image.crossOrigin) {
                image.crossOrigin = 'anonymous';
              }
            }

            tile.addEventListener(EventType.CHANGE, this.handleTileChange_);
          }
        }
      }
    }, {
      key: "uploadTile_",
      value: function uploadTile_() {
        var helper = this.helper_;
        var gl = helper.getGL();
        var tile = this.tile;

        if (tile instanceof ImageTile || tile instanceof ReprojTile) {
          var texture = gl.createTexture();
          this.textures.push(texture);
          this.bandCount = 4;
          uploadImageTexture(gl, texture, tile.getImage(), tile.interpolate);
          return;
        }

        var sourceTileSize = tile.getSize();
        var pixelSize = [sourceTileSize[0] + 2 * this.gutter_, sourceTileSize[1] + 2 * this.gutter_];
        var data = tile.getData();
        var isFloat = data instanceof Float32Array;
        var pixelCount = pixelSize[0] * pixelSize[1];
        var DataType = isFloat ? Float32Array : Uint8Array;
        var bytesPerElement = DataType.BYTES_PER_ELEMENT;
        var bytesPerRow = data.byteLength / pixelSize[1];
        this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);
        var textureCount = Math.ceil(this.bandCount / 4);

        if (textureCount === 1) {
          var _texture = gl.createTexture();

          this.textures.push(_texture);
          uploadDataTexture(helper, _texture, data, pixelSize, this.bandCount, tile.interpolate);
          return;
        }

        var textureDataArrays = new Array(textureCount);

        for (var textureIndex = 0; textureIndex < textureCount; ++textureIndex) {
          var _texture2 = gl.createTexture();

          this.textures.push(_texture2);
          var bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
          textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);
        }

        var dataIndex = 0;
        var rowOffset = 0;
        var colCount = pixelSize[0] * this.bandCount;

        for (var rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
          for (var colIndex = 0; colIndex < colCount; ++colIndex) {
            var dataValue = data[rowOffset + colIndex];
            var pixelIndex = Math.floor(dataIndex / this.bandCount);
            var bandIndex = colIndex % this.bandCount;

            var _textureIndex = Math.floor(bandIndex / 4);

            var textureData = textureDataArrays[_textureIndex];

            var _bandCount = textureData.length / pixelCount;

            var textureBandIndex = bandIndex % 4;
            textureData[pixelIndex * _bandCount + textureBandIndex] = dataValue;
            ++dataIndex;
          }

          rowOffset += bytesPerRow / bytesPerElement;
        }

        for (var _textureIndex2 = 0; _textureIndex2 < textureCount; ++_textureIndex2) {
          var _texture3 = this.textures[_textureIndex2];
          var _textureData = textureDataArrays[_textureIndex2];

          var _bandCount2 = _textureData.length / pixelCount;

          uploadDataTexture(helper, _texture3, _textureData, pixelSize, _bandCount2, tile.interpolate);
        }
      }
    }, {
      key: "handleTileChange_",
      value: function handleTileChange_() {
        if (this.tile.getState() === TileState.LOADED) {
          this.loaded = true;
          this.uploadTile_();
          this.dispatchEvent(EventType.CHANGE);
        }
      }
    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        var gl = this.helper_.getGL();
        this.helper_.deleteBuffer(this.coords);

        for (var i = 0; i < this.textures.length; ++i) {
          gl.deleteTexture(this.textures[i]);
        }

        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);
      }
      /**
       * Get data for a pixel.  If the tile is not loaded, null is returned.
       * @param {number} renderCol The column index (in rendered tile space).
       * @param {number} renderRow The row index (in rendered tile space).
       * @return {import("../DataTile.js").Data|null} The data.
       */

    }, {
      key: "getPixelData",
      value: function getPixelData(renderCol, renderRow) {
        if (!this.loaded) {
          return null;
        }

        var renderWidth = this.renderSize_[0];
        var renderHeight = this.renderSize_[1];
        var gutter = this.gutter_;

        if (this.tile instanceof DataTile) {
          var sourceSize = this.tile.getSize();
          var _sourceWidthWithoutGutter = sourceSize[0];
          var _sourceHeightWithoutGutter = sourceSize[1];

          var _sourceWidth = _sourceWidthWithoutGutter + 2 * gutter;

          var _sourceHeight = _sourceHeightWithoutGutter + 2 * gutter;

          var _sourceCol = gutter + Math.floor(_sourceWidthWithoutGutter * (renderCol / renderWidth));

          var _sourceRow = gutter + Math.floor(_sourceHeightWithoutGutter * (renderRow / renderHeight));

          var _data = this.tile.getData();

          if (_data instanceof DataView) {
            var bytesPerPixel = _data.byteLength / (_sourceWidth * _sourceHeight);

            var _offset = bytesPerPixel * (_sourceRow * _sourceWidth + _sourceCol);

            var buffer = _data.buffer.slice(_offset, _offset + bytesPerPixel);

            return new DataView(buffer);
          }

          var offset = this.bandCount * (_sourceRow * _sourceWidth + _sourceCol);
          return _data.slice(offset, offset + this.bandCount);
        }

        if (!pixelContext) {
          createPixelContext();
        }

        pixelContext.clearRect(0, 0, 1, 1);
        var image = this.tile.getImage();
        var sourceWidth = image.width;
        var sourceHeight = image.height;
        var sourceWidthWithoutGutter = sourceWidth - 2 * gutter;
        var sourceHeightWithoutGutter = sourceHeight - 2 * gutter;
        var sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));
        var sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));
        var data;

        try {
          pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
          pixelContext = null;
          return null;
        }

        return data;
      }
    }]);

    return TileTexture;
  }(Target);

  var Uniforms = {
    TILE_TEXTURE_ARRAY: 'u_tileTextures',
    TILE_TRANSFORM: 'u_tileTransform',
    TRANSITION_ALPHA: 'u_transitionAlpha',
    DEPTH: 'u_depth',
    TEXTURE_PIXEL_WIDTH: 'u_texturePixelWidth',
    TEXTURE_PIXEL_HEIGHT: 'u_texturePixelHeight',
    TEXTURE_RESOLUTION: 'u_textureResolution',
    // map units per texture pixel
    TEXTURE_ORIGIN_X: 'u_textureOriginX',
    // map x coordinate of left edge of texture
    TEXTURE_ORIGIN_Y: 'u_textureOriginY',
    // map y coordinate of top edge of texture
    RENDER_EXTENT: 'u_renderExtent',
    // intersection of layer, source, and view extent
    RESOLUTION: 'u_resolution',
    ZOOM: 'u_zoom'
  };
  var Attributes = {
    TEXTURE_COORD: 'a_textureCoord'
  };
  /**
   * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}
   */

  var attributeDescriptions = [{
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
  }];
  /**
   * @type {Object<string, boolean>}
   */

  var empty = {};
  /**
   * Transform a zoom level into a depth value ranging from -1 to 1.
   * @param {number} z A zoom level.
   * @return {number} A depth value.
   */

  function depthForZ(z) {
    return 2 * (1 - 1 / (z + 1)) - 1;
  }
  /**
   * Add a tile texture to the lookup.
   * @param {Object<number, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
   * tile textures by zoom level.
   * @param {import("../../webgl/TileTexture.js").default} tileTexture A tile texture.
   * @param {number} z The zoom level.
   */


  function addTileTextureToLookup(tileTexturesByZ, tileTexture, z) {
    if (!(z in tileTexturesByZ)) {
      tileTexturesByZ[z] = [];
    }

    tileTexturesByZ[z].push(tileTexture);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The frame extent.
   * @return {import("../../extent.js").Extent} Frame extent intersected with layer extents.
   */


  function getRenderExtent(frameState, extent) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];

    if (layerState.extent) {
      extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));
    }

    var source =
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource();

    if (!source.getWrapX()) {
      var gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();

      if (gridExtent) {
        extent = getIntersection(extent, gridExtent);
      }
    }

    return extent;
  }

  function getCacheKey(source, tileCoord) {
    return "".concat(source.getKey(), ",").concat(getKey(tileCoord));
  }
  /**
   * @typedef {Object} Options
   * @property {string} vertexShader Vertex shader source.
   * @property {string} fragmentShader Fragment shader source.
   * @property {Object<string, import("../../webgl/Helper").UniformValue>} [uniforms] Additional uniforms
   * made available to shaders.
   * @property {Array<import("../../webgl/PaletteTexture.js").default>} [paletteTextures] Palette textures.
   * @property {number} [cacheSize=512] The texture cache size.
   */

  /**
   * @typedef {import("../../layer/WebGLTile.js").default} LayerType
   */

  /**
   * @classdesc
   * WebGL renderer for tile layers.
   * @extends {WebGLLayerRenderer<LayerType>}
   * @api
   */


  var WebGLTileLayerRenderer = /*#__PURE__*/function (_WebGLLayerRenderer) {
    _inherits(WebGLTileLayerRenderer, _WebGLLayerRenderer);

    var _super = _createSuper(WebGLTileLayerRenderer);

    /**
     * @param {LayerType} tileLayer Tile layer.
     * @param {Options} options Options.
     */
    function WebGLTileLayerRenderer(tileLayer, options) {
      var _this;

      _classCallCheck(this, WebGLTileLayerRenderer);

      _this = _super.call(this, tileLayer, {
        uniforms: options.uniforms
      });
      /**
       * The last call to `renderFrame` was completed with all tiles loaded
       * @type {boolean}
       */

      _this.renderComplete = false;
      /**
       * This transform converts texture coordinates to screen coordinates.
       * @type {import("../../transform.js").Transform}
       * @private
       */

      _this.tileTransform_ = create$1();
      /**
       * @type {Array<number>}
       * @private
       */

      _this.tempMat4_ = create();
      /**
       * @type {import("../../TileRange.js").default}
       * @private
       */

      _this.tempTileRange_ = new TileRange(0, 0, 0, 0);
      /**
       * @type {import("../../tilecoord.js").TileCoord}
       * @private
       */

      _this.tempTileCoord_ = createOrUpdate$1(0, 0, 0);
      /**
       * @type {import("../../size.js").Size}
       * @private
       */

      _this.tempSize_ = [0, 0];
      /**
       * @type {WebGLProgram}
       * @private
       */

      _this.program_;
      /**
       * @private
       */

      _this.vertexShader_ = options.vertexShader;
      /**
       * @private
       */

      _this.fragmentShader_ = options.fragmentShader;
      /**
       * Tiles are rendered as a quad with the following structure:
       *
       *  [P3]---------[P2]
       *   |`           |
       *   |  `     B   |
       *   |    `       |
       *   |      `     |
       *   |   A    `   |
       *   |          ` |
       *  [P0]---------[P1]
       *
       * Triangle A: P0, P1, P3
       * Triangle B: P1, P2, P3
       *
       * @private
       */

      _this.indices_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, STATIC_DRAW);

      _this.indices_.fromArray([0, 1, 3, 1, 2, 3]);

      var cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;
      /**
       * @type {import("../../structs/LRUCache.js").default<import("../../webgl/TileTexture.js").default>}
       * @private
       */

      _this.tileTextureCache_ = new LRUCache(cacheSize);
      /**
       * @type {Array<import("../../webgl/PaletteTexture.js").default>}
       * @private
       */

      _this.paletteTextures_ = options.paletteTextures || [];
      /**
       * @private
       * @type {import("../../Map.js").FrameState|null}
       */

      _this.frameState_ = null;
      /**
       * @private
       * @type {import("../../proj/Projection.js").default}
       */

      _this.projection_ = undefined;
      return _this;
    }
    /**
     * @param {Options} options Options.
     */


    _createClass(WebGLTileLayerRenderer, [{
      key: "reset",
      value: function reset(options) {
        _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "reset", this).call(this, {
          uniforms: options.uniforms
        });

        this.vertexShader_ = options.vertexShader;
        this.fragmentShader_ = options.fragmentShader;
        this.paletteTextures_ = options.paletteTextures || [];

        if (this.helper) {
          this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
        }
      }
    }, {
      key: "afterHelperCreated",
      value: function afterHelperCreated() {
        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_);
        this.helper.flushBufferData(this.indices_);
      }
      /**
       * @param {import("../../webgl/TileTexture").TileType} tile Tile.
       * @return {boolean} Tile is drawable.
       * @private
       */

    }, {
      key: "isDrawableTile_",
      value: function isDrawableTile_(tile) {
        var tileLayer = this.getLayer();
        var tileState = tile.getState();
        var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
        return tileState == TileState.LOADED || tileState == TileState.EMPTY || tileState == TileState.ERROR && !useInterimTilesOnError;
      }
      /**
       * Determine whether renderFrame should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */

    }, {
      key: "prepareFrameInternal",
      value: function prepareFrameInternal(frameState) {
        if (!this.projection_) {
          this.projection_ = frameState.viewState.projection;
        } else if (frameState.viewState.projection !== this.projection_) {
          this.clearCache();
          this.projection_ = frameState.viewState.projection;
        }

        var layer = this.getLayer();
        var source = layer.getRenderSource();

        if (!source) {
          return false;
        }

        if (isEmpty(getRenderExtent(frameState, frameState.extent))) {
          return false;
        }

        return source.getState() === 'ready';
      }
      /**
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent The extent to be rendered.
       * @param {number} initialZ The zoom level.
       * @param {Object<number, Array<TileTexture>>} tileTexturesByZ The zoom level.
       * @param {number} preload Number of additional levels to load.
       */

    }, {
      key: "enqueueTiles",
      value: function enqueueTiles(frameState, extent, initialZ, tileTexturesByZ, preload) {
        var viewState = frameState.viewState;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getRenderSource();
        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        var gutter = tileSource.getGutterForProjection(viewState.projection);
        var tileSourceKey = getUid(tileSource);

        if (!(tileSourceKey in frameState.wantedTiles)) {
          frameState.wantedTiles[tileSourceKey] = {};
        }

        var wantedTiles = frameState.wantedTiles[tileSourceKey];
        var tileTextureCache = this.tileTextureCache_;
        var map = tileLayer.getMapInternal();
        var minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));

        for (var z = initialZ; z >= minZ; --z) {
          var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);
          var tileResolution = tileGrid.getResolution(z);

          for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
              var tileCoord = createOrUpdate$1(z, x, y, this.tempTileCoord_);
              var cacheKey = getCacheKey(tileSource, tileCoord);
              /** @type {TileTexture} */

              var tileTexture = void 0;
              /** @type {import("../../webgl/TileTexture").TileType} */

              var tile = void 0;

              if (tileTextureCache.containsKey(cacheKey)) {
                tileTexture = tileTextureCache.get(cacheKey);
                tile = tileTexture.tile;
              }

              if (!tileTexture || tileTexture.tile.key !== tileSource.getKey()) {
                tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);

                if (!tileTexture) {
                  tileTexture = new TileTexture({
                    tile: tile,
                    grid: tileGrid,
                    helper: this.helper,
                    gutter: gutter
                  });
                  tileTextureCache.set(cacheKey, tileTexture);
                } else {
                  if (this.isDrawableTile_(tile)) {
                    tileTexture.setTile(tile);
                  } else {
                    var interimTile =
                    /** @type {import("../../webgl/TileTexture").TileType} */
                    tile.getInterimTile();
                    tileTexture.setTile(interimTile);
                  }
                }
              }

              addTileTextureToLookup(tileTexturesByZ, tileTexture, z);
              var tileQueueKey = tile.getKey();
              wantedTiles[tileQueueKey] = true;

              if (tile.getState() === TileState.IDLE) {
                if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
                  frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);
                }
              }
            }
          }
        }
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {HTMLElement} The rendered element.
       */

    }, {
      key: "renderFrame",
      value: function renderFrame(frameState) {
        var _this2 = this;

        this.frameState_ = frameState;
        this.renderComplete = true;
        var gl = this.helper.getGL();
        this.preRender(gl, frameState);
        var viewState = frameState.viewState;
        var tileLayer = this.getLayer();
        var tileSource = tileLayer.getRenderSource();
        var tileGrid = tileSource.getTileGridForProjection(viewState.projection);
        var gutter = tileSource.getGutterForProjection(viewState.projection);
        var extent = getRenderExtent(frameState, frameState.extent);
        var z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);
        /**
         * @type {Object<number, Array<import("../../webgl/TileTexture.js").default>>}
         */

        var tileTexturesByZ = {};
        var preload = tileLayer.getPreload();

        if (frameState.nextExtent) {
          var targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);
          var nextExtent = getRenderExtent(frameState, frameState.nextExtent);
          this.enqueueTiles(frameState, nextExtent, targetZ, tileTexturesByZ, preload);
        }

        this.enqueueTiles(frameState, extent, z, tileTexturesByZ, 0);

        if (preload > 0) {
          setTimeout(function () {
            _this2.enqueueTiles(frameState, extent, z - 1, tileTexturesByZ, preload - 1);
          }, 0);
        }
        /**
         * A lookup of alpha values for tiles at the target rendering resolution
         * for tiles that are in transition.  If a tile coord key is absent from
         * this lookup, the tile should be rendered at alpha 1.
         * @type {Object<string, number>}
         */


        var alphaLookup = {};
        var uid = getUid(this);
        var time = frameState.time;
        var blend = false; // look for cached tiles to use if a target tile is not ready

        var tileTextures = tileTexturesByZ[z];

        for (var i = 0, ii = tileTextures.length; i < ii; ++i) {
          var tileTexture = tileTextures[i];
          var tile = tileTexture.tile;

          if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {
            continue;
          }

          var tileCoord = tile.tileCoord;

          if (tileTexture.loaded) {
            var alpha = tile.getAlpha(uid, time);

            if (alpha === 1) {
              // no need to look for alt tiles
              tile.endTransition(uid);
              continue;
            }

            blend = true;
            var tileCoordKey = getKey(tileCoord);
            alphaLookup[tileCoordKey] = alpha;
          }

          this.renderComplete = false; // first look for child tiles (at z + 1)

          var coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileTexturesByZ);

          if (coveredByChildren) {
            continue;
          } // next look for parent tiles


          var minZoom = tileGrid.getMinZoom();

          for (var parentZ = z - 1; parentZ >= minZoom; --parentZ) {
            var coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileTexturesByZ);

            if (coveredByParent) {
              break;
            }
          }
        }

        this.helper.useProgram(this.program_, frameState);
        this.helper.prepareDraw(frameState, !blend);
        var zs = Object.keys(tileTexturesByZ).map(Number).sort(numberSafeCompareFunction);
        var centerX = viewState.center[0];
        var centerY = viewState.center[1];

        for (var j = 0, jj = zs.length; j < jj; ++j) {
          var tileZ = zs[j];
          var tileResolution = tileGrid.getResolution(tileZ);
          var tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);
          var tileOrigin = tileGrid.getOrigin(tileZ);
          var tileWidthWithGutter = tileSize[0] + 2 * gutter;
          var tileHeightWithGutter = tileSize[1] + 2 * gutter;
          var aspectRatio = tileWidthWithGutter / tileHeightWithGutter;
          var centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);
          var centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);
          var tileScale = viewState.resolution / tileResolution;
          var depth = depthForZ(tileZ);
          var _tileTextures = tileTexturesByZ[tileZ];

          for (var _i = 0, _ii = _tileTextures.length; _i < _ii; ++_i) {
            var _tileTexture = _tileTextures[_i];

            if (!_tileTexture.loaded) {
              continue;
            }

            var _tile = _tileTexture.tile;
            var _tileCoord = _tile.tileCoord;

            var _tileCoordKey = getKey(_tileCoord);

            var tileCenterI = _tileCoord[1];
            var tileCenterJ = _tileCoord[2];
            reset(this.tileTransform_);
            scale$3(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));
            rotate$2(this.tileTransform_, viewState.rotation);
            scale$3(this.tileTransform_, 1, 1 / aspectRatio);
            translate$1(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);
            this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4_, this.tileTransform_));
            this.helper.bindBuffer(_tileTexture.coords);
            this.helper.bindBuffer(this.indices_);
            this.helper.enableAttributes(attributeDescriptions);
            var textureSlot = 0;

            while (textureSlot < _tileTexture.textures.length) {
              var textureProperty = 'TEXTURE' + textureSlot;
              var uniformName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureSlot, "]");
              gl.activeTexture(gl[textureProperty]);
              gl.bindTexture(gl.TEXTURE_2D, _tileTexture.textures[textureSlot]);
              gl.uniform1i(this.helper.getUniformLocation(uniformName), textureSlot);
              ++textureSlot;
            }

            for (var paletteIndex = 0; paletteIndex < this.paletteTextures_.length; ++paletteIndex) {
              var paletteTexture = this.paletteTextures_[paletteIndex];
              gl.activeTexture(gl['TEXTURE' + textureSlot]);
              var texture = paletteTexture.getTexture(gl);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.uniform1i(this.helper.getUniformLocation(paletteTexture.name), textureSlot);
              ++textureSlot;
            }

            var _alpha = _tileCoordKey in alphaLookup ? alphaLookup[_tileCoordKey] : 1;

            if (_alpha < 1) {
              frameState.animate = true;
            }

            this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, _alpha);
            this.helper.setUniformFloatValue(Uniforms.DEPTH, depth);
            this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, tileWidthWithGutter);
            this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, tileHeightWithGutter);
            this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, tileResolution);
            this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tileOrigin[0] + tileCenterI * tileSize[0] * tileResolution - gutter * tileResolution);
            this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tileOrigin[1] - tileCenterJ * tileSize[1] * tileResolution + gutter * tileResolution);
            var gutterExtent = extent;

            if (gutter > 0) {
              gutterExtent = tileGrid.getTileCoordExtent(_tileCoord);
              getIntersection(gutterExtent, extent, gutterExtent);
            }

            this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, gutterExtent);
            this.helper.setUniformFloatValue(Uniforms.RESOLUTION, viewState.resolution);
            this.helper.setUniformFloatValue(Uniforms.ZOOM, viewState.zoom);
            this.helper.drawElements(0, this.indices_.getSize());
          }
        }

        this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
        var canvas = this.helper.getCanvas();
        var tileTextureCache = this.tileTextureCache_;

        while (tileTextureCache.canExpireCache()) {
          var _tileTexture2 = tileTextureCache.pop();

          _tileTexture2.dispose();
        } // TODO: let the renderers manage their own cache instead of managing the source cache

        /**
         * Here we unconditionally expire the source cache since the renderer maintains
         * its own cache.
         * @param {import("../../Map.js").default} map Map.
         * @param {import("../../Map.js").FrameState} frameState Frame state.
         */


        var postRenderFunction = function postRenderFunction(map, frameState) {
          tileSource.updateCacheSize(0.1, frameState.viewState.projection);
          tileSource.expireCache(frameState.viewState.projection, empty);
        };

        frameState.postRenderFunctions.push(postRenderFunction);
        this.postRender(gl, frameState);
        return canvas;
      }
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView} Data at the pixel location.
       */

    }, {
      key: "getData",
      value: function getData(pixel) {
        var gl = this.helper.getGL();

        if (!gl) {
          return null;
        }

        var frameState = this.frameState_;

        if (!frameState) {
          return null;
        }

        var layer = this.getLayer();
        var coordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
        var viewState = frameState.viewState;
        var layerExtent = layer.getExtent();

        if (layerExtent) {
          if (!containsCoordinate(fromUserExtent(layerExtent, viewState.projection), coordinate)) {
            return null;
          }
        } // determine last source suitable for rendering at coordinate


        var sources = layer.getSources(boundingExtent([coordinate]), viewState.resolution);
        var i, source, tileGrid;

        for (i = sources.length - 1; i >= 0; --i) {
          source = sources[i];

          if (source.getState() === 'ready') {
            tileGrid = source.getTileGridForProjection(viewState.projection);

            if (source.getWrapX()) {
              break;
            }

            var gridExtent = tileGrid.getExtent();

            if (!gridExtent || containsCoordinate(gridExtent, coordinate)) {
              break;
            }
          }
        }

        if (i < 0) {
          return null;
        }

        var tileTextureCache = this.tileTextureCache_;

        for (var z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
          var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
          var cacheKey = getCacheKey(source, tileCoord);

          if (!tileTextureCache.containsKey(cacheKey)) {
            continue;
          }

          var tileTexture = tileTextureCache.get(cacheKey);
          var tile = tileTexture.tile;

          if (tile instanceof ReprojTile && tile.getState() === TileState.EMPTY) {
            return null;
          }

          if (!tileTexture.loaded) {
            continue;
          }

          var tileOrigin = tileGrid.getOrigin(z);
          var tileSize = toSize(tileGrid.getTileSize(z));
          var tileResolution = tileGrid.getResolution(z);
          var col = (coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0];
          var row = (tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1];
          return tileTexture.getPixelData(col, row);
        }

        return null;
      }
      /**
       * Look for tiles covering the provided tile coordinate at an alternate
       * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
       * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
       * @param {number} altZ The alternate zoom level.
       * @param {Object<number, Array<import("../../webgl/TileTexture.js").default>>} tileTexturesByZ Lookup of
       * tile textures by zoom level.
       * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
       * @private
       */

    }, {
      key: "findAltTiles_",
      value: function findAltTiles_(tileGrid, tileCoord, altZ, tileTexturesByZ) {
        var tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);

        if (!tileRange) {
          return false;
        }

        var covered = true;
        var tileTextureCache = this.tileTextureCache_;
        var source = this.getLayer().getRenderSource();

        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
            var cacheKey = getCacheKey(source, [altZ, x, y]);
            var loaded = false;

            if (tileTextureCache.containsKey(cacheKey)) {
              var tileTexture = tileTextureCache.get(cacheKey);

              if (tileTexture.loaded) {
                addTileTextureToLookup(tileTexturesByZ, tileTexture, altZ);
                loaded = true;
              }
            }

            if (!loaded) {
              covered = false;
            }
          }
        }

        return covered;
      }
    }, {
      key: "clearCache",
      value: function clearCache() {
        var tileTextureCache = this.tileTextureCache_;
        tileTextureCache.forEach(function (tileTexture) {
          return tileTexture.dispose();
        });
        tileTextureCache.clear();
      }
    }, {
      key: "removeHelper",
      value: function removeHelper() {
        if (this.helper) {
          this.clearCache();
        }

        _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "removeHelper", this).call(this);
      }
      /**
       * Clean up.
       */

    }, {
      key: "disposeInternal",
      value: function disposeInternal() {
        var helper = this.helper;

        if (helper) {
          var gl = helper.getGL();
          gl.deleteProgram(this.program_);
          delete this.program_;
          helper.deleteBuffer(this.indices_);
        }

        _get(_getPrototypeOf(WebGLTileLayerRenderer.prototype), "disposeInternal", this).call(this);

        delete this.indices_;
        delete this.tileTextureCache_;
        delete this.frameState_;
      }
    }]);

    return WebGLTileLayerRenderer;
  }(WebGLLayerRenderer);

  /**
   * Operators and utilities used for style expressions
   * @module ol/style/expressions
   */
  /**
   * Base type used for literal style parameters; can be a number literal or the output of an operator,
   * which in turns takes {@link import("./expressions.js").ExpressionValue} arguments.
   *
   * The following operators can be used:
   *
   * * Reading operators:
   *   * `['band', bandIndex, xOffset, yOffset]` For tile layers only. Fetches pixel values from band
   *     `bandIndex` of the source's data. The first `bandIndex` of the source data is `1`. Fetched values
   *     are in the 0..1 range. {@link import("../source/TileImage.js").default} sources have 4 bands: red,
   *     green, blue and alpha. {@link import("../source/DataTile.js").default} sources can have any number
   *     of bands, depending on the underlying data source and
   *     {@link import("../source/GeoTIFF.js").Options configuration}. `xOffset` and `yOffset` are optional
   *     and allow specifying pixel offsets for x and y. This is used for sampling data from neighboring pixels.
   *   * `['get', 'attributeName']` fetches a feature attribute (it will be prefixed by `a_` in the shader)
   *     Note: those will be taken from the attributes provided to the renderer
   *   * `['resolution']` returns the current resolution
   *   * `['time']` returns the time in seconds since the creation of the layer
   *   * `['var', 'varName']` fetches a value from the style variables, or 0 if undefined
   *   * `['zoom']` returns the current zoom level
   *
   * * Math operators:
   *   * `['*', value1, value2]` multiplies `value1` by `value2`
   *   * `['/', value1, value2]` divides `value1` by `value2`
   *   * `['+', value1, value2]` adds `value1` and `value2`
   *   * `['-', value1, value2]` subtracts `value2` from `value1`
   *   * `['clamp', value, low, high]` clamps `value` between `low` and `high`
   *   * `['%', value1, value2]` returns the result of `value1 % value2` (modulo)
   *   * `['^', value1, value2]` returns the value of `value1` raised to the `value2` power
   *   * `['abs', value1]` returns the absolute value of `value1`
   *   * `['floor', value1]` returns the nearest integer less than or equal to `value1`
   *   * `['round', value1]` returns the nearest integer to `value1`
   *   * `['ceil', value1]` returns the nearest integer greater than or equal to `value1`
   *   * `['sin', value1]` returns the sine of `value1`
   *   * `['cos', value1]` returns the cosine of `value1`
   *   * `['atan', value1, value2]` returns `atan2(value1, value2)`. If `value2` is not provided, returns `atan(value1)`
   *
   * * Transform operators:
   *   * `['case', condition1, output1, ...conditionN, outputN, fallback]` selects the first output whose corresponding
   *     condition evaluates to `true`. If no match is found, returns the `fallback` value.
   *     All conditions should be `boolean`, output and fallback can be any kind.
   *   * `['match', input, match1, output1, ...matchN, outputN, fallback]` compares the `input` value against all
   *     provided `matchX` values, returning the output associated with the first valid match. If no match is found,
   *     returns the `fallback` value.
   *     `input` and `matchX` values must all be of the same type, and can be `number` or `string`. `outputX` and
   *     `fallback` values must be of the same type, and can be of any kind.
   *   * `['interpolate', interpolation, input, stop1, output1, ...stopN, outputN]` returns a value by interpolating between
   *     pairs of inputs and outputs; `interpolation` can either be `['linear']` or `['exponential', base]` where `base` is
   *     the rate of increase from stop A to stop B (i.e. power to which the interpolation ratio is raised); a value
   *     of 1 is equivalent to `['linear']`.
   *     `input` and `stopX` values must all be of type `number`. `outputX` values can be `number` or `color` values.
   *     Note: `input` will be clamped between `stop1` and `stopN`, meaning that all output values will be comprised
   *     between `output1` and `outputN`.
   *
   * * Logical operators:
   *   * `['<', value1, value2]` returns `true` if `value1` is strictly lower than `value2`, or `false` otherwise.
   *   * `['<=', value1, value2]` returns `true` if `value1` is lower than or equals `value2`, or `false` otherwise.
   *   * `['>', value1, value2]` returns `true` if `value1` is strictly greater than `value2`, or `false` otherwise.
   *   * `['>=', value1, value2]` returns `true` if `value1` is greater than or equals `value2`, or `false` otherwise.
   *   * `['==', value1, value2]` returns `true` if `value1` equals `value2`, or `false` otherwise.
   *   * `['!=', value1, value2]` returns `true` if `value1` does not equal `value2`, or `false` otherwise.
   *   * `['!', value1]` returns `false` if `value1` is `true` or greater than `0`, or `true` otherwise.
   *   * `['all', value1, value2, ...]` returns `true` if all the inputs are `true`, `false` otherwise.
   *   * `['any', value1, value2, ...]` returns `true` if any of the inputs are `true`, `false` otherwise.
   *   * `['between', value1, value2, value3]` returns `true` if `value1` is contained between `value2` and `value3`
   *     (inclusively), or `false` otherwise.
   *
   * * Conversion operators:
   *   * `['array', value1, ...valueN]` creates a numerical array from `number` values; please note that the amount of
   *     values can currently only be 2, 3 or 4.
   *   * `['color', red, green, blue, alpha]` creates a `color` value from `number` values; the `alpha` parameter is
   *     optional; if not specified, it will be set to 1.
   *     Note: `red`, `green` and `blue` components must be values between 0 and 255; `alpha` between 0 and 1.
   *   * `['palette', index, colors]` picks a `color` value from an array of colors using the given index; the `index`
   *     expression must evaluate to a number; the items in the `colors` array must be strings with hex colors
   *     (e.g. `'#86A136'`), colors using the rgba[a] functional notation (e.g. `'rgb(134, 161, 54)'` or `'rgba(134, 161, 54, 1)'`),
   *     named colors (e.g. `'red'`), or array literals with 3 ([r, g, b]) or 4 ([r, g, b, a]) values (with r, g, and b
   *     in the 0-255 range and a in the 0-1 range).
   *
   * Values can either be literals or another operator, as they will be evaluated recursively.
   * Literal values can be of the following types:
   * * `boolean`
   * * `number`
   * * `string`
   * * {@link module:ol/color~Color}
   *
   * @typedef {Array<*>|import("../color.js").Color|string|number|boolean} ExpressionValue
   * @api
   */

  /**
   * Possible inferred types from a given value or expression.
   * Note: these are binary flags.
   * @enum {number}
   */

  var ValueTypes = {
    NUMBER: 1,
    STRING: 2,
    COLOR: 4,
    BOOLEAN: 8,
    NUMBER_ARRAY: 16,
    ANY: 31,
    NONE: 0
  };
  /**
   * An operator declaration must contain two methods: `getReturnType` which returns a type based on
   * the operator arguments, and `toGlsl` which returns a GLSL-compatible string.
   * Note: both methods can process arguments recursively.
   * @typedef {Object} Operator
   * @property {function(Array<ExpressionValue>): ValueTypes|number} getReturnType Returns one or several types
   * @property {function(ParsingContext, Array<ExpressionValue>, ValueTypes=): string} toGlsl Returns a GLSL-compatible string
   * Note: takes in an optional type hint as 3rd parameter
   */

  /**
   * Operator declarations
   * @type {Object<string, Operator>}
   */

  var Operators = {};
  /**
   * Returns the possible types for a given value (each type being a binary flag)
   * To test a value use e.g. `getValueType(v) & ValueTypes.BOOLEAN`
   * @param {ExpressionValue} value Value
   * @return {ValueTypes|number} Type or types inferred from the value
   */

  function getValueType(value) {
    if (typeof value === 'number') {
      return ValueTypes.NUMBER;
    }

    if (typeof value === 'boolean') {
      return ValueTypes.BOOLEAN;
    }

    if (typeof value === 'string') {
      if (isStringColor(value)) {
        return ValueTypes.COLOR | ValueTypes.STRING;
      }

      return ValueTypes.STRING;
    }

    if (!Array.isArray(value)) {
      throw new Error("Unhandled value type: ".concat(JSON.stringify(value)));
    }

    var valueArr =
    /** @type {Array<*>} */
    value;
    var onlyNumbers = valueArr.every(function (v) {
      return typeof v === 'number';
    });

    if (onlyNumbers) {
      if (valueArr.length === 3 || valueArr.length === 4) {
        return ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY;
      }

      return ValueTypes.NUMBER_ARRAY;
    }

    if (typeof valueArr[0] !== 'string') {
      throw new Error("Expected an expression operator but received: ".concat(JSON.stringify(valueArr)));
    }

    var operator = Operators[valueArr[0]];

    if (operator === undefined) {
      throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(valueArr)));
    }

    return operator.getReturnType(valueArr.slice(1));
  }
  /**
   * Checks if only one value type is enabled in the input number.
   * @param {ValueTypes|number} valueType Number containing value type binary flags
   * @return {boolean} True if only one type flag is enabled, false if zero or multiple
   */

  function isTypeUnique(valueType) {
    return Math.log2(valueType) % 1 === 0;
  }
  /**
   * Context available during the parsing of an expression.
   * @typedef {Object} ParsingContext
   * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader
   * @property {Array<string>} variables List of variables used in the expression; contains **unprefixed names**
   * @property {Array<string>} attributes List of attributes used in the expression; contains **unprefixed names**
   * @property {Object<string, number>} stringLiteralsMap This object maps all encountered string values to a number
   * @property {Object<string, string>} functions Lookup of functions used by the style.
   * @property {number} [bandCount] Number of bands per pixel.
   * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.
   */

  /**
   * Will return the number as a float with a dot separator, which is required by GLSL.
   * @param {number} v Numerical value.
   * @return {string} The value as string.
   */

  function numberToGlsl(v) {
    var s = v.toString();
    return s.includes('.') ? s : s + '.0';
  }
  /**
   * Will return the number array as a float with a dot separator, concatenated with ', '.
   * @param {Array<number>} array Numerical values array.
   * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.
   */

  function arrayToGlsl(array) {
    if (array.length < 2 || array.length > 4) {
      throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');
    }

    return "vec".concat(array.length, "(").concat(array.map(numberToGlsl).join(', '), ")");
  }
  /**
   * Will normalize and converts to string a `vec4` color array compatible with GLSL.
   * @param {string|import("../color.js").Color} color Color either in string format or [r, g, b, a] array format,
   * with RGB components in the 0..255 range and the alpha component in the 0..1 range.
   * Note that the final array will always have 4 components.
   * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.
   */

  function colorToGlsl(color) {
    var array = asArray(color).slice();

    if (array.length < 4) {
      array.push(1);
    }

    return arrayToGlsl(array.map(function (c, i) {
      return i < 3 ? c / 255 : c;
    }));
  }
  /**
   * Returns a stable equivalent number for the string literal.
   * @param {ParsingContext} context Parsing context
   * @param {string} string String literal value
   * @return {number} Number equivalent
   */

  function getStringNumberEquivalent(context, string) {
    if (context.stringLiteralsMap[string] === undefined) {
      context.stringLiteralsMap[string] = Object.keys(context.stringLiteralsMap).length;
    }

    return context.stringLiteralsMap[string];
  }
  /**
   * Returns a stable equivalent number for the string literal, for use in shaders. This number is then
   * converted to be a GLSL-compatible string.
   * @param {ParsingContext} context Parsing context
   * @param {string} string String literal value
   * @return {string} GLSL-compatible string containing a number
   */

  function stringToGlsl(context, string) {
    return numberToGlsl(getStringNumberEquivalent(context, string));
  }
  /**
   * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a parsing context that
   * will be read and modified during the parsing operation.
   * @param {ParsingContext} context Parsing context
   * @param {ExpressionValue} value Value
   * @param {ValueTypes|number} [typeHint] Hint for the expected final type (can be several types combined)
   * @return {string} GLSL-compatible output
   */

  function expressionToGlsl(context, value, typeHint) {
    // operator
    if (Array.isArray(value) && typeof value[0] === 'string') {
      var operator = Operators[value[0]];

      if (operator === undefined) {
        throw new Error("Unrecognized expression operator: ".concat(JSON.stringify(value)));
      }

      return operator.toGlsl(context, value.slice(1), typeHint);
    }

    var valueType = getValueType(value);

    if ((valueType & ValueTypes.NUMBER) > 0) {
      return numberToGlsl(
      /** @type {number} */
      value);
    }

    if ((valueType & ValueTypes.BOOLEAN) > 0) {
      return value.toString();
    }

    if ((valueType & ValueTypes.STRING) > 0 && (typeHint === undefined || typeHint == ValueTypes.STRING)) {
      return stringToGlsl(context, value.toString());
    }

    if ((valueType & ValueTypes.COLOR) > 0 && (typeHint === undefined || typeHint == ValueTypes.COLOR)) {
      return colorToGlsl(
      /** @type {Array<number> | string} */
      value);
    }

    if ((valueType & ValueTypes.NUMBER_ARRAY) > 0) {
      return arrayToGlsl(
      /** @type {Array<number>} */
      value);
    }

    throw new Error("Unexpected expression ".concat(value, " (expected type ").concat(typeHint, ")"));
  }

  function assertNumber(value) {
    if (!(getValueType(value) & ValueTypes.NUMBER)) {
      throw new Error("A numeric value was expected, got ".concat(JSON.stringify(value), " instead"));
    }
  }

  function assertNumbers(values) {
    for (var i = 0; i < values.length; i++) {
      assertNumber(values[i]);
    }
  }

  function assertString(value) {
    if (!(getValueType(value) & ValueTypes.STRING)) {
      throw new Error("A string value was expected, got ".concat(JSON.stringify(value), " instead"));
    }
  }

  function assertBoolean(value) {
    if (!(getValueType(value) & ValueTypes.BOOLEAN)) {
      throw new Error("A boolean value was expected, got ".concat(JSON.stringify(value), " instead"));
    }
  }

  function assertArgsCount(args, count) {
    if (args.length !== count) {
      throw new Error("Exactly ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
    }
  }

  function assertArgsMinCount(args, count) {
    if (args.length < count) {
      throw new Error("At least ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
    }
  }

  function assertArgsMaxCount(args, count) {
    if (args.length > count) {
      throw new Error("At most ".concat(count, " arguments were expected, got ").concat(args.length, " instead"));
    }
  }

  function assertArgsEven(args) {
    if (args.length % 2 !== 0) {
      throw new Error("An even amount of arguments was expected, got ".concat(args, " instead"));
    }
  }

  function assertArgsOdd(args) {
    if (args.length % 2 === 0) {
      throw new Error("An odd amount of arguments was expected, got ".concat(args, " instead"));
    }
  }

  function assertUniqueInferredType(args, types) {
    if (!isTypeUnique(types)) {
      throw new Error("Could not infer only one type from the following expression: ".concat(JSON.stringify(args)));
    }
  }

  Operators['get'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.ANY;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertString(args[0]);
      var value = args[0].toString();

      if (!context.attributes.includes(value)) {
        context.attributes.push(value);
      }

      var prefix = context.inFragmentShader ? 'v_' : 'a_';
      return prefix + value;
    }
  };
  /**
   * Get the uniform name given a variable name.
   * @param {string} variableName The variable name.
   * @return {string} The uniform name.
   */

  function uniformNameForVariable(variableName) {
    return 'u_var_' + variableName;
  }
  Operators['var'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.ANY;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertString(args[0]);
      var value = args[0].toString();

      if (!context.variables.includes(value)) {
        context.variables.push(value);
      }

      return uniformNameForVariable(value);
    }
  };
  var PALETTE_TEXTURE_ARRAY = 'u_paletteTextures'; // ['palette', index, colors]

  Operators['palette'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.COLOR;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumber(args[0]);
      var index = expressionToGlsl(context, args[0]);
      var colors = args[1];

      if (!Array.isArray(colors)) {
        throw new Error('The second argument of palette must be an array');
      }

      var numColors = colors.length;
      var palette = new Uint8Array(numColors * 4);

      for (var i = 0; i < numColors; i++) {
        var candidate = colors[i];
        /**
         * @type {import('../color.js').Color}
         */

        var color = void 0;

        if (typeof candidate === 'string') {
          color = fromString(candidate);
        } else {
          if (!Array.isArray(candidate)) {
            throw new Error('The second argument of palette must be an array of strings or colors');
          }

          var length = candidate.length;

          if (length === 4) {
            color = candidate;
          } else {
            if (length !== 3) {
              throw new Error("Expected palette color to have 3 or 4 values, got ".concat(length));
            }

            color = [candidate[0], candidate[1], candidate[2], 1];
          }
        }

        var offset = i * 4;
        palette[offset] = color[0];
        palette[offset + 1] = color[1];
        palette[offset + 2] = color[2];
        palette[offset + 3] = color[3] * 255;
      }

      if (!context.paletteTextures) {
        context.paletteTextures = [];
      }

      var paletteName = "".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "]");
      var paletteTexture = new PaletteTexture(paletteName, palette);
      context.paletteTextures.push(paletteTexture);
      return "texture2D(".concat(paletteName, ", vec2((").concat(index, " + 0.5) / ").concat(numColors, ".0, 0.5))");
    }
  };
  var GET_BAND_VALUE_FUNC = 'getBandValue';
  Operators['band'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsMinCount(args, 1);
      assertArgsMaxCount(args, 3);
      var band = args[0];

      if (!(GET_BAND_VALUE_FUNC in context.functions)) {
        var ifBlocks = '';
        var bandCount = context.bandCount || 1;

        for (var i = 0; i < bandCount; i++) {
          var colorIndex = Math.floor(i / 4);
          var bandIndex = i % 4;

          if (i === bandCount - 1 && bandIndex === 1) {
            // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha
            bandIndex = 3;
          }

          var textureName = "".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(colorIndex, "]");
          ifBlocks += "\n          if (band == ".concat(i + 1, ".0) {\n            return texture2D(").concat(textureName, ", v_textureCoord + vec2(dx, dy))[").concat(bandIndex, "];\n          }\n        ");
        }

        context.functions[GET_BAND_VALUE_FUNC] = "\n        float getBandValue(float band, float xOffset, float yOffset) {\n          float dx = xOffset / ".concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n          float dy = yOffset / ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n          ").concat(ifBlocks, "\n        }\n      ");
      }

      var bandExpression = expressionToGlsl(context, band);
      var xOffsetExpression = expressionToGlsl(context, args[1] || 0);
      var yOffsetExpression = expressionToGlsl(context, args[2] || 0);
      return "".concat(GET_BAND_VALUE_FUNC, "(").concat(bandExpression, ", ").concat(xOffsetExpression, ", ").concat(yOffsetExpression, ")");
    }
  };
  Operators['time'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 0);
      return 'u_time';
    }
  };
  Operators['zoom'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 0);
      return 'u_zoom';
    }
  };
  Operators['resolution'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 0);
      return 'u_resolution';
    }
  };
  Operators['*'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " * ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['/'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " / ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['+'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " + ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['-'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " - ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['clamp'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 3);
      assertNumbers(args);
      var min = expressionToGlsl(context, args[1]);
      var max = expressionToGlsl(context, args[2]);
      return "clamp(".concat(expressionToGlsl(context, args[0]), ", ").concat(min, ", ").concat(max, ")");
    }
  };
  Operators['%'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "mod(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['^'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "pow(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['abs'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "abs(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['floor'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "floor(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['round'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "floor(".concat(expressionToGlsl(context, args[0]), " + 0.5)");
    }
  };
  Operators['ceil'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "ceil(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['sin'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "sin(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['cos'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertNumbers(args);
      return "cos(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['atan'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsMinCount(args, 1);
      assertArgsMaxCount(args, 2);
      assertNumbers(args);
      return args.length === 2 ? "atan(".concat(expressionToGlsl(context, args[0]), ", ").concat(expressionToGlsl(context, args[1]), ")") : "atan(".concat(expressionToGlsl(context, args[0]), ")");
    }
  };
  Operators['>'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " > ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['>='] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " >= ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['<'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " < ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };
  Operators['<='] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 2);
      assertNumbers(args);
      return "(".concat(expressionToGlsl(context, args[0]), " <= ").concat(expressionToGlsl(context, args[1]), ")");
    }
  };

  function getEqualOperator(operator) {
    return {
      getReturnType: function getReturnType(args) {
        return ValueTypes.BOOLEAN;
      },
      toGlsl: function toGlsl(context, args) {
        assertArgsCount(args, 2); // find common type

        var type = ValueTypes.ANY;

        for (var i = 0; i < args.length; i++) {
          type &= getValueType(args[i]);
        }

        if (type === ValueTypes.NONE) {
          throw new Error("All arguments should be of compatible type, got ".concat(JSON.stringify(args), " instead"));
        } // Since it's not possible to have color types here, we can leave it out
        // This fixes issues in case the value type is ambiguously detected as a color (e.g. the string 'red')


        type &= ~ValueTypes.COLOR;
        return "(".concat(expressionToGlsl(context, args[0], type), " ").concat(operator, " ").concat(expressionToGlsl(context, args[1], type), ")");
      }
    };
  }

  Operators['=='] = getEqualOperator('==');
  Operators['!='] = getEqualOperator('!=');
  Operators['!'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 1);
      assertBoolean(args[0]);
      return "(!".concat(expressionToGlsl(context, args[0]), ")");
    }
  };

  function getDecisionOperator(operator) {
    return {
      getReturnType: function getReturnType(args) {
        return ValueTypes.BOOLEAN;
      },
      toGlsl: function toGlsl(context, args) {
        assertArgsMinCount(args, 2);

        for (var i = 0; i < args.length; i++) {
          assertBoolean(args[i]);
        }

        var result = '';
        result = args.map(function (arg) {
          return expressionToGlsl(context, arg);
        }).join(" ".concat(operator, " "));
        result = "(".concat(result, ")");
        return result;
      }
    };
  }

  Operators['all'] = getDecisionOperator('&&');
  Operators['any'] = getDecisionOperator('||');
  Operators['between'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.BOOLEAN;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsCount(args, 3);
      assertNumbers(args);
      var min = expressionToGlsl(context, args[1]);
      var max = expressionToGlsl(context, args[2]);
      var value = expressionToGlsl(context, args[0]);
      return "(".concat(value, " >= ").concat(min, " && ").concat(value, " <= ").concat(max, ")");
    }
  };
  Operators['array'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.NUMBER_ARRAY;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsMinCount(args, 2);
      assertArgsMaxCount(args, 4);
      assertNumbers(args);
      var parsedArgs = args.map(function (val) {
        return expressionToGlsl(context, val, ValueTypes.NUMBER);
      });
      return "vec".concat(args.length, "(").concat(parsedArgs.join(', '), ")");
    }
  };
  Operators['color'] = {
    getReturnType: function getReturnType(args) {
      return ValueTypes.COLOR;
    },
    toGlsl: function toGlsl(context, args) {
      assertArgsMinCount(args, 3);
      assertArgsMaxCount(args, 4);
      assertNumbers(args);
      var array =
      /** @type {Array<number>} */
      args;

      if (args.length === 3) {
        array.push(1);
      }

      var parsedArgs = args.map(function (val, i) {
        return expressionToGlsl(context, val, ValueTypes.NUMBER) + (i < 3 ? ' / 255.0' : '');
      });
      return "vec".concat(args.length, "(").concat(parsedArgs.join(', '), ")");
    }
  };
  Operators['interpolate'] = {
    getReturnType: function getReturnType(args) {
      var type = ValueTypes.COLOR | ValueTypes.NUMBER;

      for (var i = 3; i < args.length; i += 2) {
        type = type & getValueType(args[i]);
      }

      return type;
    },
    toGlsl: function toGlsl(context, args, typeHint) {
      assertArgsEven(args);
      assertArgsMinCount(args, 6); // validate interpolation type

      var type = args[0];
      var interpolation;

      switch (type[0]) {
        case 'linear':
          interpolation = 1;
          break;

        case 'exponential':
          interpolation = type[1];
          break;

        default:
          interpolation = null;
      }

      if (!interpolation) {
        throw new Error("Invalid interpolation type for \"interpolate\" operator, received: ".concat(JSON.stringify(type)));
      } // compute input/output types


      typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;
      var outputType = Operators['interpolate'].getReturnType(args) & typeHint;
      assertUniqueInferredType(args, outputType);
      var input = expressionToGlsl(context, args[1]);
      var exponent = numberToGlsl(interpolation);
      var result = '';

      for (var i = 2; i < args.length - 2; i += 2) {
        var stop1 = expressionToGlsl(context, args[i]);
        var output1 = result || expressionToGlsl(context, args[i + 1], outputType);
        var stop2 = expressionToGlsl(context, args[i + 2]);
        var output2 = expressionToGlsl(context, args[i + 3], outputType);
        result = "mix(".concat(output1, ", ").concat(output2, ", pow(clamp((").concat(input, " - ").concat(stop1, ") / (").concat(stop2, " - ").concat(stop1, "), 0.0, 1.0), ").concat(exponent, "))");
      }

      return result;
    }
  };
  Operators['match'] = {
    getReturnType: function getReturnType(args) {
      var type = ValueTypes.ANY;

      for (var i = 2; i < args.length; i += 2) {
        type = type & getValueType(args[i]);
      }

      type = type & getValueType(args[args.length - 1]);
      return type;
    },
    toGlsl: function toGlsl(context, args, typeHint) {
      assertArgsEven(args);
      assertArgsMinCount(args, 4);
      typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;
      var outputType = Operators['match'].getReturnType(args) & typeHint;
      assertUniqueInferredType(args, outputType);
      var input = expressionToGlsl(context, args[0]);
      var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
      var result = null;

      for (var i = args.length - 3; i >= 1; i -= 2) {
        var match = expressionToGlsl(context, args[i]);
        var output = expressionToGlsl(context, args[i + 1], outputType);
        result = "(".concat(input, " == ").concat(match, " ? ").concat(output, " : ").concat(result || fallback, ")");
      }

      return result;
    }
  };
  Operators['case'] = {
    getReturnType: function getReturnType(args) {
      var type = ValueTypes.ANY;

      for (var i = 1; i < args.length; i += 2) {
        type = type & getValueType(args[i]);
      }

      type = type & getValueType(args[args.length - 1]);
      return type;
    },
    toGlsl: function toGlsl(context, args, typeHint) {
      assertArgsOdd(args);
      assertArgsMinCount(args, 3);
      typeHint = typeHint !== undefined ? typeHint : ValueTypes.ANY;
      var outputType = Operators['case'].getReturnType(args) & typeHint;
      assertUniqueInferredType(args, outputType);

      for (var i = 0; i < args.length - 1; i += 2) {
        assertBoolean(args[i]);
      }

      var fallback = expressionToGlsl(context, args[args.length - 1], outputType);
      var result = null;

      for (var _i = args.length - 3; _i >= 0; _i -= 2) {
        var condition = expressionToGlsl(context, args[_i]);
        var output = expressionToGlsl(context, args[_i + 1], outputType);
        result = "(".concat(condition, " ? ").concat(output, " : ").concat(result || fallback, ")");
      }

      return result;
    }
  };

  /**
   * @typedef {import("../source/DataTile.js").default|import("../source/TileImage.js").default} SourceType
   */

  /**
   * @typedef {Object} Style
   * Translates tile data to rendered pixels.
   *
   * @property {Object<string, (string|number)>} [variables] Style variables.  Each variable must hold a number or string.  These
   * variables can be used in the `color`, `brightness`, `contrast`, `exposure`, `saturation` and `gamma`
   * {@link import("../style/expressions.js").ExpressionValue expressions}, using the `['var', 'varName']` operator.
   * To update style variables, use the {@link import("./WebGLTile.js").default#updateStyleVariables} method.
   * @property {import("../style/expressions.js").ExpressionValue} [color] An expression applied to color values.
   * @property {import("../style/expressions.js").ExpressionValue} [brightness=0] Value used to decrease or increase
   * the layer brightness.  Values range from -1 to 1.
   * @property {import("../style/expressions.js").ExpressionValue} [contrast=0] Value used to decrease or increase
   * the layer contrast.  Values range from -1 to 1.
   * @property {import("../style/expressions.js").ExpressionValue} [exposure=0] Value used to decrease or increase
   * the layer exposure.  Values range from -1 to 1.
   * @property {import("../style/expressions.js").ExpressionValue} [saturation=0] Value used to decrease or increase
   * the layer saturation.  Values range from -1 to 1.
   * @property {import("../style/expressions.js").ExpressionValue} [gamma=1] Apply a gamma correction to the layer.
   * Values range from 0 to infinity.
   */

  /**
   * @typedef {Object} Options
   * @property {Style} [style] Style to apply to the layer.
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
   * means no preloading.
   * @property {SourceType} [source] Source for this layer.
   * @property {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>} [sources] Array
   * of sources for this layer. Takes precedence over `source`. Can either be an array of sources, or a function that
   * expects an extent and a resolution (in view projection units per pixel) and returns an array of sources. See
   * {@link module:ol/source.sourcesFromTileGrid} for a helper function to generate sources that are organized in a
   * pyramid following the same pattern as a tile grid. **Note:** All sources must have the same band count and content.
   * @property {import("../Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map~Map#addLayer}.
   * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
   * @property {number} [cacheSize=512] The internal texture cache size.  This needs to be large enough to render
   * two zoom levels worth of tiles.
   */

  /**
   * @typedef {Object} ParsedStyle
   * @property {string} vertexShader The vertex shader.
   * @property {string} fragmentShader The fragment shader.
   * @property {Object<string,import("../webgl/Helper.js").UniformValue>} uniforms Uniform definitions.
   * @property {Array<import("../webgl/PaletteTexture.js").default>} paletteTextures Palette textures.
   */

  /**
   * @param {Style} style The layer style.
   * @param {number} [bandCount] The number of bands.
   * @return {ParsedStyle} Shaders and uniforms generated from the style.
   */

  function parseStyle(style, bandCount) {
    var vertexShader = "\n    attribute vec2 ".concat(Attributes.TEXTURE_COORD, ";\n    uniform mat4 ").concat(Uniforms.TILE_TRANSFORM, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.TEXTURE_RESOLUTION, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_X, ";\n    uniform float ").concat(Uniforms.TEXTURE_ORIGIN_Y, ";\n    uniform float ").concat(Uniforms.DEPTH, ";\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n\n    void main() {\n      v_textureCoord = ").concat(Attributes.TEXTURE_COORD, ";\n      v_mapCoord = vec2(\n        ").concat(Uniforms.TEXTURE_ORIGIN_X, " + ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, " * v_textureCoord[0],\n        ").concat(Uniforms.TEXTURE_ORIGIN_Y, " - ").concat(Uniforms.TEXTURE_RESOLUTION, " * ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, " * v_textureCoord[1]\n      );\n      gl_Position = ").concat(Uniforms.TILE_TRANSFORM, " * vec4(").concat(Attributes.TEXTURE_COORD, ", ").concat(Uniforms.DEPTH, ", 1.0);\n    }\n  ");
    /**
     * @type {import("../style/expressions.js").ParsingContext}
     */

    var context = {
      inFragmentShader: true,
      variables: [],
      attributes: [],
      stringLiteralsMap: {},
      functions: {},
      bandCount: bandCount
    };
    var pipeline = [];

    if (style.color !== undefined) {
      var color = expressionToGlsl(context, style.color, ValueTypes.COLOR);
      pipeline.push("color = ".concat(color, ";"));
    }

    if (style.contrast !== undefined) {
      var contrast = expressionToGlsl(context, style.contrast, ValueTypes.NUMBER);
      pipeline.push("color.rgb = clamp((".concat(contrast, " + 1.0) * color.rgb - (").concat(contrast, " / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
    }

    if (style.exposure !== undefined) {
      var exposure = expressionToGlsl(context, style.exposure, ValueTypes.NUMBER);
      pipeline.push("color.rgb = clamp((".concat(exposure, " + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
    }

    if (style.saturation !== undefined) {
      var saturation = expressionToGlsl(context, style.saturation, ValueTypes.NUMBER);
      pipeline.push("\n      float saturation = ".concat(saturation, " + 1.0;\n      float sr = (1.0 - saturation) * 0.2126;\n      float sg = (1.0 - saturation) * 0.7152;\n      float sb = (1.0 - saturation) * 0.0722;\n      mat3 saturationMatrix = mat3(\n        sr + saturation, sr, sr,\n        sg, sg + saturation, sg,\n        sb, sb, sb + saturation\n      );\n      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    "));
    }

    if (style.gamma !== undefined) {
      var gamma = expressionToGlsl(context, style.gamma, ValueTypes.NUMBER);
      pipeline.push("color.rgb = pow(color.rgb, vec3(1.0 / ".concat(gamma, "));"));
    }

    if (style.brightness !== undefined) {
      var brightness = expressionToGlsl(context, style.brightness, ValueTypes.NUMBER);
      pipeline.push("color.rgb = clamp(color.rgb + ".concat(brightness, ", vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));"));
    }
    /** @type {Object<string,import("../webgl/Helper").UniformValue>} */


    var uniforms = {};
    var numVariables = context.variables.length;

    if (numVariables > 1 && !style.variables) {
      throw new Error("Missing variables in style (expected ".concat(context.variables, ")"));
    }

    var _loop = function _loop(i) {
      var variableName = context.variables[i];

      if (!(variableName in style.variables)) {
        throw new Error("Missing '".concat(variableName, "' in style variables"));
      }

      var uniformName = uniformNameForVariable(variableName);

      uniforms[uniformName] = function () {
        var value = style.variables[variableName];

        if (typeof value === 'string') {
          value = getStringNumberEquivalent(context, value);
        }

        return value !== undefined ? value : -9999999; // to avoid matching with the first string literal
      };
    };

    for (var i = 0; i < numVariables; ++i) {
      _loop(i);
    }

    var uniformDeclarations = Object.keys(uniforms).map(function (name) {
      return "uniform float ".concat(name, ";");
    });
    var textureCount = Math.ceil(bandCount / 4);
    uniformDeclarations.push("uniform sampler2D ".concat(Uniforms.TILE_TEXTURE_ARRAY, "[").concat(textureCount, "];"));

    if (context.paletteTextures) {
      uniformDeclarations.push("uniform sampler2D ".concat(PALETTE_TEXTURE_ARRAY, "[").concat(context.paletteTextures.length, "];"));
    }

    var functionDefintions = Object.keys(context.functions).map(function (name) {
      return context.functions[name];
    });
    var fragmentShader = "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n    #else\n    precision mediump float;\n    #endif\n\n    varying vec2 v_textureCoord;\n    varying vec2 v_mapCoord;\n    uniform vec4 ".concat(Uniforms.RENDER_EXTENT, ";\n    uniform float ").concat(Uniforms.TRANSITION_ALPHA, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_WIDTH, ";\n    uniform float ").concat(Uniforms.TEXTURE_PIXEL_HEIGHT, ";\n    uniform float ").concat(Uniforms.RESOLUTION, ";\n    uniform float ").concat(Uniforms.ZOOM, ";\n\n    ").concat(uniformDeclarations.join('\n'), "\n\n    ").concat(functionDefintions.join('\n'), "\n\n    void main() {\n      if (\n        v_mapCoord[0] < ").concat(Uniforms.RENDER_EXTENT, "[0] ||\n        v_mapCoord[1] < ").concat(Uniforms.RENDER_EXTENT, "[1] ||\n        v_mapCoord[0] > ").concat(Uniforms.RENDER_EXTENT, "[2] ||\n        v_mapCoord[1] > ").concat(Uniforms.RENDER_EXTENT, "[3]\n      ) {\n        discard;\n      }\n\n      vec4 color = texture2D(").concat(Uniforms.TILE_TEXTURE_ARRAY, "[0],  v_textureCoord);\n\n      ").concat(pipeline.join('\n'), "\n\n      if (color.a == 0.0) {\n        discard;\n      }\n\n      gl_FragColor = color;\n      gl_FragColor.rgb *= gl_FragColor.a;\n      gl_FragColor *= ").concat(Uniforms.TRANSITION_ALPHA, ";\n    }");
    return {
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      uniforms: uniforms,
      paletteTextures: context.paletteTextures
    };
  }
  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends BaseTileLayer<SourceType, WebGLTileLayerRenderer>
   * @fires import("../render/Event.js").RenderEvent
   * @api
   */


  var WebGLTileLayer = /*#__PURE__*/function (_BaseTileLayer) {
    _inherits(WebGLTileLayer, _BaseTileLayer);

    var _super = _createSuper(WebGLTileLayer);

    /**
     * @param {Options} options Tile layer options.
     */
    function WebGLTileLayer(options) {
      var _this;

      _classCallCheck(this, WebGLTileLayer);

      options = options ? Object.assign({}, options) : {};
      var style = options.style || {};
      delete options.style;
      var cacheSize = options.cacheSize;
      delete options.cacheSize;
      _this = _super.call(this, options);
      /**
       * @type {Array<SourceType>|function(import("../extent.js").Extent, number):Array<SourceType>}
       * @private
       */

      _this.sources_ = options.sources;
      /**
       * @type {SourceType|null}
       * @private
       */

      _this.renderedSource_ = null;
      /**
       * @type {number}
       * @private
       */

      _this.renderedResolution_ = NaN;
      /**
       * @type {Style}
       * @private
       */

      _this.style_ = style;
      /**
       * @type {number}
       * @private
       */

      _this.cacheSize_ = cacheSize;
      /**
       * @type {Object<string, (string|number)>}
       * @private
       */

      _this.styleVariables_ = _this.style_.variables || {};

      _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourceUpdate_);

      return _this;
    }
    /**
     * Gets the sources for this layer, for a given extent and resolution.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<SourceType>} Sources.
     */


    _createClass(WebGLTileLayer, [{
      key: "getSources",
      value: function getSources(extent, resolution) {
        var source = this.getSource();
        return this.sources_ ? typeof this.sources_ === 'function' ? this.sources_(extent, resolution) : this.sources_ : source ? [source] : [];
      }
      /**
       * @return {SourceType} The source being rendered.
       */

    }, {
      key: "getRenderSource",
      value: function getRenderSource() {
        return this.renderedSource_ || this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */

    }, {
      key: "getSourceState",
      value: function getSourceState() {
        var source = this.getRenderSource();
        return source ? source.getState() : 'undefined';
      }
      /**
       * @private
       */

    }, {
      key: "handleSourceUpdate_",
      value: function handleSourceUpdate_() {
        if (this.hasRenderer()) {
          this.getRenderer().clearCache();
        }

        if (this.getSource()) {
          this.setStyle(this.style_);
        }
      }
      /**
       * @private
       * @return {number} The number of source bands.
       */

    }, {
      key: "getSourceBandCount_",
      value: function getSourceBandCount_() {
        var max = Number.MAX_SAFE_INTEGER;
        var sources = this.getSources([-max, -max, max, max], max);
        return sources && sources.length && 'bandCount' in sources[0] ? sources[0].bandCount : 4;
      }
    }, {
      key: "createRenderer",
      value: function createRenderer() {
        var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
        return new WebGLTileLayerRenderer(this, {
          vertexShader: parsedStyle.vertexShader,
          fragmentShader: parsedStyle.fragmentShader,
          uniforms: parsedStyle.uniforms,
          cacheSize: this.cacheSize_,
          paletteTextures: parsedStyle.paletteTextures
        });
      }
      /**
       * @param {import("../Map").FrameState} frameState Frame state.
       * @param {Array<SourceType>} sources Sources.
       * @return {HTMLElement} Canvas.
       */

    }, {
      key: "renderSources",
      value: function renderSources(frameState, sources) {
        var layerRenderer = this.getRenderer();
        var canvas;

        for (var i = 0, ii = sources.length; i < ii; ++i) {
          this.renderedSource_ = sources[i];

          if (layerRenderer.prepareFrame(frameState)) {
            canvas = layerRenderer.renderFrame(frameState);
          }
        }

        return canvas;
      }
      /**
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement} The rendered element.
       */

    }, {
      key: "render",
      value: function render(frameState, target) {
        var _this2 = this;

        this.rendered = true;
        var viewState = frameState.viewState;
        var sources = this.getSources(frameState.extent, viewState.resolution);
        var ready = true;

        var _loop2 = function _loop2(i, ii) {
          var source = sources[i];
          var sourceState = source.getState();

          if (sourceState == 'loading') {
            var onChange = function onChange() {
              if (source.getState() == 'ready') {
                source.removeEventListener('change', onChange);

                _this2.changed();
              }
            };

            source.addEventListener('change', onChange);
          }

          ready = ready && sourceState == 'ready';
        };

        for (var i = 0, ii = sources.length; i < ii; ++i) {
          _loop2(i);
        }

        var canvas = this.renderSources(frameState, sources);

        if (this.getRenderer().renderComplete && ready) {
          // Fully rendered, done.
          this.renderedResolution_ = viewState.resolution;
          return canvas;
        } // Render sources from previously fully rendered frames


        if (this.renderedResolution_ > 0.5 * viewState.resolution) {
          var altSources = this.getSources(frameState.extent, this.renderedResolution_).filter(function (source) {
            return !sources.includes(source);
          });

          if (altSources.length > 0) {
            return this.renderSources(frameState, altSources);
          }
        }

        return canvas;
      }
      /**
       * Update the layer style.  The `updateStyleVariables` function is a more efficient
       * way to update layer rendering.  In cases where the whole style needs to be updated,
       * this method may be called instead.  Note that calling this method will also replace
       * any previously set variables, so the new style also needs to include new variables,
       * if needed.
       * @param {Style} style The new style.
       */

    }, {
      key: "setStyle",
      value: function setStyle(style) {
        this.styleVariables_ = style.variables || {};
        this.style_ = style;
        var parsedStyle = parseStyle(this.style_, this.getSourceBandCount_());
        var renderer = this.getRenderer();
        renderer.reset({
          vertexShader: parsedStyle.vertexShader,
          fragmentShader: parsedStyle.fragmentShader,
          uniforms: parsedStyle.uniforms,
          paletteTextures: parsedStyle.paletteTextures
        });
        this.changed();
      }
      /**
       * Update any variables used by the layer style and trigger a re-render.
       * @param {Object<string, number>} variables Variables to update.
       * @api
       */

    }, {
      key: "updateStyleVariables",
      value: function updateStyleVariables(variables) {
        Object.assign(this.styleVariables_, variables);
        this.changed();
      }
    }]);

    return WebGLTileLayer;
  }(BaseTileLayer);
  /**
   * Clean up underlying WebGL resources.
   * @function
   * @api
   */


  WebGLTileLayer.prototype.dispose;

  window.addEventListener('load', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var source, rasterLayer;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // const response = await fetch('features.json');
            // const fc = await response.json();
            // const vectorSource = new VectorSource({
            //     features: new GeoJSON().readFeatures(fc),
            // });
            // const styles = {
            //     /*'Point': new Style({
            //         image: image,
            //     }),*/
            //     'LineString': new Style({
            //         stroke: new Stroke({
            //             color: 'green',
            //             width: 1,
            //         }),
            //     }),
            //     'MultiLineString': new Style({
            //         stroke: new Stroke({
            //             color: 'green',
            //             width: 1,
            //         }),
            //     }),
            //     /*'MultiPoint': new Style({
            //         image: image,
            //     }),*/
            //     'MultiPolygon': new Style({
            //         stroke: new Stroke({
            //             color: 'yellow',
            //             width: 1,
            //         }),
            //         fill: new Fill({
            //             color: 'rgba(219,130,62,0.82)',
            //         }),
            //     }),
            //     'Polygon': new Style({
            //         stroke: new Stroke({
            //             color: 'blue',
            //             lineDash: [4],
            //             width: 3,
            //         }),
            //         fill: new Fill({
            //             color: 'rgba(159,234,29,0.86)',
            //         }),
            //     }),
            //     'GeometryCollection': new Style({
            //         stroke: new Stroke({
            //             color: 'magenta',
            //             width: 2,
            //         }),
            //         fill: new Fill({
            //             color: 'magenta',
            //         }),
            //         image: new CircleStyle({
            //             radius: 10,
            //             fill: null,
            //             stroke: new Stroke({
            //                 color: 'magenta',
            //             }),
            //         }),
            //     }),
            //     'Circle': new Style({
            //         stroke: new Stroke({
            //             color: 'rgba(239,101,161,0.89)',
            //             width: 2,
            //         }),
            //         fill: new Fill({
            //             color: 'rgba(255,0,0,0.2)',
            //         }),
            //     }),
            // };
            // const styleFunction = function (feature) {
            //     return styles[feature.getGeometry().getType()];
            // };
            // const vectorLayer = new VectorLayer({
            //     source: vectorSource,
            //     style: styleFunction,
            // });
            // const r = await fetch('out.tif');
            // const blob = await r.blob();               
            source = new GeoTIFFSource({
              sources: [{
                url: 'out.tif'
              }]
            });
            rasterLayer = new WebGLTileLayer({
              source: source
            });
            new Map$1({
              target: 'map',
              layers: [new TileLayer({
                source: new OSM()
              }), rasterLayer],
              view: new View({
                center: [0, 0],
                zoom: 12
              })
            });

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

})();
//# sourceMappingURL=index.js.map
